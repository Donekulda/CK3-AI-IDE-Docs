{
    "add_dynasty_modifier": {
        "desc": "Add a modifier to a dynasty",
        "usage": "add_dynasty_modifier = name\nadd_dynasty_modifier = { modifier = name days/weeks/months/years = int }",
        "supported_scopes": "dynasty",
        "supported_targets": null,
        "notes": null
    },
    "add_dynasty_perk": {
        "desc": "Adds dynasty perk. add_dynasty_perk = key",
        "usage": "",
        "supported_scopes": "dynasty",
        "supported_targets": null,
        "notes": null
    },
    "add_dynasty_prestige": {
        "desc": "adds dynasty prestige",
        "usage": "",
        "supported_scopes": "dynasty",
        "supported_targets": null,
        "notes": null
    },
    "add_dynasty_prestige_level": {
        "desc": "adds dynasty prestige levels",
        "usage": "",
        "supported_scopes": "dynasty",
        "supported_targets": null,
        "notes": null
    },
    "every_dynasty_member": {
        "desc": "Iterate through all dynasty members",
        "usage": "every_dynasty_member = { limit = { <triggers> } <effects> }",
        "supported_scopes": "dynasty",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_dynasty_member": {
        "desc": "Iterate through all dynasty members",
        "usage": "ordered_dynasty_member = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "dynasty",
        "supported_targets": "character",
        "notes": null
    },
    "random_dynasty_member": {
        "desc": "Iterate through all dynasty members",
        "usage": "random_dynasty_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "dynasty",
        "supported_targets": "character",
        "notes": null
    },
    "remove_all_dynasty_modifier_instances": {
        "desc": "Remove all instances of a modifier from a dynasty",
        "usage": "remove_all_dynasty_modifier_instances = name",
        "supported_scopes": "dynasty",
        "supported_targets": null,
        "notes": null
    },
    "remove_dynasty_modifier": {
        "desc": "Remove a modifier from a dynasty",
        "usage": "remove_dynasty_modifier = name",
        "supported_scopes": "dynasty",
        "supported_targets": null,
        "notes": null
    },
    "remove_dynasty_perk": {
        "desc": "Removes dynasty perk. remove_dynasty_perk = key",
        "usage": "",
        "supported_scopes": "dynasty",
        "supported_targets": null,
        "notes": null
    },
    "set_dynasty_name": {
        "desc": "Sets dynasty name",
        "usage": "set_dynasty_name=loc_key",
        "supported_scopes": "dynasty",
        "supported_targets": null,
        "notes": null
    },
    "add_activity_log_entry": {
        "desc": "add_activity_log_entry = {",
        "usage": "key = <loc_key>\nscore = <script_value>\ntags = { <a> <b> <c> } # Optional\nshow_in_conclusion = yes/no # Optional, defaults to no\ncharacter = <character>\ntarget = <character> # Optional\nlocation = <province> # Optional, defaults to current activity loction\nartifact = <artifact> # Optional",
        "supported_scopes": "activity",
        "supported_targets": null,
        "notes": null
    },
    "add_to_current_phase_guest_subset": {
        "desc": "add_to_current_phase_guest_subset = {",
        "usage": "name = <subset_key>\ntarget = scope:character",
        "supported_scopes": "activity",
        "supported_targets": null,
        "notes": null
    },
    "add_to_guest_subset": {
        "desc": "add_to_guest_subset = {",
        "usage": "name = <subset_key>\ntarget = scope:character\nphase = <phase_key> # Optional",
        "supported_scopes": "activity",
        "supported_targets": null,
        "notes": null
    },
    "every_activity_phase_location": {
        "desc": "Iterate through all province locations of the phases of the activity, optionally limited to unique locations.",
        "usage": "unique = yes/no\nevery_activity_phase_location = { limit = { <triggers> } <effects> }",
        "supported_scopes": "activity",
        "supported_targets": "province",
        "notes": "any/every/random_activity_phase_location {"
    },
    "every_activity_phase_location_future": {
        "desc": "Iterate through all future province locations of the phases of the activity, optionally limited to unique locations. ('future' does not include any started phase)",
        "usage": "unique = yes/no\nevery_activity_phase_location_future = { limit = { <triggers> } <effects> }",
        "supported_scopes": "activity",
        "supported_targets": "province",
        "notes": "any/every/random_activity_phase_location_future {"
    },
    "every_activity_phase_location_past": {
        "desc": "Iterate through all past province locations of the phases of the activity, optionally limited to unique locations. ('past' only includes ended phases)",
        "usage": "unique = yes/no\nevery_activity_phase_location_past = { limit = { <triggers> } <effects> }",
        "supported_scopes": "activity",
        "supported_targets": "province",
        "notes": "any/every/random_activity_phase_location_future {"
    },
    "every_attending_character": {
        "desc": "Iterate through all characters attending an activity.",
        "usage": "any_attending_character = { state = travel/passive/active }\nevery_attending_character = { limit = { <triggers> } <effects> }",
        "supported_scopes": "activity",
        "supported_targets": "character",
        "notes": "Invited guests that have not accepted/declined yet are not part of this list. Supports an optional state the character must be in."
    },
    "every_guest_subset": {
        "desc": "any/every/random_guest_subset = {",
        "usage": "name = <subset_key>\nphase = <phase_key> # Optional\nevery_guest_subset = { limit = { <triggers> } <effects> }",
        "supported_scopes": "activity",
        "supported_targets": "character",
        "notes": null
    },
    "every_guest_subset_current_phase": {
        "desc": "any/every/random_guest_subset_current_phase = {",
        "usage": "name = <subset_key>\nevery_guest_subset_current_phase = { limit = { <triggers> } <effects> }",
        "supported_scopes": "activity",
        "supported_targets": "character",
        "notes": null
    },
    "every_invited_character": {
        "desc": "Iterate through all characters invited to an activity. Once they accept/decline, they are removed from this list.",
        "usage": "every_invited_character = { limit = { <triggers> } <effects> }",
        "supported_scopes": "activity",
        "supported_targets": "character",
        "notes": null
    },
    "every_special_guest": {
        "desc": "Iterate through all special guests of an activity.",
        "usage": "any_special_guest = { ... }\nevery_special_guest = { limit = { <triggers> } <effects> }",
        "supported_scopes": "activity",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_activity_phase_location": {
        "desc": "Iterate through all province locations of the phases of the activity, optionally limited to unique locations.",
        "usage": "unique = yes/no\nordered_activity_phase_location = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "activity",
        "supported_targets": "province",
        "notes": "any/every/random_activity_phase_location {"
    },
    "ordered_activity_phase_location_future": {
        "desc": "Iterate through all future province locations of the phases of the activity, optionally limited to unique locations. ('future' does not include any started phase)",
        "usage": "unique = yes/no\nordered_activity_phase_location_future = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "activity",
        "supported_targets": "province",
        "notes": "any/every/random_activity_phase_location_future {"
    },
    "ordered_activity_phase_location_past": {
        "desc": "Iterate through all past province locations of the phases of the activity, optionally limited to unique locations. ('past' only includes ended phases)",
        "usage": "unique = yes/no\nordered_activity_phase_location_past = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "activity",
        "supported_targets": "province",
        "notes": "any/every/random_activity_phase_location_future {"
    },
    "ordered_attending_character": {
        "desc": "Iterate through all characters attending an activity.",
        "usage": "any_attending_character = { state = travel/passive/active }\nordered_attending_character = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "activity",
        "supported_targets": "character",
        "notes": "Invited guests that have not accepted/declined yet are not part of this list. Supports an optional state the character must be in."
    },
    "ordered_guest_subset": {
        "desc": "any/every/random_guest_subset = {",
        "usage": "name = <subset_key>\nphase = <phase_key> # Optional\nordered_guest_subset = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "activity",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_guest_subset_current_phase": {
        "desc": "any/every/random_guest_subset_current_phase = {",
        "usage": "name = <subset_key>\nordered_guest_subset_current_phase = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "activity",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_invited_character": {
        "desc": "Iterate through all characters invited to an activity. Once they accept/decline, they are removed from this list.",
        "usage": "ordered_invited_character = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "activity",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_special_guest": {
        "desc": "Iterate through all special guests of an activity.",
        "usage": "any_special_guest = { ... }\nordered_special_guest = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "activity",
        "supported_targets": "character",
        "notes": null
    },
    "progress_activity_phase_after": {
        "desc": "Progress the current activity phase forward after X days.",
        "usage": "progress_activity_phase_after = { days = X weeks = Z months = Y}",
        "supported_scopes": "activity",
        "supported_targets": null,
        "notes": null
    },
    "random_activity_phase_location": {
        "desc": "Iterate through all province locations of the phases of the activity, optionally limited to unique locations.",
        "usage": "unique = yes/no\nrandom_activity_phase_location = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "activity",
        "supported_targets": "province",
        "notes": "any/every/random_activity_phase_location {"
    },
    "random_activity_phase_location_future": {
        "desc": "Iterate through all future province locations of the phases of the activity, optionally limited to unique locations. ('future' does not include any started phase)",
        "usage": "unique = yes/no\nrandom_activity_phase_location_future = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "activity",
        "supported_targets": "province",
        "notes": "any/every/random_activity_phase_location_future {"
    },
    "random_activity_phase_location_past": {
        "desc": "Iterate through all past province locations of the phases of the activity, optionally limited to unique locations. ('past' only includes ended phases)",
        "usage": "unique = yes/no\nrandom_activity_phase_location_past = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "activity",
        "supported_targets": "province",
        "notes": "any/every/random_activity_phase_location_future {"
    },
    "random_attending_character": {
        "desc": "Iterate through all characters attending an activity.",
        "usage": "any_attending_character = { state = travel/passive/active }\nrandom_attending_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "activity",
        "supported_targets": "character",
        "notes": "Invited guests that have not accepted/declined yet are not part of this list. Supports an optional state the character must be in."
    },
    "random_guest_subset": {
        "desc": "any/every/random_guest_subset = {",
        "usage": "name = <subset_key>\nphase = <phase_key> # Optional\nrandom_guest_subset = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "activity",
        "supported_targets": "character",
        "notes": null
    },
    "random_guest_subset_current_phase": {
        "desc": "any/every/random_guest_subset_current_phase = {",
        "usage": "name = <subset_key>\nrandom_guest_subset_current_phase = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "activity",
        "supported_targets": "character",
        "notes": null
    },
    "random_invited_character": {
        "desc": "Iterate through all characters invited to an activity. Once they accept/decline, they are removed from this list.",
        "usage": "random_invited_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "activity",
        "supported_targets": "character",
        "notes": null
    },
    "random_special_guest": {
        "desc": "Iterate through all special guests of an activity.",
        "usage": "any_special_guest = { ... }\nrandom_special_guest = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "activity",
        "supported_targets": "character",
        "notes": null
    },
    "remove_from_current_phase_guest_subset": {
        "desc": "remove_from_current_phase_guest_subset = {",
        "usage": "name = <subset_key>\ntarget = scope:character",
        "supported_scopes": "activity",
        "supported_targets": null,
        "notes": null
    },
    "remove_from_guest_subset": {
        "desc": "add_to_guest_subset = {",
        "usage": "name = <subset_key>\ntarget = scope:character\nphase = <phase_key> # Optional",
        "supported_scopes": "activity",
        "supported_targets": null,
        "notes": null
    },
    "set_activity_host": {
        "desc": "set_activity_host = character",
        "usage": "",
        "supported_scopes": "activity",
        "supported_targets": "character",
        "notes": "The host of the scoped activity is set to the target character"
    },
    "skip_activity_phase": {
        "desc": "Skip the current activity phase, either directly to the next phase, or to completion. (fast-forwards) skip_activity_phase = yes/no.",
        "usage": "",
        "supported_scopes": "activity",
        "supported_targets": null,
        "notes": null
    },
    "add_culture_tradition": {
        "desc": "Adds the cultural tradition scope specified in the RHS to the scope culture.add_culture_tradition = tradition_court_eunuchs",
        "usage": "",
        "supported_scopes": "culture",
        "supported_targets": "culture_tradition",
        "notes": null
    },
    "add_innovation": {
        "desc": "Add innovation to a culture. add_innovation = innovation_key",
        "usage": "",
        "supported_scopes": "culture",
        "supported_targets": null,
        "notes": null
    },
    "add_name_list": {
        "desc": "Adds the name list to the culture",
        "usage": "<culture> = { add_name_list = name }",
        "supported_scopes": "culture",
        "supported_targets": null,
        "notes": null
    },
    "add_random_innovation": {
        "desc": "Add random available innovation<culture> = { add_random_innovation = culture_group_military/culture_group_civic/culture_group_regional/yes }",
        "usage": "",
        "supported_scopes": "culture",
        "supported_targets": null,
        "notes": null
    },
    "add_random_valid_tradition": {
        "desc": "Adds one random valid tradition to a culture. Target character provides context for can_pick and is_shown. If this would put the culture over the tradition limit, an error is loggedadd_random_valid_tradition = scope:character",
        "usage": "",
        "supported_scopes": "culture",
        "supported_targets": "character",
        "notes": null
    },
    "add_random_valid_tradition_replace_if_necessary": {
        "desc": "Adds one random valid tradition to a culture. Target character provides context for can_pick and is_shown. If this would put the culture over the tradition limit, a random existing tradition is removedadd_random_valid_tradition_replace_if_necessary = scope:character",
        "usage": "",
        "supported_scopes": "culture",
        "supported_targets": "character",
        "notes": null
    },
    "change_cultural_acceptance": {
        "desc": "Changes cultural acceptance with the target culture",
        "usage": "change_cultural_acceptance = {\ntarget = <culture>\nvalue = script value\ndesc = dynamic desc. Description that'll show when hovering over the acceptance tooltip in the culture window",
        "supported_scopes": "culture",
        "supported_targets": null,
        "notes": null
    },
    "clear_culture_traditions": {
        "desc": "Removes all cultural traditions from the scope culture.clear_culture_traditions = yes",
        "usage": "",
        "supported_scopes": "culture",
        "supported_targets": null,
        "notes": null
    },
    "copy_all_traditions_from": {
        "desc": "Replaces all traditions of scoped culture with traditions from the given culturecopy_all_traditions_from = scope:target_culture",
        "usage": "",
        "supported_scopes": "culture",
        "supported_targets": "culture",
        "notes": null
    },
    "every_culture_county": {
        "desc": "Iterate through all counties of the culture",
        "usage": "every_culture_county = { limit = { <triggers> } <effects> }",
        "supported_scopes": "culture",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_culture_duchy": {
        "desc": "Iterate through all duchies of the culture (duchies with at least one county of the culture",
        "usage": "every_culture_duchy = { limit = { <triggers> } <effects> }",
        "supported_scopes": "culture",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_culture_empire": {
        "desc": "Iterate through all empires of the culture (empires with at least one county of the culture",
        "usage": "every_culture_empire = { limit = { <triggers> } <effects> }",
        "supported_scopes": "culture",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_culture_kingdom": {
        "desc": "Iterate through all kingdoms of the culture (kingdoms with at least one county of the culture",
        "usage": "every_culture_kingdom = { limit = { <triggers> } <effects> }",
        "supported_scopes": "culture",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_parent_culture": {
        "desc": "Iterate through all parent cultures",
        "usage": "every_parent_culture = { limit = { <triggers> } <effects> }",
        "supported_scopes": "culture",
        "supported_targets": "culture",
        "notes": null
    },
    "every_parent_culture_or_above": {
        "desc": "Iterate through all parent cultures or above",
        "usage": "every_parent_culture_or_above = { limit = { <triggers> } <effects> }",
        "supported_scopes": "culture",
        "supported_targets": "culture",
        "notes": null
    },
    "every_tradition": {
        "desc": "Iterate through all traditions of the given culture",
        "usage": "every_tradition = { limit = { <triggers> } <effects> }",
        "supported_scopes": "culture",
        "supported_targets": "culture_tradition",
        "notes": null
    },
    "get_all_innovations_from": {
        "desc": "Discover all innovations from the target culture",
        "usage": "get_all_innovations_from = <culture>",
        "supported_scopes": "culture",
        "supported_targets": "culture",
        "notes": null
    },
    "get_random_innovation_from": {
        "desc": "Get random available innovation from another culture",
        "usage": "",
        "supported_scopes": "culture",
        "supported_targets": null,
        "notes": null
    },
    "join_era": {
        "desc": "Joins all culture eras up to and including the given one",
        "usage": "join_era = culture_era_type",
        "supported_scopes": "culture",
        "supported_targets": null,
        "notes": null
    },
    "leave_era": {
        "desc": "Leaves all culture eras down to and including the given one",
        "usage": "leave_era = culture_era_type",
        "supported_scopes": "culture",
        "supported_targets": null,
        "notes": null
    },
    "ordered_culture_county": {
        "desc": "Iterate through all counties of the culture",
        "usage": "ordered_culture_county = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "culture",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_culture_duchy": {
        "desc": "Iterate through all duchies of the culture (duchies with at least one county of the culture",
        "usage": "ordered_culture_duchy = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "culture",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_culture_empire": {
        "desc": "Iterate through all empires of the culture (empires with at least one county of the culture",
        "usage": "ordered_culture_empire = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "culture",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_culture_kingdom": {
        "desc": "Iterate through all kingdoms of the culture (kingdoms with at least one county of the culture",
        "usage": "ordered_culture_kingdom = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "culture",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_parent_culture": {
        "desc": "Iterate through all parent cultures",
        "usage": "ordered_parent_culture = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "culture",
        "supported_targets": "culture",
        "notes": null
    },
    "ordered_parent_culture_or_above": {
        "desc": "Iterate through all parent cultures or above",
        "usage": "ordered_parent_culture_or_above = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "culture",
        "supported_targets": "culture",
        "notes": null
    },
    "ordered_tradition": {
        "desc": "Iterate through all traditions of the given culture",
        "usage": "ordered_tradition = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "culture",
        "supported_targets": "culture_tradition",
        "notes": null
    },
    "random_culture_county": {
        "desc": "Iterate through all counties of the culture",
        "usage": "random_culture_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "culture",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_culture_duchy": {
        "desc": "Iterate through all duchies of the culture (duchies with at least one county of the culture",
        "usage": "random_culture_duchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "culture",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_culture_empire": {
        "desc": "Iterate through all empires of the culture (empires with at least one county of the culture",
        "usage": "random_culture_empire = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "culture",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_culture_kingdom": {
        "desc": "Iterate through all kingdoms of the culture (kingdoms with at least one county of the culture",
        "usage": "random_culture_kingdom = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "culture",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_parent_culture": {
        "desc": "Iterate through all parent cultures",
        "usage": "random_parent_culture = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "culture",
        "supported_targets": "culture",
        "notes": null
    },
    "random_parent_culture_or_above": {
        "desc": "Iterate through all parent cultures or above",
        "usage": "random_parent_culture_or_above = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "culture",
        "supported_targets": "culture",
        "notes": null
    },
    "random_tradition": {
        "desc": "Iterate through all traditions of the given culture",
        "usage": "random_tradition = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "culture",
        "supported_targets": "culture_tradition",
        "notes": null
    },
    "remove_culture_tradition": {
        "desc": "Removes the cultural tradition scope specified in the RHS from the scope culture.remove_culture_tradition = tradition_court_eunuchs",
        "usage": "",
        "supported_scopes": "culture",
        "supported_targets": "culture_tradition",
        "notes": null
    },
    "remove_innovation": {
        "desc": "Remove innovation from a culture. remove_innovation = innovation_key",
        "usage": "",
        "supported_scopes": "culture",
        "supported_targets": null,
        "notes": null
    },
    "remove_random_culture_tradition": {
        "desc": "Removes a random cultural tradition from the scope culture.remove_random_culture_tradition = yes",
        "usage": "",
        "supported_scopes": "culture",
        "supported_targets": null,
        "notes": null
    },
    "reset_culture_creation_date": {
        "desc": "Sets the culture creation date to be todays datereset_culture_creation_date = yes",
        "usage": "",
        "supported_scopes": "culture",
        "supported_targets": null,
        "notes": null
    },
    "set_cultural_acceptance": {
        "desc": "Sets cultural acceptance with the target culture",
        "usage": "set_cultural_accpetance = { target = <culture> value = script value }",
        "supported_scopes": "culture",
        "supported_targets": null,
        "notes": null
    },
    "set_culture_name": {
        "desc": "Permanently sets the name of the scope culture to the parsed text from the provided localization string.",
        "usage": "Like 'set_title_name', the new name is static and unchanging (i.e., if the localization key provided is 'Neo-[old_culture.GetName]' and the old culture is French, the new name is just be saved as a simple string, 'Neo-French', so that if/when the old_culture scope is cleaned up the localization does not break.set_culture_name = {\nnoun = dynamic description\ncollective_noun = dynamic description\nprefix = dynamic description",
        "supported_scopes": "culture",
        "supported_targets": null,
        "notes": null
    },
    "set_culture_pillar": {
        "desc": "Adds the current pillar specified in the RHS to the scope culture, replacing the pillar in the matching slot.set_culture_pillar = ethos_warmonger",
        "usage": "",
        "supported_scopes": "culture",
        "supported_targets": null,
        "notes": null
    },
    "set_ethos_from": {
        "desc": "Set the ethos from the RHS on the scope culture.set_ethos_from = culture:norwegian",
        "usage": "",
        "supported_scopes": "culture",
        "supported_targets": "culture",
        "notes": null
    },
    "set_heritage_from": {
        "desc": "Set the heritage from the RHS on the scope culture.set_heritage_from = culture:norwegian",
        "usage": "",
        "supported_scopes": "culture",
        "supported_targets": "culture",
        "notes": null
    },
    "set_language_from": {
        "desc": "Set the language from the RHS on the scope culture.set_language_from = culture:norwegian",
        "usage": "",
        "supported_scopes": "culture",
        "supported_targets": "culture",
        "notes": null
    },
    "set_martial_custom_from": {
        "desc": "Set the martial custom from the RHS on the scope culture.set_martial_custom_from = culture:norwegian",
        "usage": "",
        "supported_scopes": "culture",
        "supported_targets": "culture",
        "notes": null
    },
    "set_name_list": {
        "desc": "Remove all existing name lists then adds the specified name list to the culture",
        "usage": "<culture> = { set_name_list = name }",
        "supported_scopes": "culture",
        "supported_targets": null,
        "notes": null
    },
    "every_memory_participant": {
        "desc": "Iterate through all participating character of a memory",
        "usage": "every_memory_participant = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character_memory",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_memory_participant": {
        "desc": "Iterate through all participating character of a memory",
        "usage": "ordered_memory_participant = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character_memory",
        "supported_targets": "character",
        "notes": null
    },
    "random_memory_participant": {
        "desc": "Iterate through all participating character of a memory",
        "usage": "random_memory_participant = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character_memory",
        "supported_targets": "character",
        "notes": null
    },
    "change_maa_regiment_size": {
        "desc": "Change size of MaA regiment by the specified value.",
        "usage": "unless reinforce = yes is used\nscope:regiment = {\nchange_maa_regiment_size = scope:change_by\nchange_maa_regiment_size = {\nsize = 5\nreinforce = yes",
        "supported_scopes": "regiment",
        "supported_targets": null,
        "notes": "Extra troops are deleted, by default new troops will have to reinforce,"
    },
    "change_maa_troops_count": {
        "desc": "Change current troops count of MaA regiment. It can't exceed max troops count",
        "usage": "scope:regiment = { change_maa_troops_count = value }",
        "supported_scopes": "regiment",
        "supported_targets": null,
        "notes": null
    },
    "destroy_maa_regiment": {
        "desc": "Destroy MaA regiment",
        "usage": "scope:regiment = {\ndestroy_maa_regiment = yes",
        "supported_scopes": "regiment",
        "supported_targets": null,
        "notes": "Doesn't work on regiments that belong to mercenary companies and holy orders"
    },
    "transfer_title_maa": {
        "desc": "Transfet title MaA regiment to another title",
        "usage": "",
        "supported_scopes": "regiment",
        "supported_targets": "landed_title",
        "notes": null
    },
    "add_confederation_member": {
        "desc": "Adds a character to the scoped confederation, unless they're already part of one.The target character must have their primary title tier lower than the confederation title's tier.This will also make the character a vassal of the confederation leader.add_member = CHARACTER",
        "usage": "",
        "supported_scopes": "confederation",
        "supported_targets": "character",
        "notes": null
    },
    "disband_confederation": {
        "desc": "Disbands the scoped confederation, destroying the confederation title.disband_confederation = yes",
        "usage": "",
        "supported_scopes": "confederation",
        "supported_targets": null,
        "notes": null
    },
    "every_confederation_member": {
        "desc": "Iterates through all members of the scoped confederation",
        "usage": "every_confederation_member = { limit = { <triggers> } <effects> }",
        "supported_scopes": "confederation",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_confederation_member": {
        "desc": "Iterates through all members of the scoped confederation",
        "usage": "ordered_confederation_member = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "confederation",
        "supported_targets": "character",
        "notes": null
    },
    "random_confederation_member": {
        "desc": "Iterates through all members of the scoped confederation",
        "usage": "random_confederation_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "confederation",
        "supported_targets": "character",
        "notes": null
    },
    "remove_confederation_member": {
        "desc": "Removes the target character from the scoped confederation.The holder of the confederation title cannot be removed.remove_member = CHARACTER",
        "usage": "",
        "supported_scopes": "confederation",
        "supported_targets": "character",
        "notes": null
    },
    "generate_coa": {
        "desc": "Generates a coat of arms for the scoped landed title, dynasty or house",
        "usage": "generate_coa = yes",
        "supported_scopes": "landed_title, dynasty, dynasty_house, confederation",
        "supported_targets": null,
        "notes": null
    },
    "reset_coa": {
        "desc": "Rest the coat of arms for the scoped landed title, dynasty or house to its template",
        "usage": "reset_coa = yes",
        "supported_scopes": "landed_title, dynasty, dynasty_house, confederation",
        "supported_targets": null,
        "notes": null
    },
    "set_coa": {
        "desc": "Sets the coat of arms of a landed title, dynasty, or house to the right hand side coat of arms or that of an object of the same type",
        "usage": "set_coa = k_england\nset_coa = scope:new_coa",
        "supported_scopes": "landed_title, dynasty, dynasty_house, confederation",
        "supported_targets": null,
        "notes": null
    },
    "every_opposite_trait": {
        "desc": "Iterate through all opposite traits of the scoped trait",
        "usage": "every_opposite_trait = { limit = { <triggers> } <effects> }",
        "supported_scopes": "trait",
        "supported_targets": "trait",
        "notes": null
    },
    "ordered_opposite_trait": {
        "desc": "Iterate through all opposite traits of the scoped trait",
        "usage": "ordered_opposite_trait = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "trait",
        "supported_targets": "trait",
        "notes": null
    },
    "random_opposite_trait": {
        "desc": "Iterate through all opposite traits of the scoped trait",
        "usage": "random_opposite_trait = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "trait",
        "supported_targets": "trait",
        "notes": null
    },
    "add_house_artifact_claim": {
        "desc": "Adds a claim on the target artifact to the scoped house",
        "usage": "",
        "supported_scopes": "dynasty_house",
        "supported_targets": "artifact",
        "notes": null
    },
    "add_house_modifier": {
        "desc": "Add a modifier to a house",
        "usage": "add_house_modifier = name\nadd_house_modifier = { modifier = name days/weeks/months/years = int }",
        "supported_scopes": "dynasty_house",
        "supported_targets": null,
        "notes": null
    },
    "add_house_unity_modifier": {
        "desc": "Add a modifier to a house",
        "usage": "add_house_unity_modifier = name\nadd_house_unity_modifier = { modifier = name days/weeks/months/years = int }",
        "supported_scopes": "dynasty_house",
        "supported_targets": null,
        "notes": null
    },
    "add_unity_value": {
        "desc": "Adds value to the house unity.",
        "usage": "add_unity_value = {\nvalue = VALUE\ncharacter = CHARACTER\ndesc = localization_key",
        "supported_scopes": "dynasty_house",
        "supported_targets": null,
        "notes": "Usage:"
    },
    "every_house_claimed_artifact": {
        "desc": "Iterate through all claimed artifacts of the scoped house",
        "usage": "every_house_claimed_artifact = { limit = { <triggers> } <effects> }",
        "supported_scopes": "dynasty_house",
        "supported_targets": "artifact",
        "notes": null
    },
    "every_house_member": {
        "desc": "Iterate through all house members",
        "usage": "every_house_member = { limit = { <triggers> } <effects> }",
        "supported_scopes": "dynasty_house",
        "supported_targets": "character",
        "notes": null
    },
    "every_house_unity_member": {
        "desc": "Iterate through all valid house unity members",
        "usage": "every_house_unity_member = { limit = { <triggers> } <effects> }",
        "supported_scopes": "dynasty_house",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_house_claimed_artifact": {
        "desc": "Iterate through all claimed artifacts of the scoped house",
        "usage": "ordered_house_claimed_artifact = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "dynasty_house",
        "supported_targets": "artifact",
        "notes": null
    },
    "ordered_house_member": {
        "desc": "Iterate through all house members",
        "usage": "ordered_house_member = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "dynasty_house",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_house_unity_member": {
        "desc": "Iterate through all valid house unity members",
        "usage": "ordered_house_unity_member = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "dynasty_house",
        "supported_targets": "character",
        "notes": null
    },
    "random_house_claimed_artifact": {
        "desc": "Iterate through all claimed artifacts of the scoped house",
        "usage": "random_house_claimed_artifact = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "dynasty_house",
        "supported_targets": "artifact",
        "notes": null
    },
    "random_house_member": {
        "desc": "Iterate through all house members",
        "usage": "random_house_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "dynasty_house",
        "supported_targets": "character",
        "notes": null
    },
    "random_house_unity_member": {
        "desc": "Iterate through all valid house unity members",
        "usage": "random_house_unity_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "dynasty_house",
        "supported_targets": "character",
        "notes": null
    },
    "remove_all_house_modifier_instances": {
        "desc": "Remove all instances of a modifier from a house",
        "usage": "remove_all_house_modifier_instances = name",
        "supported_scopes": "dynasty_house",
        "supported_targets": null,
        "notes": null
    },
    "remove_all_house_unity_modifier_instances": {
        "desc": "Remove all instances of a modifier from a house unity",
        "usage": "remove_all_house_unity_modifier_instances = name",
        "supported_scopes": "dynasty_house",
        "supported_targets": null,
        "notes": null
    },
    "remove_house_artifact_claim": {
        "desc": "Removes a claim on the target artifact from the scoped house",
        "usage": "",
        "supported_scopes": "dynasty_house",
        "supported_targets": "artifact",
        "notes": null
    },
    "remove_house_modifier": {
        "desc": "Remove a modifier from a house",
        "usage": "remove_house_modifier = name",
        "supported_scopes": "dynasty_house",
        "supported_targets": null,
        "notes": null
    },
    "remove_house_unity_modifier": {
        "desc": "Remove a modifier from a house unity",
        "usage": "remove_house_unity_modifier = name",
        "supported_scopes": "dynasty_house",
        "supported_targets": null,
        "notes": null
    },
    "set_house_head": {
        "desc": "Set house head for the house. Also transfers noble family title. Usage:",
        "usage": "set_house_head = <character>",
        "supported_scopes": "dynasty_house",
        "supported_targets": "character",
        "notes": null
    },
    "set_house_name": {
        "desc": "Sets dynasty house name",
        "usage": "set_house_name=loc_key",
        "supported_scopes": "dynasty_house",
        "supported_targets": null,
        "notes": null
    },
    "set_house_name_from_dynasty": {
        "desc": "Sets dynasty house name from another dynasty's name",
        "usage": "set_house_name_from_dynasty = dynasty",
        "supported_scopes": "dynasty_house",
        "supported_targets": "dynasty",
        "notes": null
    },
    "set_house_name_from_house": {
        "desc": "Sets dynasty house name from another dynasty house's name",
        "usage": "set_house_name_from_house = house",
        "supported_scopes": "dynasty_house",
        "supported_targets": "dynasty_house",
        "notes": null
    },
    "complete_task_contract": {
        "desc": "complete_task_contract = task_contract_reward",
        "usage": "",
        "supported_scopes": "task_contract",
        "supported_targets": null,
        "notes": null
    },
    "invalidate_contract": {
        "desc": "Invalidate contract",
        "usage": "invalidate_contract = yes/no",
        "supported_scopes": "task_contract",
        "supported_targets": null,
        "notes": null
    },
    "set_task_contract_target": {
        "desc": "set_task_task_contract_target = CHARACTER_SCOPE",
        "usage": "",
        "supported_scopes": "task_contract",
        "supported_targets": "character",
        "notes": null
    },
    "add_secret_participant": {
        "desc": "Adds an participant to the secret",
        "usage": "",
        "supported_scopes": "secret",
        "supported_targets": "character",
        "notes": null
    },
    "disable_exposure_by": {
        "desc": "Forbids the target character from exposing the secret, disable_exposure_by = target_character",
        "usage": "",
        "supported_scopes": "secret",
        "supported_targets": "character",
        "notes": null
    },
    "every_secret_knower": {
        "desc": "Iterate through all characters who know the secret",
        "usage": "every_secret_knower = { limit = { <triggers> } <effects> }",
        "supported_scopes": "secret",
        "supported_targets": "character",
        "notes": null
    },
    "every_secret_participant": {
        "desc": "Iterate through participants in a secret",
        "usage": "every_secret_participant = { limit = { <triggers> } <effects> }",
        "supported_scopes": "secret",
        "supported_targets": "character",
        "notes": null
    },
    "expose_secret": {
        "desc": "Exposes the scope secret",
        "usage": "",
        "supported_scopes": "secret",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_secret_knower": {
        "desc": "Iterate through all characters who know the secret",
        "usage": "ordered_secret_knower = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "secret",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_secret_participant": {
        "desc": "Iterate through participants in a secret",
        "usage": "ordered_secret_participant = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "secret",
        "supported_targets": "character",
        "notes": null
    },
    "random_secret_knower": {
        "desc": "Iterate through all characters who know the secret",
        "usage": "random_secret_knower = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "secret",
        "supported_targets": "character",
        "notes": null
    },
    "random_secret_participant": {
        "desc": "Iterate through participants in a secret",
        "usage": "random_secret_participant = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "secret",
        "supported_targets": "character",
        "notes": null
    },
    "remove_secret": {
        "desc": "Removes the scope secret",
        "usage": "",
        "supported_scopes": "secret",
        "supported_targets": null,
        "notes": null
    },
    "reveal_to": {
        "desc": "Reveals the scope secret to the target character",
        "usage": "",
        "supported_scopes": "secret",
        "supported_targets": "character",
        "notes": null
    },
    "set_secret_owner": {
        "desc": "Sets a new owner for the secret",
        "usage": "",
        "supported_scopes": "secret",
        "supported_targets": "character",
        "notes": null
    },
    "spend_by": {
        "desc": "Spends the scope secret, spend_by = target_character",
        "usage": "",
        "supported_scopes": "secret",
        "supported_targets": "character",
        "notes": null
    },
    "every_faith": {
        "desc": "Iterate through all faiths within a religion",
        "usage": "every_faith = { limit = { <triggers> } <effects> }",
        "supported_scopes": "religion",
        "supported_targets": "faith",
        "notes": null
    },
    "ordered_faith": {
        "desc": "Iterate through all faiths within a religion",
        "usage": "ordered_faith = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "religion",
        "supported_targets": "faith",
        "notes": null
    },
    "random_faith": {
        "desc": "Iterate through all faiths within a religion",
        "usage": "random_faith = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "religion",
        "supported_targets": "faith",
        "notes": null
    },
    "add_loot": {
        "desc": "Adds loot to the currently scoped raiding army.",
        "usage": "add_loot = VALUE",
        "supported_scopes": "army",
        "supported_targets": null,
        "notes": "Usage:"
    },
    "add_supply": {
        "desc": "Adds the designated supply to the army's supply. Cannot exceed the",
        "usage": "scope:army = { add_supply = 20 }",
        "supported_scopes": "army",
        "supported_targets": null,
        "notes": "army's max supply capacity."
    },
    "assign_commander": {
        "desc": "Assign a commander for the scoped army",
        "usage": "set_commander = scope:a_character",
        "supported_scopes": "army",
        "supported_targets": "character",
        "notes": null
    },
    "clear_supply": {
        "desc": "Clears the designated army's supply.",
        "usage": "scope:army = { clear_supply = yes }",
        "supported_scopes": "army",
        "supported_targets": null,
        "notes": null
    },
    "deplete_army_by_percentage": {
        "desc": "Reduce current army size by the giver percentage",
        "usage": "scope:army = { deplete_army_by_percentage = 0.2 }",
        "supported_scopes": "army",
        "supported_targets": null,
        "notes": "Value on the right side determines what portions of soldiers shall perish"
    },
    "every_army_maa_regiment": {
        "desc": "Iterate through all MaA regiments in the army",
        "usage": "scope:army = {\nany_army_maa_regiment = {\ninclude_hired = yes # should it include merc and holy order regiments (yes by default)\nevery_army_maa_regiment = { limit = { <triggers> } <effects> }",
        "supported_scopes": "army",
        "supported_targets": "regiment",
        "notes": null
    },
    "ordered_army_maa_regiment": {
        "desc": "Iterate through all MaA regiments in the army",
        "usage": "scope:army = {\nany_army_maa_regiment = {\ninclude_hired = yes # should it include merc and holy order regiments (yes by default)\nordered_army_maa_regiment = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "army",
        "supported_targets": "regiment",
        "notes": null
    },
    "random_army_maa_regiment": {
        "desc": "Iterate through all MaA regiments in the army",
        "usage": "scope:army = {\nany_army_maa_regiment = {\ninclude_hired = yes # should it include merc and holy order regiments (yes by default)\nrandom_army_maa_regiment = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "army",
        "supported_targets": "regiment",
        "notes": null
    },
    "refill_supply": {
        "desc": "Refills the designated army's supply to its max capacity.",
        "usage": "scope:army = { refull_supply = yes }",
        "supported_scopes": "army",
        "supported_targets": null,
        "notes": null
    },
    "remove_commander": {
        "desc": "Removes the currently assigned commander from the scoped army",
        "usage": "remove_commander = yes",
        "supported_scopes": "army",
        "supported_targets": null,
        "notes": null
    },
    "set_army_location": {
        "desc": "Teleports the army to the given location. Cannot be done while in combat. Will cause combat to happen with this army as the attacker if there's hostiles in the target",
        "usage": "set_army_location = scope:province",
        "supported_scopes": "army",
        "supported_targets": "province",
        "notes": null
    },
    "subtract_supply": {
        "desc": "Subtracts the designated supply to the army's supply. Cannot exceed the",
        "usage": "scope:army = { subtract_supply = 20 }",
        "supported_scopes": "army",
        "supported_targets": null,
        "notes": "army's max supply capacity."
    },
    "abort_travel_plan": {
        "desc": "Abort the travel plan immediately - no further travelling is executed, the on_action effect 'on_travel_plan_abort' will be run.",
        "usage": "abort_travel_plan = yes/no.",
        "supported_scopes": "travel_plan",
        "supported_targets": null,
        "notes": null
    },
    "add_companion": {
        "desc": "Adds a character as a companion to the scoped travel plan.",
        "usage": "add_companion = CHARACTER",
        "supported_scopes": "travel_plan",
        "supported_targets": "character",
        "notes": null
    },
    "add_destination_progress": {
        "desc": "Add X days towards the progress of the travel plan to the next destination. If the next destination is reached, excess progress is discarded.",
        "usage": "add_destination_progress = {\ndays/weeks/months/years = X",
        "supported_scopes": "travel_plan",
        "supported_targets": null,
        "notes": "'on_travel_plan_movement' on_action will not be triggered for any of the provinces. 'on_travel_plan_arrival' will be triggered."
    },
    "add_travel_option": {
        "desc": "Adds the travel option specified in the RHS to the scope travel plan.<travel_plan> = { add_travel_option = name }",
        "usage": "",
        "supported_scopes": "travel_plan",
        "supported_targets": null,
        "notes": null
    },
    "add_travel_plan_modifier": {
        "desc": "Add a modifier to a travel plan",
        "usage": "add_travel_plan_modifier = name\nadd_travel_plan_modifier = { modifier = name days/weeks/months/years = int }",
        "supported_scopes": "travel_plan",
        "supported_targets": null,
        "notes": null
    },
    "add_travel_waypoint": {
        "desc": "Adds a travel waypoint just ahead of the current travel location, and change the path accordingly.",
        "usage": "<travel_plan> = { add_travel_waypoint = province }",
        "supported_scopes": "travel_plan",
        "supported_targets": null,
        "notes": null
    },
    "cancel_travel_plan": {
        "desc": "Cancel travel plan future path, leave any associated activities, and reroute to home.",
        "usage": "cancel_travel_plan = yes/no.",
        "supported_scopes": "travel_plan",
        "supported_targets": null,
        "notes": null
    },
    "complete_travel_plan": {
        "desc": "Complete the travel plan immediately - no further travelling is executed, and the on_action effect 'on_travel_plan_complete' is run.",
        "usage": "complete_travel_plan = yes/no",
        "supported_scopes": "travel_plan",
        "supported_targets": null,
        "notes": null
    },
    "delay_travel_plan": {
        "desc": "Delay the travel plan by specific time duration. Will pause the travel plan, and resume after the duration ends.",
        "usage": "Will add to any existing delay duration, unless 'add = no' is set.\ndelay_travel_plan = {\ndays/weeks/months/years = X\nadd = yes/no [optional]",
        "supported_scopes": "travel_plan",
        "supported_targets": null,
        "notes": null
    },
    "every_entourage_character": {
        "desc": "Iterate through all characters travelling along with the travel plan owner. Includes travel leader, but not the travel plan owner.",
        "usage": "every_entourage_character = { limit = { <triggers> } <effects> }",
        "supported_scopes": "travel_plan",
        "supported_targets": "character",
        "notes": null
    },
    "every_future_path_location": {
        "desc": "Iterate through all provinces this travel plan has in its route.",
        "usage": "every_future_path_location = { limit = { <triggers> } <effects> }",
        "supported_scopes": "travel_plan",
        "supported_targets": "province",
        "notes": null
    },
    "every_visited_location": {
        "desc": "Iterate through all provinces this travel plan has arrived at so far.",
        "usage": "every_visited_location = { limit = { <triggers> } <effects> }",
        "supported_scopes": "travel_plan",
        "supported_targets": "province",
        "notes": null
    },
    "ordered_entourage_character": {
        "desc": "Iterate through all characters travelling along with the travel plan owner. Includes travel leader, but not the travel plan owner.",
        "usage": "ordered_entourage_character = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "travel_plan",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_future_path_location": {
        "desc": "Iterate through all provinces this travel plan has in its route.",
        "usage": "ordered_future_path_location = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "travel_plan",
        "supported_targets": "province",
        "notes": null
    },
    "ordered_visited_location": {
        "desc": "Iterate through all provinces this travel plan has arrived at so far.",
        "usage": "ordered_visited_location = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "travel_plan",
        "supported_targets": "province",
        "notes": null
    },
    "pause_travel_plan": {
        "desc": "Pause the travel plan, until explicitly resumed. Any existing pause resume date is removed.",
        "usage": "pause_travel_plan = yes/no.",
        "supported_scopes": "travel_plan",
        "supported_targets": null,
        "notes": null
    },
    "pause_travel_plan_mp": {
        "desc": "Pause the travel plan, until resumed, if in multiplayer. Any existing pause resume date is removed.",
        "usage": "pause_travel_plan_mp = yes/no.",
        "supported_scopes": "travel_plan",
        "supported_targets": null,
        "notes": null
    },
    "random_entourage_character": {
        "desc": "Iterate through all characters travelling along with the travel plan owner. Includes travel leader, but not the travel plan owner.",
        "usage": "random_entourage_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "travel_plan",
        "supported_targets": "character",
        "notes": null
    },
    "random_future_path_location": {
        "desc": "Iterate through all provinces this travel plan has in its route.",
        "usage": "random_future_path_location = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "travel_plan",
        "supported_targets": "province",
        "notes": null
    },
    "random_visited_location": {
        "desc": "Iterate through all provinces this travel plan has arrived at so far.",
        "usage": "random_visited_location = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "travel_plan",
        "supported_targets": "province",
        "notes": null
    },
    "remove_all_travel_plan_modifier_instances": {
        "desc": "Remove all instances of a modifier from a travel plan",
        "usage": "remove_all_travel_plan_modifier_instances = name",
        "supported_scopes": "travel_plan",
        "supported_targets": null,
        "notes": null
    },
    "remove_character": {
        "desc": "Remove character from a travel plan. You cannot remove the travel plan owner.",
        "usage": "remove_character = CHARACTER.",
        "supported_scopes": "travel_plan",
        "supported_targets": "character",
        "notes": null
    },
    "remove_travel_option": {
        "desc": "Removes the travel option specified in the RHS from the scope travel plan.<travel_plan> = { remove_travel_option = name }",
        "usage": "",
        "supported_scopes": "travel_plan",
        "supported_targets": null,
        "notes": null
    },
    "remove_travel_plan_modifier": {
        "desc": "Remove a modifier from a travel plan",
        "usage": "remove_travel_plan_modifier = name",
        "supported_scopes": "travel_plan",
        "supported_targets": null,
        "notes": null
    },
    "resume_travel_plan": {
        "desc": "Resume the travel plan, if paused.",
        "usage": "resume_travel_plan = yes/no.",
        "supported_scopes": "travel_plan",
        "supported_targets": null,
        "notes": null
    },
    "resume_travel_plan_mp": {
        "desc": "Resume the travel plan, if paused for multiplayer purposes via 'pause_travel_plan_mp'.",
        "usage": "resume_travel_plan_mp = yes/no.",
        "supported_scopes": "travel_plan",
        "supported_targets": null,
        "notes": null
    },
    "set_travel_leader": {
        "desc": "Set a character as the travel leader on the scoped travel plan. Any current leader is moved to be a regular companion in the entourage.",
        "usage": "set_travel_leader = CHARACTER",
        "supported_scopes": "travel_plan",
        "supported_targets": "character",
        "notes": null
    },
    "set_travel_plan_owner": {
        "desc": "Set a character as the owner of the scoped travel plan. If they're already the travel leader or an entourage member, it will remove them from those positions. The current owner is moved to be a regular companion in the entourage.",
        "usage": "set_travel_plan_owner = CHARACTER",
        "supported_scopes": "travel_plan",
        "supported_targets": "character",
        "notes": null
    },
    "activate_holy_site": {
        "desc": "Activate an inactive holy site<faith_scope> = { activate_holy_site = <holy_site_name> }",
        "usage": "",
        "supported_scopes": "faith",
        "supported_targets": null,
        "notes": null
    },
    "add_doctrine": {
        "desc": "Add doctrine to faith<faith_scope> = { add_doctrine = <doctrine_name> }",
        "usage": "",
        "supported_scopes": "faith",
        "supported_targets": "doctrine",
        "notes": null
    },
    "change_fervor": {
        "desc": "Changes the fervor of the faith by the given value. change_fervor = script value",
        "usage": "",
        "supported_scopes": "faith",
        "supported_targets": null,
        "notes": null
    },
    "deactivate_holy_site": {
        "desc": "Deactivate an active holy site<faith_scope> = { deactivate_holy_site = <holy_site_name> }",
        "usage": "",
        "supported_scopes": "faith",
        "supported_targets": null,
        "notes": null
    },
    "every_defensive_great_holy_wars": {
        "desc": "Iterate through all great holy wars this faith is defending against",
        "usage": "every_defensive_great_holy_wars = { limit = { <triggers> } <effects> }",
        "supported_scopes": "faith",
        "supported_targets": "ghw",
        "notes": null
    },
    "every_faith_character": {
        "desc": "Iterate through characters of the scoped faith",
        "usage": "every_faith_character = { limit = { <triggers> } <effects> }",
        "supported_scopes": "faith",
        "supported_targets": "character",
        "notes": null
    },
    "every_faith_holy_order": {
        "desc": "Iterate through all holy orders of the faith",
        "usage": "every_faith_holy_order = { limit = { <triggers> } <effects> }",
        "supported_scopes": "faith",
        "supported_targets": "holy_order",
        "notes": null
    },
    "every_faith_playable_ruler": {
        "desc": "Iterate through playable rulers of the scoped faith",
        "usage": "every_faith_playable_ruler = { limit = { <triggers> } <effects> }",
        "supported_scopes": "faith",
        "supported_targets": "character",
        "notes": null
    },
    "every_faith_ruler": {
        "desc": "Iterate through rulers of the scoped faith",
        "usage": "every_faith_ruler = { limit = { <triggers> } <effects> }",
        "supported_scopes": "faith",
        "supported_targets": "character",
        "notes": null
    },
    "every_holy_site": {
        "desc": "Iterate through all holy site baronies of a faith",
        "usage": "every_holy_site = { limit = { <triggers> } <effects> }",
        "supported_scopes": "faith",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_defensive_great_holy_wars": {
        "desc": "Iterate through all great holy wars this faith is defending against",
        "usage": "ordered_defensive_great_holy_wars = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "faith",
        "supported_targets": "ghw",
        "notes": null
    },
    "ordered_faith_character": {
        "desc": "Iterate through characters of the scoped faith",
        "usage": "ordered_faith_character = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "faith",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_faith_holy_order": {
        "desc": "Iterate through all holy orders of the faith",
        "usage": "ordered_faith_holy_order = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "faith",
        "supported_targets": "holy_order",
        "notes": null
    },
    "ordered_faith_playable_ruler": {
        "desc": "Iterate through playable rulers of the scoped faith",
        "usage": "ordered_faith_playable_ruler = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "faith",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_faith_ruler": {
        "desc": "Iterate through rulers of the scoped faith",
        "usage": "ordered_faith_ruler = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "faith",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_holy_site": {
        "desc": "Iterate through all holy site baronies of a faith",
        "usage": "ordered_holy_site = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "faith",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_defensive_great_holy_wars": {
        "desc": "Iterate through all great holy wars this faith is defending against",
        "usage": "random_defensive_great_holy_wars = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "faith",
        "supported_targets": "ghw",
        "notes": null
    },
    "random_faith_character": {
        "desc": "Iterate through characters of the scoped faith",
        "usage": "random_faith_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "faith",
        "supported_targets": "character",
        "notes": null
    },
    "random_faith_holy_order": {
        "desc": "Iterate through all holy orders of the faith",
        "usage": "random_faith_holy_order = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "faith",
        "supported_targets": "holy_order",
        "notes": null
    },
    "random_faith_playable_ruler": {
        "desc": "Iterate through playable rulers of the scoped faith",
        "usage": "random_faith_playable_ruler = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "faith",
        "supported_targets": "character",
        "notes": null
    },
    "random_faith_ruler": {
        "desc": "Iterate through rulers of the scoped faith",
        "usage": "random_faith_ruler = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "faith",
        "supported_targets": "character",
        "notes": null
    },
    "random_holy_site": {
        "desc": "Iterate through all holy site baronies of a faith",
        "usage": "random_holy_site = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "faith",
        "supported_targets": "landed_title",
        "notes": null
    },
    "remove_doctrine": {
        "desc": "Remove doctrine from faith<faith_scope> = { remove_doctrine = <doctrine_name> }",
        "usage": "",
        "supported_scopes": "faith",
        "supported_targets": "doctrine",
        "notes": null
    },
    "remove_religious_head_title": {
        "desc": "Removes the religious head title of the faith",
        "usage": "remove_religious_head_title = yes",
        "supported_scopes": "faith",
        "supported_targets": null,
        "notes": null
    },
    "set_religious_head_title": {
        "desc": "Sets the religious head title of the faith to the given title. set_religious_head_title = scope",
        "usage": "",
        "supported_scopes": "faith",
        "supported_targets": "landed_title",
        "notes": null
    },
    "start_great_holy_war": {
        "desc": "Starts a great holy war.",
        "usage": "start_great_holy_war = {target_character = someonetarget_title = some titledelay = script value # Number of days until the war should startwar = some war # Optional. Will make this a directed GHW instead of undirected, and tie it to this specific war}",
        "supported_scopes": "faith",
        "supported_targets": null,
        "notes": null
    },
    "activate_struggle_catalyst": {
        "desc": "Activate a catalyst, activate_struggle_catalyst = { catalyst = X character = Y}where X is a catalystY is scope:character # optionalsimplified: activate_struggle_catalyst = <catalyst>",
        "usage": "",
        "supported_scopes": "struggle",
        "supported_targets": null,
        "notes": null
    },
    "change_struggle_phase": {
        "desc": "Change the phase from the current one to a listed scripted phase without going into transition phase",
        "usage": "change_struggle_phase = X\nchange_struggle_phase = { struggle_phase = X with_transition = yes/no }",
        "supported_scopes": "struggle",
        "supported_targets": null,
        "notes": null
    },
    "change_struggle_phase_duration": {
        "desc": "Change the current phase duration in the scoped Struggle.",
        "usage": "change_struggle_phase_duration = { duration = { points = X } }\nchange_struggle_phase_duration = { duration = { days/weeks/months/years = Y }",
        "supported_scopes": "struggle",
        "supported_targets": null,
        "notes": null
    },
    "end_struggle": {
        "desc": "End a struggle, end_struggle = yes",
        "usage": "",
        "supported_scopes": "struggle",
        "supported_targets": null,
        "notes": null
    },
    "every_interloper_ruler": {
        "desc": "Iterate through all characters that are interloper in a struggle.",
        "usage": "every_interloper_ruler = { limit = { <triggers> } <effects> }",
        "supported_scopes": "struggle",
        "supported_targets": "character",
        "notes": null
    },
    "every_involved_county": {
        "desc": "Iterate through all counties that are involved in a struggle",
        "usage": "every_involved_county = { limit = { <triggers> } <effects> }",
        "supported_scopes": "struggle",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_involved_ruler": {
        "desc": "Iterate through all characters that are involved in a struggle.",
        "usage": "every_involved_ruler = { limit = { <triggers> } <effects> }",
        "supported_scopes": "struggle",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_interloper_ruler": {
        "desc": "Iterate through all characters that are interloper in a struggle.",
        "usage": "ordered_interloper_ruler = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "struggle",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_involved_county": {
        "desc": "Iterate through all counties that are involved in a struggle",
        "usage": "ordered_involved_county = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "struggle",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_involved_ruler": {
        "desc": "Iterate through all characters that are involved in a struggle.",
        "usage": "ordered_involved_ruler = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "struggle",
        "supported_targets": "character",
        "notes": null
    },
    "random_interloper_ruler": {
        "desc": "Iterate through all characters that are interloper in a struggle.",
        "usage": "random_interloper_ruler = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "struggle",
        "supported_targets": "character",
        "notes": null
    },
    "random_involved_county": {
        "desc": "Iterate through all counties that are involved in a struggle",
        "usage": "random_involved_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "struggle",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_involved_ruler": {
        "desc": "Iterate through all characters that are involved in a struggle.",
        "usage": "random_involved_ruler = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "struggle",
        "supported_targets": "character",
        "notes": null
    },
    "set_culture_as_involved": {
        "desc": "Set a culture as involved in the scoped Struggle.",
        "usage": "",
        "supported_scopes": "struggle",
        "supported_targets": "culture",
        "notes": null
    },
    "set_culture_as_uninvolved": {
        "desc": "Set a culture as involved in the scoped Struggle.",
        "usage": "",
        "supported_scopes": "struggle",
        "supported_targets": "culture",
        "notes": null
    },
    "set_faith_as_involved": {
        "desc": "Set a faith as involved in the scoped Struggle.",
        "usage": "",
        "supported_scopes": "struggle",
        "supported_targets": "faith",
        "notes": null
    },
    "set_faith_as_uninvolved": {
        "desc": "Set a faith as uninvolved in the scoped Struggle.",
        "usage": "",
        "supported_scopes": "struggle",
        "supported_targets": "faith",
        "notes": null
    },
    "add_geographical_region": {
        "desc": "Adds a geographical region to the situation sub-region.",
        "usage": "add_geographical_region = db_type:geographical_region",
        "supported_scopes": "situation_sub_region",
        "supported_targets": "geographical_region",
        "notes": "usage:"
    },
    "add_phase_max_duration": {
        "desc": "Add (or subtract if negative) duration from the sub-region current phase' max duration.",
        "usage": "add_phase_max_duration = {\ndays = 123\nmonths = 123",
        "supported_scopes": "situation_sub_region",
        "supported_targets": null,
        "notes": null
    },
    "add_takeover_phase_duration": {
        "desc": "Add (or subtract if negative) duration towards a future takeover phase of this situation sub-region.",
        "usage": "add_takeover_phase_duration = {\nphase = situation_phase_key\ndays = 123\nmonths = 123",
        "supported_scopes": "situation_sub_region",
        "supported_targets": null,
        "notes": null
    },
    "add_takeover_phase_points": {
        "desc": "Add (or subtract if negative) points towards a future takeover phase of this situation sub-region. (rounded down)",
        "usage": "add_takeover_phase_points = {\nphase = situation_phase_key\npoints = scripted_value",
        "supported_scopes": "situation_sub_region",
        "supported_targets": null,
        "notes": null
    },
    "add_title_to_sub_region": {
        "desc": "Adds a landed county title to the situation sub-region.",
        "usage": "add_title_to_sub_region = <title>",
        "supported_scopes": "situation_sub_region",
        "supported_targets": "landed_title",
        "notes": "usage:"
    },
    "change_phase": {
        "desc": "Change the phase of a sub-region from the current one to a specific phase",
        "usage": "change_phase = my_first_phase\nchange_phase = { phase = my_first_phase }",
        "supported_scopes": "situation_sub_region",
        "supported_targets": null,
        "notes": null
    },
    "every_situation_sub_region_county": {
        "desc": "Iterate through all counties of a situation sub-region (warning: not fast)",
        "usage": "every_situation_sub_region_county = { limit = { <triggers> } <effects> }",
        "supported_scopes": "situation_sub_region",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_situation_sub_region_geographical_region": {
        "desc": "Iterate through all geographical regions of a situation sub-region",
        "usage": "every_situation_sub_region_geographical_region = { limit = { <triggers> } <effects> }",
        "supported_scopes": "situation_sub_region",
        "supported_targets": "geographical_region",
        "notes": null
    },
    "every_situation_sub_region_participant": {
        "desc": "Iterate through all characters that are participating in a situation, in a specific subregion",
        "usage": "every_situation_sub_region_participant = { limit = { <triggers> } <effects> }",
        "supported_scopes": "situation_sub_region",
        "supported_targets": "character",
        "notes": null
    },
    "every_situation_sub_region_participant_group": {
        "desc": "Iterate through all participant groups of the situation sub-region",
        "usage": "every_situation_sub_region_participant_group = { limit = { <triggers> } <effects> }",
        "supported_scopes": "situation_sub_region",
        "supported_targets": "situation_participant_group",
        "notes": null
    },
    "ordered_situation_sub_region_county": {
        "desc": "Iterate through all counties of a situation sub-region (warning: not fast)",
        "usage": "ordered_situation_sub_region_county = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "situation_sub_region",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_situation_sub_region_geographical_region": {
        "desc": "Iterate through all geographical regions of a situation sub-region",
        "usage": "ordered_situation_sub_region_geographical_region = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "situation_sub_region",
        "supported_targets": "geographical_region",
        "notes": null
    },
    "ordered_situation_sub_region_participant": {
        "desc": "Iterate through all characters that are participating in a situation, in a specific subregion",
        "usage": "ordered_situation_sub_region_participant = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "situation_sub_region",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_situation_sub_region_participant_group": {
        "desc": "Iterate through all participant groups of the situation sub-region",
        "usage": "ordered_situation_sub_region_participant_group = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "situation_sub_region",
        "supported_targets": "situation_participant_group",
        "notes": null
    },
    "random_situation_sub_region_county": {
        "desc": "Iterate through all counties of a situation sub-region (warning: not fast)",
        "usage": "random_situation_sub_region_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "situation_sub_region",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_situation_sub_region_geographical_region": {
        "desc": "Iterate through all geographical regions of a situation sub-region",
        "usage": "random_situation_sub_region_geographical_region = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "situation_sub_region",
        "supported_targets": "geographical_region",
        "notes": null
    },
    "random_situation_sub_region_participant": {
        "desc": "Iterate through all characters that are participating in a situation, in a specific subregion",
        "usage": "random_situation_sub_region_participant = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "situation_sub_region",
        "supported_targets": "character",
        "notes": null
    },
    "random_situation_sub_region_participant_group": {
        "desc": "Iterate through all participant groups of the situation sub-region",
        "usage": "random_situation_sub_region_participant_group = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "situation_sub_region",
        "supported_targets": "situation_participant_group",
        "notes": null
    },
    "remove_geographical_region": {
        "desc": "Removes a geographical region from the situation sub-region.",
        "usage": "remove_geographical_region = db_type:geographical_region",
        "supported_scopes": "situation_sub_region",
        "supported_targets": "geographical_region",
        "notes": "usage:"
    },
    "remove_title_to_sub_region": {
        "desc": "Removes a title from the situation sub-region.",
        "usage": "remove_title_to_sub_region = <title>",
        "supported_scopes": "situation_sub_region",
        "supported_targets": "landed_title",
        "notes": "usage:"
    },
    "change_war_chest_gold": {
        "desc": "Changes the amount of gold in the war chest by the given amount. change_war_chest_gold = script value",
        "usage": "",
        "supported_scopes": "ghw",
        "supported_targets": null,
        "notes": null
    },
    "change_war_chest_piety": {
        "desc": "Changes the amount of piety in the war chest by the given amount. change_war_chest_piety = script value",
        "usage": "",
        "supported_scopes": "ghw",
        "supported_targets": null,
        "notes": null
    },
    "change_war_chest_prestige": {
        "desc": "Changes the amount of prestige in the war chest by the given amount. change_war_chest_prestige = script value",
        "usage": "",
        "supported_scopes": "ghw",
        "supported_targets": null,
        "notes": null
    },
    "divide_war_chest": {
        "desc": "The scoped GHW gives out its war-chest in full or in part.",
        "usage": "divide_war_chest = {\ndefenders = yes (default to attackers instead)\nfaction = script value (default 1 for 100%)\ngold = no (default = yes)\npiety = no (default = yes)\nprestige = no (default = yes)",
        "supported_scopes": "ghw",
        "supported_targets": null,
        "notes": null
    },
    "do_ghw_title_handout": {
        "desc": "Hands out titles in the target kingdom to the GHW attacker beneficiaries. Will vassalize people based on dejure liege within the taken kingdom. Will refill county garrisons and levies. do_ghw_title_handout = scope:title_and_vassal_change",
        "usage": "",
        "supported_scopes": "ghw",
        "supported_targets": "title_and_vassal_change",
        "notes": null
    },
    "every_pledged_attacker": {
        "desc": "Iterate through all pledged attackers within a great holy war",
        "usage": "every_pledged_attacker = { limit = { <triggers> } <effects> }",
        "supported_scopes": "ghw",
        "supported_targets": "character",
        "notes": null
    },
    "every_pledged_defender": {
        "desc": "Iterate through all pledged defenders within a great holy war",
        "usage": "every_pledged_defender = { limit = { <triggers> } <effects> }",
        "supported_scopes": "ghw",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_pledged_attacker": {
        "desc": "Iterate through all pledged attackers within a great holy war",
        "usage": "ordered_pledged_attacker = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "ghw",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_pledged_defender": {
        "desc": "Iterate through all pledged defenders within a great holy war",
        "usage": "ordered_pledged_defender = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "ghw",
        "supported_targets": "character",
        "notes": null
    },
    "pledge_attacker": {
        "desc": "The target character pledges themselves as an attacker in the GHW. Must be of the same faith as the GHW declarer. pledge_attacker = some character",
        "usage": "",
        "supported_scopes": "ghw",
        "supported_targets": "character",
        "notes": null
    },
    "pledge_defender": {
        "desc": "The target character pledges themselves as a defender in the GHW. Must be of the same faith as the GHW target. pledge_defender = some character",
        "usage": "",
        "supported_scopes": "ghw",
        "supported_targets": "character",
        "notes": null
    },
    "random_pledged_attacker": {
        "desc": "Iterate through all pledged attackers within a great holy war",
        "usage": "random_pledged_attacker = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "ghw",
        "supported_targets": "character",
        "notes": null
    },
    "random_pledged_defender": {
        "desc": "Iterate through all pledged defenders within a great holy war",
        "usage": "random_pledged_defender = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "ghw",
        "supported_targets": "character",
        "notes": null
    },
    "reset_designated_winner": {
        "desc": "The GHW stops having a designated winner. reset_designated_winner = yes",
        "usage": "",
        "supported_scopes": "ghw",
        "supported_targets": null,
        "notes": null
    },
    "set_designated_winner": {
        "desc": "The target character becomes the designated winner of the GHW. set_designated_winner = some character",
        "usage": "",
        "supported_scopes": "ghw",
        "supported_targets": "character",
        "notes": null
    },
    "set_great_holy_war_target": {
        "desc": "Sets the target of the great holy war.",
        "usage": "set_great_holy_war_target = { target_character = someone target_title = some title }",
        "supported_scopes": "ghw",
        "supported_targets": null,
        "notes": null
    },
    "set_war_declarer": {
        "desc": "The target character becomes the character that should declare war instead of the religious head. set_war_declarer = some character",
        "usage": "",
        "supported_scopes": "ghw",
        "supported_targets": "character",
        "notes": null
    },
    "start_ghw_war": {
        "desc": "Starts the GHW war. start_ghw_war = undirected_great_holy_war",
        "usage": "",
        "supported_scopes": "ghw",
        "supported_targets": null,
        "notes": null
    },
    "unpledge_attacker": {
        "desc": "The target character removes their pledge as an attacker in the GHW. unpledge_attacker = some character",
        "usage": "",
        "supported_scopes": "ghw",
        "supported_targets": "character",
        "notes": null
    },
    "unpledge_defender": {
        "desc": "The target character removes their pledge as a defender in the GHW. unpledge_defender = some character",
        "usage": "",
        "supported_scopes": "ghw",
        "supported_targets": "character",
        "notes": null
    },
    "every_infected_province": {
        "desc": "Gets all provinces infected by the scoped epidemic",
        "usage": "every_infected_province = { limit = { <triggers> } <effects> }",
        "supported_scopes": "epidemic",
        "supported_targets": "province",
        "notes": null
    },
    "ordered_infected_province": {
        "desc": "Gets all provinces infected by the scoped epidemic",
        "usage": "ordered_infected_province = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "epidemic",
        "supported_targets": "province",
        "notes": null
    },
    "random_infected_province": {
        "desc": "Gets all provinces infected by the scoped epidemic",
        "usage": "random_infected_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "epidemic",
        "supported_targets": "province",
        "notes": null
    },
    "set_epidemic_outbreak_intensity": {
        "desc": "Sets the epidemic outbreak intensity to the new value.",
        "usage": "set_epidemic_outbreak_intensity = major\nminor, major, apocalyptic",
        "supported_scopes": "epidemic",
        "supported_targets": null,
        "notes": null
    },
    "every_tax_slot_vassal": {
        "desc": "Iterates through all Vassals assigned to the scoped Tax Slot",
        "usage": "every_tax_slot_vassal = { limit = { <triggers> } <effects> }",
        "supported_scopes": "tax_slot",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_tax_slot_vassal": {
        "desc": "Iterates through all Vassals assigned to the scoped Tax Slot",
        "usage": "ordered_tax_slot_vassal = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "tax_slot",
        "supported_targets": "character",
        "notes": null
    },
    "random_tax_slot_vassal": {
        "desc": "Iterates through all Vassals assigned to the scoped Tax Slot",
        "usage": "random_tax_slot_vassal = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "tax_slot",
        "supported_targets": "character",
        "notes": null
    },
    "every_situation_group_participant": {
        "desc": "Iterate through all characters that are part of a participation group in a situation.",
        "usage": "every_situation_group_participant = { limit = { <triggers> } <effects> }",
        "supported_scopes": "situation_participant_group",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_situation_group_participant": {
        "desc": "Iterate through all characters that are part of a participation group in a situation.",
        "usage": "ordered_situation_group_participant = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "situation_participant_group",
        "supported_targets": "character",
        "notes": null
    },
    "random_situation_group_participant": {
        "desc": "Iterate through all characters that are part of a participation group in a situation.",
        "usage": "random_situation_group_participant = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "situation_participant_group",
        "supported_targets": "character",
        "notes": null
    },
    "add_from_contribution_attackers": {
        "desc": "Adds prestige, gold and piety based on contribution to allied attackers. parameters: prestige, gold, piety.",
        "usage": "",
        "supported_scopes": "casus_belli",
        "supported_targets": null,
        "notes": null
    },
    "add_from_contribution_defenders": {
        "desc": "Adds prestige, gold and piety based on contribution to allied defenders. parameters: prestige, gold, piety.",
        "usage": "",
        "supported_scopes": "casus_belli",
        "supported_targets": null,
        "notes": null
    },
    "every_target_title": {
        "desc": "Iterate through all casus belli's target titles",
        "usage": "every_target_title = { limit = { <triggers> } <effects> }",
        "supported_scopes": "casus_belli",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_target_title": {
        "desc": "Iterate through all casus belli's target titles",
        "usage": "ordered_target_title = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "casus_belli",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_target_title": {
        "desc": "Iterate through all casus belli's target titles",
        "usage": "random_target_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "casus_belli",
        "supported_targets": "landed_title",
        "notes": null
    },
    "add_artifact_history": {
        "desc": "Adds a history entry to the artifact, could for example be a reforging event",
        "usage": "type = enum - history entry type\ndate = jomini date - when this historical event took place\nactor = character - who is the actor in the event, for example who created it\nrecipient = character - who is the recipient in the event, for example who was the artifact given to\nlocation = province - where the event took place",
        "supported_scopes": "artifact",
        "supported_targets": null,
        "notes": null
    },
    "add_artifact_modifier": {
        "desc": "Adds a static modifier to the given artifact",
        "usage": "add_artifact_modifier = modifier_name",
        "supported_scopes": "artifact",
        "supported_targets": null,
        "notes": null
    },
    "add_artifact_title_history": {
        "desc": "Adds the title history of the given title to the scoped artifacts history",
        "usage": "add_artifact_title_history = {}\ntarget = title scope - landed title to take history from\ndate = game date - from which date onwards to copy historical entries",
        "supported_scopes": "artifact",
        "supported_targets": null,
        "notes": null
    },
    "add_durability": {
        "desc": "Add this much to the artifacts durability",
        "usage": "",
        "supported_scopes": "artifact",
        "supported_targets": null,
        "notes": null
    },
    "clear_artifact_modifiers": {
        "desc": "Removes all modifiers from the scoped artifact",
        "usage": "clear_artifact_modifiers = yes",
        "supported_scopes": "artifact",
        "supported_targets": null,
        "notes": null
    },
    "copy_artifact_modifiers": {
        "desc": "Copies the modifiers of the target artifact. Does *not* clear out existing modifiers",
        "usage": "copy_artifact_modifiers = target_artifact",
        "supported_scopes": "artifact",
        "supported_targets": "artifact",
        "notes": null
    },
    "equip_artifact_to_owner": {
        "desc": "Makes the owner of the scoped artifact equip it, will fail if there already is an equipment in the artifact's slot.",
        "usage": "",
        "supported_scopes": "artifact",
        "supported_targets": null,
        "notes": null
    },
    "equip_artifact_to_owner_replace": {
        "desc": "Makes the owner of the scoped artifact equip it, will replace the first held artifact if all slots of its type are filled.",
        "usage": "",
        "supported_scopes": "artifact",
        "supported_targets": null,
        "notes": null
    },
    "every_artifact_claimant": {
        "desc": "Iterate through all characters with a claim on the scoped artifact",
        "usage": "every_artifact_claimant = { limit = { <triggers> } <effects> }",
        "supported_scopes": "artifact",
        "supported_targets": "character",
        "notes": null
    },
    "every_artifact_house_claimant": {
        "desc": "Iterate through all dynasty houses with a claim on the scoped artifact",
        "usage": "every_artifact_house_claimant = { limit = { <triggers> } <effects> }",
        "supported_scopes": "artifact",
        "supported_targets": "dynasty_house",
        "notes": null
    },
    "ordered_artifact_claimant": {
        "desc": "Iterate through all characters with a claim on the scoped artifact",
        "usage": "ordered_artifact_claimant = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "artifact",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_artifact_house_claimant": {
        "desc": "Iterate through all dynasty houses with a claim on the scoped artifact",
        "usage": "ordered_artifact_house_claimant = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "artifact",
        "supported_targets": "dynasty_house",
        "notes": null
    },
    "random_artifact_claimant": {
        "desc": "Iterate through all characters with a claim on the scoped artifact",
        "usage": "random_artifact_claimant = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "artifact",
        "supported_targets": "character",
        "notes": null
    },
    "random_artifact_house_claimant": {
        "desc": "Iterate through all dynasty houses with a claim on the scoped artifact",
        "usage": "random_artifact_house_claimant = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "artifact",
        "supported_targets": "dynasty_house",
        "notes": null
    },
    "reforge_artifact": {
        "desc": "Reforges the given artifact, restoring its durability and potentially changing any other attributes such as type or modifiers unless those fields are left empty",
        "usage": "name = dynamic description - artifact name\ndescription = dynamic description - artifact description\nrarity = enum - artifact rarity, ex. legendary\ntype = flag - inventory slot type, ex. trinket\nmodifier = static modifier - applied to the character whom wields this artifact\ndurability = script value - new durability, will be max by default\nmax_durability = script value - Optional. A value for the max durability, which would override the one normally assigned by the defines\ndecaying = yes/no - Optional. Set if artifact decays with time. Yes by default\nhistory = artifact history entry - custom history entry to denote for example that this is artifact was reforged by someone else than the owner\ntype = artifact history entry type - available types:\ntemplate = artifact scripted template - a scripted base template with triggers and modifiers\nvisuals = artifact visual type - how this artifact should appear visually\ngenerate_history = bool - automatically generate a new history entry if none has been scripted?\nquality = script value - new quality, used in AI scoring\nwealth = script value - new wealth, used in AI scoring\ncreator = character scope - set a custom creator of the artifact ( default is the owner )\nvisuals_source = scope containing landed title, dynasty or house - set a source of coat of arms graphics for the artifact",
        "supported_scopes": "artifact",
        "supported_targets": null,
        "notes": "Be aware that we make use of the current scopes implicitly. This is done in common/artifacts/visuals"
    },
    "remove_artifact_feature_group": {
        "desc": "Removes th feature from the specified group from the artifact.",
        "usage": "remove_artifact_feature_group = key",
        "supported_scopes": "artifact",
        "supported_targets": null,
        "notes": "Cannot remove required groups."
    },
    "remove_artifact_modifier": {
        "desc": "Removes a static modifier to the given artifact",
        "usage": "remove_artifact_modifier = modifier_name",
        "supported_scopes": "artifact",
        "supported_targets": null,
        "notes": null
    },
    "set_artifact_description": {
        "desc": "Sets the description of the given artifact",
        "usage": "set_artifact_description = dynamic desc",
        "supported_scopes": "artifact",
        "supported_targets": null,
        "notes": null
    },
    "set_artifact_feature": {
        "desc": "Sets the specified feature on the artifact.",
        "usage": "set_artifact_feature = key",
        "supported_scopes": "artifact",
        "supported_targets": null,
        "notes": "If there's already a feature of that group, it gets overridden."
    },
    "set_artifact_feature_group": {
        "desc": "Sets a feature from the specified group on the artifact.",
        "usage": "set_artifact_feature_group = key",
        "supported_scopes": "artifact",
        "supported_targets": null,
        "notes": "Uses the current scopes. Uses the weighting from the group. If there's already a feature of that group, it gets overridden."
    },
    "set_artifact_name": {
        "desc": "Sets the name of the given artifact",
        "usage": "set_artifact_name = dynamic name",
        "supported_scopes": "artifact",
        "supported_targets": null,
        "notes": null
    },
    "set_artifact_rarity": {
        "desc": "Sets the rarity of the scoped artifact. Note that this does not update graphics and the like",
        "usage": "set_artifact_rarity = common",
        "supported_scopes": "artifact",
        "supported_targets": null,
        "notes": null
    },
    "set_max_durability": {
        "desc": "Sets the artifact's max durability",
        "usage": "",
        "supported_scopes": "artifact",
        "supported_targets": null,
        "notes": null
    },
    "set_owner": {
        "desc": "Change the artifacts owner and transfer it to the given character",
        "usage": "set_artifact_owner = {}\ntarget = character scope - the new owner character\nhistory = artifact history entry - custom history entry to denote for example that this is artifact was stolen rather than given\ngenerate_history = bool - automatically generate a new history entry if none has been scripted?",
        "supported_scopes": "artifact",
        "supported_targets": null,
        "notes": null
    },
    "set_should_decay": {
        "desc": "Set if the scoped artifact should decay with time or not",
        "usage": "set_should_decay = yes/no",
        "supported_scopes": "artifact",
        "supported_targets": null,
        "notes": null
    },
    "unequip_artifact_from_owner": {
        "desc": "Makes the owner of the scoped artifact unequip it.",
        "usage": "",
        "supported_scopes": "artifact",
        "supported_targets": null,
        "notes": null
    },
    "every_killed_character": {
        "desc": "Iterate through all kills of a character",
        "usage": "every_killed_character = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character, artifact",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_killed_character": {
        "desc": "Iterate through all kills of a character",
        "usage": "ordered_killed_character = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character, artifact",
        "supported_targets": "character",
        "notes": null
    },
    "random_killed_character": {
        "desc": "Iterate through all kills of a character",
        "usage": "random_killed_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character, artifact",
        "supported_targets": "character",
        "notes": null
    },
    "add_diplomacy_skill": {
        "desc": "Adds diplomacy skill",
        "usage": "",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "add_focus_progress": {
        "desc": "Adds focus progress",
        "usage": "",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "add_internal_flag": {
        "desc": "adds effect to be read internally (no effect in the gamestate)",
        "usage": "",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "add_intrigue_skill": {
        "desc": "Adds intrigue skill",
        "usage": "",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "add_learning_skill": {
        "desc": "Adds learning skill",
        "usage": "",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "add_martial_skill": {
        "desc": "Adds martial skill",
        "usage": "",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "add_prowess_skill": {
        "desc": "Adds prowess skill",
        "usage": "",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "add_stewardship_skill": {
        "desc": "Adds stewardship skill",
        "usage": "",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "add_title_law": {
        "desc": "add law to scoped title, overriding any current law from the same group. DOES NOT apply law change costs and effects.",
        "usage": "add_title_law = princely_elective_succession_law",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "add_title_law_effects": {
        "desc": "add law to scoped title, overriding any current law from the same group. DOES apply law change costs and effects.",
        "usage": "add_title_law = princely_elective_succession_law",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "add_to_global_variable_list": {
        "desc": "Adds the event target to a variable list for the given duration",
        "usage": "add_to_variable_list = { name = X target = Y days/weeks/months/years = Z }",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "add_to_list": {
        "desc": "Adds the current scope to an arbitrarily-named list (or creates the list if not already present) to be referenced later in the (unbroken) event chain",
        "usage": "add_to_list = <name_of_list>\nadd_to_list = { name = <name_of_list> value = <script_value> }",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "add_to_local_variable_list": {
        "desc": "Adds the event target to a variable list for the given duration",
        "usage": "add_to_variable_list = { name = X target = Y days/weeks/months/years = Z }",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "add_to_temporary_list": {
        "desc": "Adds the current scope to an arbitrarily-named list (or creates the list if not already present) to be referenced later in the same effect",
        "usage": "add_to_temporary_list = <name_of_list>\nadd_to_temporary_list = { name = <name_of_list> value = <script_value> }",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "add_to_variable_list": {
        "desc": "Adds the event target to a variable list for the given duration",
        "usage": "add_to_variable_list = { name = X target = Y days/weeks/months/years = Z }",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "assert_if": {
        "desc": "Conditionally cause an assert during run time",
        "usage": "assert_if = { limit = { X } text = Y }, where X is a trigger and Y is an optional string",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "assert_read": {
        "desc": "Conditionally cause an assert during read time",
        "usage": "assert_read = X, where X is yes or the string to be printed in the assert",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "break_betrothal": {
        "desc": "Breaks the betrothal between the scope character to the target character, break_betrothal = target",
        "usage": "",
        "supported_scopes": "none",
        "supported_targets": "character",
        "notes": null
    },
    "change_global_variable": {
        "desc": "Changes the value or a numeric variable",
        "usage": "change_variable = { name = X operation = Y }",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "change_local_variable": {
        "desc": "Changes the value or a numeric variable",
        "usage": "change_variable = { name = X operation = Y }",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "change_title_holder": {
        "desc": "= {",
        "usage": "holder = Character that should get the title\nchange = 'previously created title_and_vassal_change', adds a title change, will not transfer vassals\ntake_baronies = yes # Optional; if set, will cause baronies to be taken (rather than vassalized) as well if this title is a county\ngovernment_base = character # Optional, if the character getting the title was unlanded, their new government",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "change_title_holder_include_vassals": {
        "desc": "= {\\n\"",
        "usage": "holder = 'Character that should get the title'\nchange = 'previously created title_and_vassal_change', adds a title change, will transfer vassals\ntake_baronies = yes # Optional; if set, will cause baronies to be taken (rather than vassalized) as well if this title is a county\ngovernment_base = character # Optional, if the character getting the title was unlanded, their new government",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "change_variable": {
        "desc": "Changes the value or a numeric variable",
        "usage": "change_variable = { name = X operation = Y }",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "clamp_global_variable": {
        "desc": "Clamps a variable the specified max and min",
        "usage": "clamp_variable = { name = X max = Y min = Z }",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "clamp_local_variable": {
        "desc": "Clamps a variable the specified max and min",
        "usage": "clamp_variable = { name = X max = Y min = Z }",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "clamp_variable": {
        "desc": "Clamps a variable the specified max and min",
        "usage": "clamp_variable = { name = X max = Y min = Z }",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "clear_global_variable_list": {
        "desc": "Empties the list",
        "usage": "clear_variable_list = variable_name",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "clear_local_variable_list": {
        "desc": "Empties the list",
        "usage": "clear_variable_list = variable_name",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "clear_saved_scope": {
        "desc": "Clears a saved scope from the top scope",
        "usage": "save_scope_as = cool_scope -> clear_saved_scope = cool_scope",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "clear_traits": {
        "desc": "Removes all traits for the character. clear_traits = yes",
        "usage": "",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "clear_variable_list": {
        "desc": "Empties the list",
        "usage": "clear_variable_list = variable_name",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "close_all_views": {
        "desc": "Closes all views. close_all_views = yes",
        "usage": "",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "close_view": {
        "desc": "Tries to close the defined view.",
        "usage": "close_view = {\nview = <view name>\nplayer = scope:character # optional, else closes for all players who execute the effect\n}simplified: close_view = <view name>",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": "Take care to set player if effect is executed not through UI but through synchronized code. Else all the window will open for all players."
    },
    "copy_traits": {
        "desc": "Adds all traits of the target to the character. Skips any traits that the character isn't allowed to have. Will not remove the character's existing traits. copy_traits = scope:character",
        "usage": "",
        "supported_scopes": "none",
        "supported_targets": "character",
        "notes": null
    },
    "create_accolade": {
        "desc": "Create an accolade for the scoped character with the given knight and types. The name is an optional loc key, a default name will be generated otherwise.",
        "usage": "create_accolade = { knight = scope:character primary = accolade_type secondary = accolade_type name = loc_key }",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "create_adventurer_title": {
        "desc": "Create a title for a landless adventurer.",
        "usage": "create_adventurer_title = \\\"\nname = key/dynamic description\nholder = <character> (intended holder of the new title)\ngovernment = administrative_government # optional government, default is adventurer\nsave_scope_as = <name>\nprefix = key/dynamic description (optional; name used if not specified)\nadjective = key/dynamic description (optional; name used if not specified)",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": "usage:"
    },
    "create_betrothal": {
        "desc": "Betroth the scope character to the target character, create_betrothal = target (at least one of the characters need to not be adult)",
        "usage": "",
        "supported_scopes": "none",
        "supported_targets": "character",
        "notes": null
    },
    "create_betrothal_matrilineal": {
        "desc": "Betroth the scope character to the target character matrilineally, create_betrothal_matrilineal = target (at least one of the characters need to not be adult)",
        "usage": "",
        "supported_scopes": "none",
        "supported_targets": "character",
        "notes": null
    },
    "create_character": {
        "desc": "Creates a character",
        "usage": "save_event_target_as = flag - save the character as an event target\nsave_temporary_event_target_as = flag - save the character as a temporary event target\nname =\nage =\ngender = male/female/character scope\ngender_female_chance = script_value - Range (0..100)\nopposite_gender = character scope\ntrait = add this trait\nrandom_traits_list = { count = { 1 5 } traitID = { some triggers } traitID = { some triggers } } - A number of traits specified by count (1 if not specified) will be picked from the traits that have their triggers met. Scopes are the same as where create_character is used. More than one grouping like this can be defined\nrandom_traits = yes/no\nhealth =\nfertility =\nmother =\nfather =\nreal_father = (should only be set if the real father is not the same as father=)\nemployer = will end up in this court, will become a pool character unless specified or father/mother is landed\nlocation = pool province; mutually exclusive with employer\ntemplate_character =\nfaith = faith tag OR a faith scope\nrandom_faith = { catholic = { some triggers } cathar = { some triggers }. Random one where the triggers are met will be picked. Scopes are the same as where create_character is used\nrandom_faith_in_religion = religion tag OR a faith scope (there's no religion scope)\nculture = culture name OR a culture scope\nrandom_culture = { norse = { some triggers } norwegian = { some triggers }. Random one where the triggers are met will be picked. Scopes are the same as where create_character is used\nrandom_culture_in_group = culture group name OR a culture scope (there's no group scope)\ndynasty_house = dynasty house name OR a dynasty house scope\ndynasty = generate/inherit/none - What to do if dynasty_house is not specified. generate by default.\nethnicity = culture/mother/father/parents/<ethnicity> - How to select ethnicity, culture by default.\nethnicities = { <key> = { some_triggers } } - Pick randomly from these ethnicities instead.\nmartial/diplomacy/intrigue...  =  will get random unless specified\nafter_creation = { some effects } run after character is created. Scope starts off in the character, with the scope it was created in as PREV, and the same top scope and saved targets etc.",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "create_dynamic_title": {
        "desc": "Creates a dynamic title",
        "usage": "create_dynamic_title = {\ntier = <tier>\nname = key/dynamic description\nadj = key/dynamic description (optional; name used if not specified)\npre = key/dynamic description (optional)\narticle = key/dynamic description (optional)",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": "The title will be saved to scope:new_titleusage:"
    },
    "create_holy_order": {
        "desc": "Create a new holy order",
        "usage": "create_holy_order = {\nleader = scope:a_character\ncapital = scope:a_barony_title\nname = <name> #Optional\ncoat_of_arms = <coa_name> #Optional\nsave_scope_as/save_temporary_scope_as = new_holy_order # optional way to get a reference to the new holy order",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "create_nomad_title": {
        "desc": "Create a title for a nomad.",
        "usage": "create_nomad_title = \\\"\nname = key/dynamic description\nholder = <character> (intended holder of the new title)\ngovernment = administrative_government # optional government, default is herder_government\nsave_scope_as = <name>\nprefix = key/dynamic description (optional; name used if not specified)\nadjective = key/dynamic description (optional; name used if not specified)",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": "usage:"
    },
    "create_title_and_vassal_change": {
        "desc": "starts a title and vassal change and saves it as a temporary event target",
        "usage": "create_title_and_vassal_change = {\ntype = conquest (or other type)\nsave_scope_as = change (name of resulting saved scope)\nadd_claim_on_loss = yes (optional)",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "custom_description": {
        "desc": "Wraps effects that get a custom description instead of the auto-generated one",
        "usage": "custom_description = {\ntext = <effect_localization_key>\nsubject = <optional subject scope> #defaults to current scope\nobject = <optional object scope>\nvalue = <optional script value>",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "custom_description_no_bullet": {
        "desc": "Wraps effects that get a custom description instead of the auto-generated one. Also ensures no bullet point appears",
        "usage": "custom_description_no_bullet = {\ntext = <effect_localization_key>\nsubject = <optional subject scope> #defaults to current scope\nobject = <optional object scope>\nvalue = <optional script value>",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "custom_label": {
        "desc": "just a tooltip, the scope as object (for grouping, localization). Can also be written as custom_label = { text = key subject = scope (optional) <hidden effects> }",
        "usage": "",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "custom_tooltip": {
        "desc": "just a tooltip, the scope as subject (for grouping, localization). Can also be written as custom_tooltip = { text = key subject = scope (optional) <hidden effects> }",
        "usage": "",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "debug_log": {
        "desc": "Log a string to the debug log when this effect executes, debug_log = message, the message can be a localization string with ROOT, SCOPE and PREV available",
        "usage": "",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "debug_log_date": {
        "desc": "Logs the current date to the debug.log",
        "usage": "",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "debug_log_scopes": {
        "desc": "Log the current scope to the debug log when this effect executes yes = full scope info, no=only current scope",
        "usage": "",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "debug_trigger_event": {
        "desc": "Like trigger_event, except it'll print the trigger fulfillment and immediate effects of the event too",
        "usage": "",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "destroy_artifact": {
        "desc": "Destroy given artifact, regardless of owner.",
        "usage": "destroy_artifact = artifact",
        "supported_scopes": "none",
        "supported_targets": "artifact",
        "notes": null
    },
    "destroy_character_memory": {
        "desc": "destroy_character_memory = character_memory",
        "usage": "",
        "supported_scopes": "none",
        "supported_targets": "character_memory",
        "notes": "Destroys the targeted character memory, do not use the destroyed scope after calling this since it will have been removed"
    },
    "destroy_inspiration": {
        "desc": "destroy_inspiration = inspiration",
        "usage": "",
        "supported_scopes": "none",
        "supported_targets": "inspiration",
        "notes": "Destroys the targeted inspiration, do not use the destroyed scope after calling this since it will have been removed"
    },
    "destroy_owned_artifact": {
        "desc": "Destroy artifact owned by character. Safer version of 'destroy_artifact'.",
        "usage": "destroy_owned_artifact = artifact",
        "supported_scopes": "none",
        "supported_targets": "artifact",
        "notes": null
    },
    "divorce": {
        "desc": "Divorces the scope character from the target character. divorce = target",
        "usage": "",
        "supported_scopes": "none",
        "supported_targets": "character",
        "notes": null
    },
    "duel": {
        "desc": "duel effect that selects an effect based on comparing specified skill(s), and/or saved variable(s) on, of a character to a value or another character's skill(s). Alternatively, the compare value can be scripted completely",
        "usage": "duel = {\nskill = X\n(skills = { X1 X2 ... })\nchallenge_variable = saved_variable_name\n(challenge_variables = { saved_variable_name_1 saved_variable_name_2 ... })\ntarget = Y\nvalue = Z\nlocalization = W\nIf localization = W is specified, the effect localization W will be used (entry in effect_localization database, not a localization key directly).",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "else": {
        "desc": "Executes enclosed effects if limit criteria of preceding 'if' or 'else_if' is not met",
        "usage": "if = { limit = { <triggers> } <effects> }\nelse = { <effects> }",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "else_if": {
        "desc": "Executes enclosed effects if limit criteria of preceding 'if' or 'else_if' is not met, and its own limit is met",
        "usage": "if = { limit = { <triggers> } <effects> }\nelse_if = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "end_inspiration_sponsorship": {
        "desc": "end_inspiration_sponsorship = inspiration",
        "usage": "",
        "supported_scopes": "none",
        "supported_targets": "inspiration",
        "notes": "Stops the sponsorship of the targeted inspiration"
    },
    "error_log": {
        "desc": "Log a string to the error log when this effect executes, error_log = message, the message can be a localization string with ROOT, SCOPE and PREV available",
        "usage": "",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "every_accolade_type": {
        "desc": "Iterate through every accolade_type in the database",
        "usage": "every_accolade_type = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "accolade_type",
        "notes": null
    },
    "every_activity": {
        "desc": "Iterate through all activities in the world",
        "usage": "every_activity = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "activity",
        "notes": null
    },
    "every_activity_type": {
        "desc": "Iterate through every activity_type in the database",
        "usage": "every_activity_type = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "activity_type",
        "notes": null
    },
    "every_artifact": {
        "desc": "Iterate through all existing artifacts",
        "usage": "every_artifact = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "artifact",
        "notes": null
    },
    "every_barony": {
        "desc": "Iterate through all baronies in the game",
        "usage": "every_barony = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_casus_belli_type": {
        "desc": "Iterate through every casus_belli_type in the database",
        "usage": "every_casus_belli_type = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "casus_belli_type",
        "notes": null
    },
    "every_character_with_royal_court": {
        "desc": "Iterate through all characters with a royal court",
        "usage": "every_character_with_royal_court = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "character",
        "notes": null
    },
    "every_completed_legend": {
        "desc": "Gets all legends in the world that have been completed",
        "usage": "every_completed_legend = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "legend",
        "notes": null
    },
    "every_county": {
        "desc": "Iterate through all counties in the game",
        "usage": "every_county = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_county_in_region": {
        "desc": "Iterate through all counties in the region. Put 'region = region_name' inside it",
        "usage": "every_county_in_region = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_court_position_type": {
        "desc": "Iterate through every court_position_type in the database",
        "usage": "every_court_position_type = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "court_position_type",
        "notes": null
    },
    "every_culture_global": {
        "desc": "Iterate through all cultures in the game",
        "usage": "every_culture_global = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "culture",
        "notes": null
    },
    "every_culture_pillar": {
        "desc": "Iterate through every culture_pillar in the database",
        "usage": "every_culture_pillar = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "culture_pillar",
        "notes": null
    },
    "every_culture_tradition": {
        "desc": "Iterate through every culture_tradition in the database",
        "usage": "every_culture_tradition = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "culture_tradition",
        "notes": null
    },
    "every_decision": {
        "desc": "Iterate through every decision in the database",
        "usage": "every_decision = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "decision",
        "notes": null
    },
    "every_doctrine": {
        "desc": "Iterate through every doctrine in the database",
        "usage": "every_doctrine = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "doctrine",
        "notes": null
    },
    "every_domicile": {
        "desc": "Iterate through all domiciles",
        "usage": "every_domicile = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "domicile",
        "notes": null
    },
    "every_duchy": {
        "desc": "Iterate through all duchies in the game",
        "usage": "every_duchy = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_empire": {
        "desc": "Iterate through all empires in the game",
        "usage": "every_empire = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_epidemic": {
        "desc": "Gets all epidemics in the world",
        "usage": "every_epidemic = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "epidemic",
        "notes": null
    },
    "every_epidemic_type": {
        "desc": "Iterate through every epidemic_type in the database",
        "usage": "every_epidemic_type = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "epidemic_type",
        "notes": null
    },
    "every_geographical_region": {
        "desc": "Iterate through every geographical_region in the database",
        "usage": "every_geographical_region = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "geographical_region",
        "notes": null
    },
    "every_government_type": {
        "desc": "Iterate through every government_type in the database",
        "usage": "every_government_type = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "government_type",
        "notes": null
    },
    "every_holding_type": {
        "desc": "Iterate through every holding_type in the database",
        "usage": "every_holding_type = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "holding_type",
        "notes": null
    },
    "every_important_location": {
        "desc": "Iterate through all counties that are important for at least some title",
        "usage": "every_important_location = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_in_global_list": {
        "desc": "Iterate through all items in global list. list = name or variable = name",
        "usage": "every_in_global_list = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "every_in_list": {
        "desc": "Iterate through all items in list. list = name or variable = name",
        "usage": "every_in_list = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "every_in_local_list": {
        "desc": "Iterate through all items in local list. list = name or variable = name",
        "usage": "every_in_local_list = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "every_independent_ruler": {
        "desc": "Independent rulers list with a COUNT tier or above who hold land",
        "usage": "every_independent_ruler = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "character",
        "notes": null
    },
    "every_inspiration": {
        "desc": "Iterate through all inspirations in the world",
        "usage": "every_inspiration = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "inspiration",
        "notes": null
    },
    "every_inspired_character": {
        "desc": "Iterate through all characters with an inspirations in the world",
        "usage": "every_inspired_character = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "character",
        "notes": null
    },
    "every_interested_title": {
        "desc": "Iterate through all titles that are interested in any county",
        "usage": "every_interested_title = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_kingdom": {
        "desc": "Iterate through all kingdoms in the game",
        "usage": "every_kingdom = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_legend": {
        "desc": "Gets all legends in the world that have not been completed",
        "usage": "every_legend = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "legend",
        "notes": null
    },
    "every_legend_type": {
        "desc": "Iterate through every legend_type in the database",
        "usage": "every_legend_type = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "legend_type",
        "notes": null
    },
    "every_living_character": {
        "desc": "Iterate through all living characters",
        "usage": "every_living_character = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "character",
        "notes": null
    },
    "every_mercenary_company": {
        "desc": "Iterate through all mercenary companies",
        "usage": "every_mercenary_company = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "mercenary_company",
        "notes": null
    },
    "every_open_invite_activity": {
        "desc": "Iterate through all open invite activities in the world",
        "usage": "every_open_invite_activity = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "activity",
        "notes": null
    },
    "every_player": {
        "desc": "Iterate through all player characters",
        "usage": "every_player = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "character",
        "notes": null
    },
    "every_pool_character": {
        "desc": "Iterate through all characters in the pool of the given province",
        "usage": "every_pool_character = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "character",
        "notes": null
    },
    "every_province": {
        "desc": "Iterate through all provinces (skips non-land and impassable provinces)",
        "usage": "every_province = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "province",
        "notes": null
    },
    "every_religion_global": {
        "desc": "Iterate through all religions in the game",
        "usage": "every_religion_global = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "religion",
        "notes": null
    },
    "every_ruler": {
        "desc": "Rulers list with a COUNT tier o above",
        "usage": "every_ruler = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "character",
        "notes": null
    },
    "every_special_building_province": {
        "desc": "Iterate through all provinces with a special building slot (built or un-built)",
        "usage": "every_special_building_province = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "province",
        "notes": null
    },
    "every_task_contract": {
        "desc": "Gets all available and accepted task contracts.",
        "usage": "every_task_contract = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "task_contract",
        "notes": null
    },
    "every_task_contract_type": {
        "desc": "Iterate through every task_contract_type in the database",
        "usage": "every_task_contract_type = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "task_contract_type",
        "notes": null
    },
    "every_trait": {
        "desc": "Iterate through every trait in the database",
        "usage": "every_trait = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "trait",
        "notes": null
    },
    "every_trait_in_category": {
        "desc": "Iterate through all traits in a given category",
        "usage": "any_trait_in_category = { category = fame/health/etc }\nevery_trait_in_category = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "trait",
        "notes": null
    },
    "every_vassal_contract": {
        "desc": "Iterate through every vassal_contract in the database",
        "usage": "every_vassal_contract = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "vassal_contract",
        "notes": null
    },
    "hidden_effect": {
        "desc": "Effect not shown in tooltips",
        "usage": "",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "hidden_effect_new_object": {
        "desc": "Suppress errors for effects using to-be created objects (like artifacts or characters) in tooltips. The effects inside are hidden from the tooltip, with no description generated whatsoever!",
        "usage": "",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "if": {
        "desc": "Executes enclosed effects if limit criteria are met",
        "usage": "if = { limit = { <triggers> } <effects> }",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "invalidate_activity": {
        "desc": "Invalidate and destroy the target activity, running its on_invalidate effect",
        "usage": "invalidate_activity = scope:activity",
        "supported_scopes": "none",
        "supported_targets": "activity",
        "notes": null
    },
    "multiply_focus_progress": {
        "desc": "Multiplies focus progress",
        "usage": "",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "open_interaction_window": {
        "desc": "Tries to open the defined view.",
        "usage": "interaction = interaction_key - the interaction object key to open\nredirect = [yes|no] - yes by default, redirect the actor and recipients ( only works if secondary_actor and secondary_recipient are not setup or are invalid)\nactor = character_actor - must be defined, must coincide with the current player\nrecipient = character_actor - must be defined\nsecondary_actor = character_secondary_actor - optional\nsecondary_recipient = character_secondary_recipient - optional\ntarget_title = title - optional",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "open_view": {
        "desc": "Tries to open the defined view without scope data.",
        "usage": "open_view = {\nview = <view name>\nview_message = <view specific instruction> # optional\nplayer = scope:character # optional, else shows for all players who execute the effect\n}simplified: open_view = <view name>",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": "Take care to set player if effect is executed not through UI but through synchronized code. Else all the window will open for all players."
    },
    "open_view_data": {
        "desc": "Tries to open the defined view with scope data.",
        "usage": "open_view_data = {\nview = <view name>\nview_message = <view specific instruction> # optional\nplayer = scope:character # optional, else shows for all players who execute the effect\nsimplified: open_view_data = <view name>\nfor example: scope:faith = { open_view_data = faith_conversion }",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": "Take care to set player if effect is executed not through UI but through synchronized code. Else all the window will open for all players."
    },
    "ordered_accolade_type": {
        "desc": "Iterate through every accolade_type in the database",
        "usage": "ordered_accolade_type = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "accolade_type",
        "notes": null
    },
    "ordered_activity": {
        "desc": "Iterate through all activities in the world",
        "usage": "ordered_activity = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "activity",
        "notes": null
    },
    "ordered_activity_type": {
        "desc": "Iterate through every activity_type in the database",
        "usage": "ordered_activity_type = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "activity_type",
        "notes": null
    },
    "ordered_artifact": {
        "desc": "Iterate through all existing artifacts",
        "usage": "ordered_artifact = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "artifact",
        "notes": null
    },
    "ordered_barony": {
        "desc": "Iterate through all baronies in the game",
        "usage": "ordered_barony = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_casus_belli_type": {
        "desc": "Iterate through every casus_belli_type in the database",
        "usage": "ordered_casus_belli_type = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "casus_belli_type",
        "notes": null
    },
    "ordered_character_with_royal_court": {
        "desc": "Iterate through all characters with a royal court",
        "usage": "ordered_character_with_royal_court = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_completed_legend": {
        "desc": "Gets all legends in the world that have been completed",
        "usage": "ordered_completed_legend = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "legend",
        "notes": null
    },
    "ordered_county": {
        "desc": "Iterate through all counties in the game",
        "usage": "ordered_county = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_county_in_region": {
        "desc": "Iterate through all counties in the region. Put 'region = region_name' inside it",
        "usage": "ordered_county_in_region = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_court_position_type": {
        "desc": "Iterate through every court_position_type in the database",
        "usage": "ordered_court_position_type = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "court_position_type",
        "notes": null
    },
    "ordered_culture_global": {
        "desc": "Iterate through all cultures in the game",
        "usage": "ordered_culture_global = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "culture",
        "notes": null
    },
    "ordered_culture_pillar": {
        "desc": "Iterate through every culture_pillar in the database",
        "usage": "ordered_culture_pillar = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "culture_pillar",
        "notes": null
    },
    "ordered_culture_tradition": {
        "desc": "Iterate through every culture_tradition in the database",
        "usage": "ordered_culture_tradition = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "culture_tradition",
        "notes": null
    },
    "ordered_decision": {
        "desc": "Iterate through every decision in the database",
        "usage": "ordered_decision = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "decision",
        "notes": null
    },
    "ordered_doctrine": {
        "desc": "Iterate through every doctrine in the database",
        "usage": "ordered_doctrine = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "doctrine",
        "notes": null
    },
    "ordered_domicile": {
        "desc": "Iterate through all domiciles",
        "usage": "ordered_domicile = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "domicile",
        "notes": null
    },
    "ordered_duchy": {
        "desc": "Iterate through all duchies in the game",
        "usage": "ordered_duchy = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_empire": {
        "desc": "Iterate through all empires in the game",
        "usage": "ordered_empire = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_epidemic": {
        "desc": "Gets all epidemics in the world",
        "usage": "ordered_epidemic = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "epidemic",
        "notes": null
    },
    "ordered_epidemic_type": {
        "desc": "Iterate through every epidemic_type in the database",
        "usage": "ordered_epidemic_type = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "epidemic_type",
        "notes": null
    },
    "ordered_geographical_region": {
        "desc": "Iterate through every geographical_region in the database",
        "usage": "ordered_geographical_region = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "geographical_region",
        "notes": null
    },
    "ordered_government_type": {
        "desc": "Iterate through every government_type in the database",
        "usage": "ordered_government_type = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "government_type",
        "notes": null
    },
    "ordered_holding_type": {
        "desc": "Iterate through every holding_type in the database",
        "usage": "ordered_holding_type = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "holding_type",
        "notes": null
    },
    "ordered_important_location": {
        "desc": "Iterate through all counties that are important for at least some title",
        "usage": "ordered_important_location = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_in_global_list": {
        "desc": "Iterate through all items in global list. list = name or variable = name",
        "usage": "ordered_in_global_list = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "ordered_in_list": {
        "desc": "Iterate through all items in list. list = name or variable = name",
        "usage": "ordered_in_list = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "ordered_in_local_list": {
        "desc": "Iterate through all items in local list. list = name or variable = name",
        "usage": "ordered_in_local_list = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "ordered_independent_ruler": {
        "desc": "Independent rulers list with a COUNT tier or above who hold land",
        "usage": "ordered_independent_ruler = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_inspiration": {
        "desc": "Iterate through all inspirations in the world",
        "usage": "ordered_inspiration = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "inspiration",
        "notes": null
    },
    "ordered_inspired_character": {
        "desc": "Iterate through all characters with an inspirations in the world",
        "usage": "ordered_inspired_character = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_interested_title": {
        "desc": "Iterate through all titles that are interested in any county",
        "usage": "ordered_interested_title = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_kingdom": {
        "desc": "Iterate through all kingdoms in the game",
        "usage": "ordered_kingdom = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_legend": {
        "desc": "Gets all legends in the world that have not been completed",
        "usage": "ordered_legend = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "legend",
        "notes": null
    },
    "ordered_legend_type": {
        "desc": "Iterate through every legend_type in the database",
        "usage": "ordered_legend_type = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "legend_type",
        "notes": null
    },
    "ordered_living_character": {
        "desc": "Iterate through all living characters",
        "usage": "ordered_living_character = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_mercenary_company": {
        "desc": "Iterate through all mercenary companies",
        "usage": "ordered_mercenary_company = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "mercenary_company",
        "notes": null
    },
    "ordered_open_invite_activity": {
        "desc": "Iterate through all open invite activities in the world",
        "usage": "ordered_open_invite_activity = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "activity",
        "notes": null
    },
    "ordered_player": {
        "desc": "Iterate through all player characters",
        "usage": "ordered_player = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_pool_character": {
        "desc": "Iterate through all characters in the pool of the given province",
        "usage": "ordered_pool_character = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_province": {
        "desc": "Iterate through all provinces (skips non-land and impassable provinces)",
        "usage": "ordered_province = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "province",
        "notes": null
    },
    "ordered_religion_global": {
        "desc": "Iterate through all religions in the game",
        "usage": "ordered_religion_global = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "religion",
        "notes": null
    },
    "ordered_ruler": {
        "desc": "Rulers list with a COUNT tier o above",
        "usage": "ordered_ruler = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_special_building_province": {
        "desc": "Iterate through all provinces with a special building slot (built or un-built)",
        "usage": "ordered_special_building_province = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "province",
        "notes": null
    },
    "ordered_task_contract": {
        "desc": "Gets all available and accepted task contracts.",
        "usage": "ordered_task_contract = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "task_contract",
        "notes": null
    },
    "ordered_task_contract_type": {
        "desc": "Iterate through every task_contract_type in the database",
        "usage": "ordered_task_contract_type = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "task_contract_type",
        "notes": null
    },
    "ordered_trait": {
        "desc": "Iterate through every trait in the database",
        "usage": "ordered_trait = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "trait",
        "notes": null
    },
    "ordered_trait_in_category": {
        "desc": "Iterate through all traits in a given category",
        "usage": "any_trait_in_category = { category = fame/health/etc }\nordered_trait_in_category = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "trait",
        "notes": null
    },
    "ordered_vassal_contract": {
        "desc": "Iterate through every vassal_contract in the database",
        "usage": "ordered_vassal_contract = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "none",
        "supported_targets": "vassal_contract",
        "notes": null
    },
    "pan_camera_to_province": {
        "desc": "Pans the camera to the specified province",
        "usage": "pan_camera_to_province = scope:army.location",
        "supported_scopes": "none",
        "supported_targets": "province",
        "notes": null
    },
    "pan_camera_to_title": {
        "desc": "Pans the camera to the specified title",
        "usage": "pan_camera_to_title = capital_barony",
        "supported_scopes": "none",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random": {
        "desc": "a random effect, random = { chance = X modifier = Y effects... }",
        "usage": "",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": "where X is a chance of the enclosed effects being fired and can be modified by optional value modifier list (AKA MTTH) Y"
    },
    "random_accolade_type": {
        "desc": "Iterate through every accolade_type in the database",
        "usage": "random_accolade_type = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "accolade_type",
        "notes": null
    },
    "random_activity": {
        "desc": "Iterate through all activities in the world",
        "usage": "random_activity = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "activity",
        "notes": null
    },
    "random_activity_type": {
        "desc": "Iterate through every activity_type in the database",
        "usage": "random_activity_type = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "activity_type",
        "notes": null
    },
    "random_artifact": {
        "desc": "Iterate through all existing artifacts",
        "usage": "random_artifact = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "artifact",
        "notes": null
    },
    "random_barony": {
        "desc": "Iterate through all baronies in the game",
        "usage": "random_barony = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_casus_belli_type": {
        "desc": "Iterate through every casus_belli_type in the database",
        "usage": "random_casus_belli_type = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "casus_belli_type",
        "notes": null
    },
    "random_character_with_royal_court": {
        "desc": "Iterate through all characters with a royal court",
        "usage": "random_character_with_royal_court = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "character",
        "notes": null
    },
    "random_completed_legend": {
        "desc": "Gets all legends in the world that have been completed",
        "usage": "random_completed_legend = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "legend",
        "notes": null
    },
    "random_county": {
        "desc": "Iterate through all counties in the game",
        "usage": "random_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_county_in_region": {
        "desc": "Iterate through all counties in the region. Put 'region = region_name' inside it",
        "usage": "random_county_in_region = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_court_position_type": {
        "desc": "Iterate through every court_position_type in the database",
        "usage": "random_court_position_type = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "court_position_type",
        "notes": null
    },
    "random_culture_global": {
        "desc": "Iterate through all cultures in the game",
        "usage": "random_culture_global = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "culture",
        "notes": null
    },
    "random_culture_pillar": {
        "desc": "Iterate through every culture_pillar in the database",
        "usage": "random_culture_pillar = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "culture_pillar",
        "notes": null
    },
    "random_culture_tradition": {
        "desc": "Iterate through every culture_tradition in the database",
        "usage": "random_culture_tradition = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "culture_tradition",
        "notes": null
    },
    "random_decision": {
        "desc": "Iterate through every decision in the database",
        "usage": "random_decision = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "decision",
        "notes": null
    },
    "random_doctrine": {
        "desc": "Iterate through every doctrine in the database",
        "usage": "random_doctrine = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "doctrine",
        "notes": null
    },
    "random_domicile": {
        "desc": "Iterate through all domiciles",
        "usage": "random_domicile = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "domicile",
        "notes": null
    },
    "random_duchy": {
        "desc": "Iterate through all duchies in the game",
        "usage": "random_duchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_empire": {
        "desc": "Iterate through all empires in the game",
        "usage": "random_empire = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_epidemic": {
        "desc": "Gets all epidemics in the world",
        "usage": "random_epidemic = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "epidemic",
        "notes": null
    },
    "random_epidemic_type": {
        "desc": "Iterate through every epidemic_type in the database",
        "usage": "random_epidemic_type = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "epidemic_type",
        "notes": null
    },
    "random_geographical_region": {
        "desc": "Iterate through every geographical_region in the database",
        "usage": "random_geographical_region = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "geographical_region",
        "notes": null
    },
    "random_government_type": {
        "desc": "Iterate through every government_type in the database",
        "usage": "random_government_type = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "government_type",
        "notes": null
    },
    "random_holding_type": {
        "desc": "Iterate through every holding_type in the database",
        "usage": "random_holding_type = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "holding_type",
        "notes": null
    },
    "random_important_location": {
        "desc": "Iterate through all counties that are important for at least some title",
        "usage": "random_important_location = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_in_global_list": {
        "desc": "Iterate through all items in global list. list = name or variable = name",
        "usage": "random_in_global_list = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "random_in_list": {
        "desc": "Iterate through all items in list. list = name or variable = name",
        "usage": "random_in_list = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "random_in_local_list": {
        "desc": "Iterate through all items in local list. list = name or variable = name",
        "usage": "random_in_local_list = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "random_independent_ruler": {
        "desc": "Independent rulers list with a COUNT tier or above who hold land",
        "usage": "random_independent_ruler = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "character",
        "notes": null
    },
    "random_inspiration": {
        "desc": "Iterate through all inspirations in the world",
        "usage": "random_inspiration = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "inspiration",
        "notes": null
    },
    "random_inspired_character": {
        "desc": "Iterate through all characters with an inspirations in the world",
        "usage": "random_inspired_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "character",
        "notes": null
    },
    "random_interested_title": {
        "desc": "Iterate through all titles that are interested in any county",
        "usage": "random_interested_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_kingdom": {
        "desc": "Iterate through all kingdoms in the game",
        "usage": "random_kingdom = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_legend": {
        "desc": "Gets all legends in the world that have not been completed",
        "usage": "random_legend = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "legend",
        "notes": null
    },
    "random_legend_type": {
        "desc": "Iterate through every legend_type in the database",
        "usage": "random_legend_type = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "legend_type",
        "notes": null
    },
    "random_list": {
        "desc": "a random list effect",
        "usage": "random_list = { X1 = { trigger = { enables/disable this effect} modifier/compare_modifier/opinion_modifier = Y1 effect1 } X2 = { trigger = { enables/disable this effect} modifier/compare_modifier/opinion_modifier = Y2 effect2 } ... }",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "random_living_character": {
        "desc": "Iterate through all living characters",
        "usage": "random_living_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "character",
        "notes": null
    },
    "random_log_scopes": {
        "desc": "Log the current scope to the random log when this effect executes. Only use temprorarily for debugging purposes as it can introduce localized strings into the Scopes._Random log. yes = full scope info, no=only current scope",
        "usage": "",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "random_mercenary_company": {
        "desc": "Iterate through all mercenary companies",
        "usage": "random_mercenary_company = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "mercenary_company",
        "notes": null
    },
    "random_open_invite_activity": {
        "desc": "Iterate through all open invite activities in the world",
        "usage": "random_open_invite_activity = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "activity",
        "notes": null
    },
    "random_player": {
        "desc": "Iterate through all player characters",
        "usage": "random_player = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "character",
        "notes": null
    },
    "random_pool_character": {
        "desc": "Iterate through all characters in the pool of the given province",
        "usage": "random_pool_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "character",
        "notes": null
    },
    "random_province": {
        "desc": "Iterate through all provinces (skips non-land and impassable provinces)",
        "usage": "random_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "province",
        "notes": null
    },
    "random_religion_global": {
        "desc": "Iterate through all religions in the game",
        "usage": "random_religion_global = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "religion",
        "notes": null
    },
    "random_ruler": {
        "desc": "Rulers list with a COUNT tier o above",
        "usage": "random_ruler = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "character",
        "notes": null
    },
    "random_special_building_province": {
        "desc": "Iterate through all provinces with a special building slot (built or un-built)",
        "usage": "random_special_building_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "province",
        "notes": null
    },
    "random_task_contract": {
        "desc": "Gets all available and accepted task contracts.",
        "usage": "random_task_contract = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "task_contract",
        "notes": null
    },
    "random_task_contract_type": {
        "desc": "Iterate through every task_contract_type in the database",
        "usage": "random_task_contract_type = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "task_contract_type",
        "notes": null
    },
    "random_trait": {
        "desc": "Iterate through every trait in the database",
        "usage": "random_trait = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "trait",
        "notes": null
    },
    "random_trait_in_category": {
        "desc": "Iterate through all traits in a given category",
        "usage": "any_trait_in_category = { category = fame/health/etc }\nrandom_trait_in_category = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "trait",
        "notes": null
    },
    "random_vassal_contract": {
        "desc": "Iterate through every vassal_contract in the database",
        "usage": "random_vassal_contract = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "none",
        "supported_targets": "vassal_contract",
        "notes": null
    },
    "recalculate_cultural_heads_of_type": {
        "desc": "Forces a recalculation of heads of provided determination type",
        "usage": "recalculate_cultural_heads_of_type = herd",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "remove_from_list": {
        "desc": "Removes the current scope from a named list remove_from_list = <string>",
        "usage": "",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "remove_global_variable": {
        "desc": "Removes a variable",
        "usage": "remove_variable = variable_name",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "remove_list_global_variable": {
        "desc": "Removes the target from a variable list",
        "usage": "remove_list_variable = { name = X target = Y }",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "remove_list_local_variable": {
        "desc": "Removes the target from a variable list",
        "usage": "remove_list_variable = { name = X target = Y }",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "remove_list_variable": {
        "desc": "Removes the target from a variable list",
        "usage": "remove_list_variable = { name = X target = Y }",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "remove_local_variable": {
        "desc": "Removes a variable",
        "usage": "remove_variable = variable_name",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "remove_title_law": {
        "desc": "remove law from scoped title. This will leave the law group empty, so only do this if you're getting rid of a law group. DOES NOT apply law removal costs and effects.",
        "usage": "remove_title_law = princely_elective_succession_law",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "remove_title_law_effects": {
        "desc": "remove law from scoped title. This will leave the law group empty, so only do this if you're getting rid of a law group. DOES apply law removal costs and effects.",
        "usage": "remove_title_law = princely_elective_succession_law",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "remove_variable": {
        "desc": "Removes a variable",
        "usage": "remove_variable = variable_name",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "resolve_title_and_vassal_change": {
        "desc": "resolve_title_and_vassal_change = scope:change",
        "usage": "",
        "supported_scopes": "none",
        "supported_targets": "title_and_vassal_change",
        "notes": "Execute and destory the target title and vassal change, the change cannot be used after calling this effect"
    },
    "round_global_variable": {
        "desc": "Rounds a variable to the nearest specified value",
        "usage": "round_variable = { name = X nearest = Y }",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "round_local_variable": {
        "desc": "Rounds a variable to the nearest specified value",
        "usage": "round_variable = { name = X nearest = Y }",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "round_variable": {
        "desc": "Rounds a variable to the nearest specified value",
        "usage": "round_variable = { name = X nearest = Y }",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "run_interaction": {
        "desc": "Execute/send the given interaction",
        "usage": "interaction = interaction_key - the interaction object key to run\nredirect = [yes|no] - yes by default, redirect the actor and recipients ( only works if secondary_actor and secondary_recipient are not setup or are invalid)\nactor = character_actor - must be defined\nrecipient = character_actor - must be defined\nsecondary_actor = character_secontary_actor - optional\nsecondary_recipient = character_secondary_recipient - optional\nexecute_threshold = accept/maybe/decline - will be executed immediately if the AI response is at least this\nsend_threshold = accept/maybe/decline - will be sent if the AI response is at least this",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "save_opinion_value_as": {
        "desc": "Saves the scoped character's opinion of the target character as an arbitrarily-named target to be referenced later in the (unbroken) event chain",
        "usage": "save_opinion_value_as = { name = <string> target = x }",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "save_scope_as": {
        "desc": "Saves the current scope as an arbitrarily-named target to be referenced later in the (unbroken) event chain",
        "usage": "save_event_target_as = <string>",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "save_scope_value_as": {
        "desc": "Saves a numerical or bool value as an arbitrarily-named target to be referenced later in the (unbroken) event chain",
        "usage": "save_scope_value_as = { name = <string> value = x }",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "save_temporary_opinion_value_as": {
        "desc": "Saves the scoped character's opinion of the target character as an arbitrarily-named target to be referenced later in the in the same effect",
        "usage": "save_temporary_opinion_value_as = { name = <string> target = x",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "save_temporary_scope_as": {
        "desc": "Saves the current scope as an arbitrarily-named temporary target to be referenced later in the same effect",
        "usage": "save_temporary_event_target_as = <string>",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "save_temporary_scope_value_as": {
        "desc": "Saves a numerical or bool value as an arbitrarily-named temporary target to be referenced later in the same effect",
        "usage": "save_temporary_scope_value_as = { name = <string> value = x }",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "send_long_tutorial_finished_telemetry": {
        "desc": "Sends a tutorial_finished telemetry event with LongVersion = true",
        "usage": "",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "send_long_tutorial_started_telemetry": {
        "desc": "Sends a tutorial_started telemetry event with LongVersion = true",
        "usage": "",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "send_short_tutorial_finished_telemetry": {
        "desc": "Sends a tutorial_finished telemetry event with LongVersion = false",
        "usage": "",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "send_short_tutorial_started_telemetry": {
        "desc": "Sends a tutorial_started telemetry event with LongVersion = false",
        "usage": "",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "set_focus_progress": {
        "desc": "Sets focus progress",
        "usage": "",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "set_generated_asexuality_chance": {
        "desc": "Sets the chance for a generated character to be asexual",
        "usage": "set_generated_asexuality_chance = 20",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "set_generated_bisexuality_chance": {
        "desc": "Sets the chance for a generated character to be bisexual",
        "usage": "set_generated_bisexuality_chance = 20",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "set_generated_homosexuality_chance": {
        "desc": "Sets the chance for a generated character to be homosexual",
        "usage": "set_generated_homosexuality_chance = 20",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "set_global_variable": {
        "desc": "Sets a variable",
        "usage": "set_variable = { name = X value = Y days = Z }\nCan also be used as set_variable = X (equivalent to set_variable = { name = X value = yes })",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "set_local_variable": {
        "desc": "Sets a variable",
        "usage": "set_variable = { name = X value = Y days = Z }\nCan also be used as set_variable = X (equivalent to set_variable = { name = X value = yes })",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "set_pregnancy_gender": {
        "desc": "Set the gender of the unborn child",
        "usage": "set_pregnancy_gender = female/male/random",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "set_variable": {
        "desc": "Sets a variable",
        "usage": "set_variable = { name = X value = Y days = Z }\nCan also be used as set_variable = X (equivalent to set_variable = { name = X value = yes })",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "setup_claim_cb": {
        "desc": "This effect will add a scope:cb_prestige_factor with a value based on what's being taken",
        "usage": "setup_claim_cb = {\nattacker = scope:attacker\ndefender = scope:defender\nclaimant = scope:claimant\nchange = scope:change\nvictory = yes/no\ntake_occupied = yes/no\ncivil_war = yes",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": "Won't steal land from people not vassalized"
    },
    "setup_de_jure_cb": {
        "desc": "This effect will add a scope:cb_prestige_factor with a value based on what's being taken",
        "usage": "setup_de_jure_cb = {\nattacker = scope:attacker\ndefender = scope:defender\nchange = scope:change\nvictory = yes/no\ntitle = scope:title",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "setup_invasion_cb": {
        "desc": "This effect will add a scope:cb_prestige_factor with a value based on what's being taken",
        "usage": "setup_invasion_cb = {\nattacker = scope:attacker\ndefender = scope:defender\nchange = scope:change\nvictory = yes/no\ntake_occupied = yes/no",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "show_as_tooltip": {
        "desc": "Effect only shown in tooltips (but not executed)",
        "usage": "",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "start_situation": {
        "desc": "Start a Situation of a specific situation type, optionally in a specific starting phase.",
        "usage": "start_situation = {\ntype = X\n<start_phase = Y>\n<save_scope_as = scope_name>\n<save_temporary_scope_as = scope_name>\nsub_region = {\nkey = my_sub_region\n<start_phase = my_first_phase>\n<geographical_regions = { ... }>\n<map_color = { 0 0 0 }>\nsub_region = {",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": "You can also optionally override named sub-regions with custom data."
    },
    "start_struggle": {
        "desc": "Start a struggle, start_struggle = { struggle_type = X start_phase = Y }where X is a struggle type, Y is a phase",
        "usage": "",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "start_tutorial_lesson": {
        "desc": "Starts the tutorial lesson with the given key. Does nothing if the tutorial is not running, the lesson is completed (or already running), or the lesson cannot be triggered (e.g. trigger fails)",
        "usage": "",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "stats_log": {
        "desc": "Log key value pairs to a given category via the elastic logging statistics",
        "usage": "stats_log = { category = string <string> = <loc_key> }",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "switch": {
        "desc": "Switch on a trigger for the evaluation of another trigger with an optional fallback trigger.",
        "usage": "switch = {\ntrigger = simple_assign_trigger\ncase_1 = { <effects> }\ncase_2 = { <effects> }\ncase_n = { <effects> }\nfallback = { <effects> }",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "trigger_event": {
        "desc": "triggers an event or on_action",
        "usage": "trigger_event = {\nid = <event ID>                               # or:\non_action = <on_action name>                  # or:\nsaved_event_id = <event target with event ID> # example: scope:my_flag_name\n# optionally, the event can be delayed via one of those choices:    days/months/years = <num>\ndays/months/years = { <num> <num> }           # pick a value randomly from the range\ntrigger_on_next_date = \"<year>.<month>.<day>\" # trigger on a specific date in the future\ntrigger_on_next_date = \"<month>.<day>\"        # trigger the next time this date is reached (this or next year)\ndelayed = yes                                 # delay to the next tick",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "try_create_important_action": {
        "desc": "Tries to create an important action notification. Will keep the current one if already exists.",
        "usage": "important_action_type = important_action_type_key - the important action object key to create. Must be defined.\nscope_name = object - optional, saves the object as the named scope to be be used by the important action effect",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "try_create_suggestion": {
        "desc": "Tries to create an suggestuib notification. Will keep the current one if already exists.",
        "usage": "suggestion_type = suggestion_type_key - the suggestion action object key to create. Must be defined.\nactor = character_actor - optional, can be used by the suggestion effect\nrecipient = character_actor - optional, can be used by the suggestion effect\nsecondary_actor = character_secondary_actor - optional, can be used by the suggestion effect\nsecondary_recipient = character_secondary_recipient - optional, can be used by the suggestion effect\nlanded_title = landed_title - optional, can be used by the suggestion effect",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "while": {
        "desc": "Repeats enclosed effects while limit criteria are met or until set iteration count is reached",
        "usage": "while = { limit = { <triggers> } <effects> }\nwhile = { count = 3 <effects> }",
        "supported_scopes": "none",
        "supported_targets": null,
        "notes": null
    },
    "add_building": {
        "desc": "Add building to the province<province> = { add_building = <building_name> }",
        "usage": "",
        "supported_scopes": "province",
        "supported_targets": null,
        "notes": null
    },
    "add_legend_spread": {
        "desc": "Adds the target legend as spread to the scoped province.",
        "usage": "add_legend_spread = legend",
        "supported_scopes": "province",
        "supported_targets": "legend",
        "notes": null
    },
    "add_province_modifier": {
        "desc": "Add a modifier to a province",
        "usage": "add_province_modifier = name\nadd_province_modifier = { modifier = name days/weeks/months/years = int }",
        "supported_scopes": "province",
        "supported_targets": null,
        "notes": null
    },
    "add_special_building": {
        "desc": "Add a special building to the province (will also add/change a special slot if needed)",
        "usage": "",
        "supported_scopes": "province",
        "supported_targets": null,
        "notes": null
    },
    "add_special_building_slot": {
        "desc": "Add a special building slot to the province<province> = { add_special_building_slot = <building_name> }",
        "usage": "",
        "supported_scopes": "province",
        "supported_targets": null,
        "notes": null
    },
    "add_travel_point_of_interest": {
        "desc": "Add a travel point of interest type to this province.",
        "usage": "add_travel_point_of_interest = point_of_interest_type",
        "supported_scopes": "province",
        "supported_targets": null,
        "notes": null
    },
    "begin_create_holding": {
        "desc": "Start construction of the specified holding type. By default player won't get anything if manually cancels the construction",
        "usage": "scope:my_province = {\nbegin_create_holding = castle_holding\nscope:my_province = {\nbegin_create_holding = {\ntype = castle_holding\nrefund_cost = {\ngold = 100",
        "supported_scopes": "province",
        "supported_targets": null,
        "notes": null
    },
    "create_epidemic_outbreak": {
        "desc": "Creates a new epidemic in the scoped province.",
        "usage": "create_epidemic_outbreak = {\ntype = smallpox\nintensity = major\nsave_scope_as = new_epidemic # optional",
        "supported_scopes": "province",
        "supported_targets": null,
        "notes": null
    },
    "every_army_in_location": {
        "desc": "Iterate through all armies currently located in the scoped province",
        "usage": "every_army_in_location = { limit = { <triggers> } <effects> }",
        "supported_scopes": "province",
        "supported_targets": "army",
        "notes": null
    },
    "every_character_in_location": {
        "desc": "Iterate through all characters currently located in the scoped province",
        "usage": "every_character_in_location = { limit = { <triggers> } <effects> }",
        "supported_scopes": "province",
        "supported_targets": "character",
        "notes": null
    },
    "every_neighboring_province": {
        "desc": "Iterate through all neighboring provinces of a province",
        "usage": "every_neighboring_province = { limit = { <triggers> } <effects> }",
        "supported_scopes": "province",
        "supported_targets": "province",
        "notes": null
    },
    "every_province_domicile": {
        "desc": "Iterate through all domiciles of scoped province",
        "usage": "every_province_domicile = { limit = { <triggers> } <effects> }",
        "supported_scopes": "province",
        "supported_targets": "domicile",
        "notes": null
    },
    "every_province_epidemic": {
        "desc": "Gets epidemics affecting the scoped province",
        "usage": "every_province_epidemic = { limit = { <triggers> } <effects> }",
        "supported_scopes": "province",
        "supported_targets": "epidemic",
        "notes": null
    },
    "every_province_legend": {
        "desc": "Gets legends affecting the scoped province",
        "usage": "every_province_legend = { limit = { <triggers> } <effects> }",
        "supported_scopes": "province",
        "supported_targets": "legend",
        "notes": null
    },
    "generate_building": {
        "desc": "Adds a random building to the province, using the AI's construction logic<province> = { generate_building = yes }",
        "usage": "",
        "supported_scopes": "province",
        "supported_targets": null,
        "notes": null
    },
    "ordered_army_in_location": {
        "desc": "Iterate through all armies currently located in the scoped province",
        "usage": "ordered_army_in_location = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "province",
        "supported_targets": "army",
        "notes": null
    },
    "ordered_character_in_location": {
        "desc": "Iterate through all characters currently located in the scoped province",
        "usage": "ordered_character_in_location = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "province",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_neighboring_province": {
        "desc": "Iterate through all neighboring provinces of a province",
        "usage": "ordered_neighboring_province = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "province",
        "supported_targets": "province",
        "notes": null
    },
    "ordered_province_domicile": {
        "desc": "Iterate through all domiciles of scoped province",
        "usage": "ordered_province_domicile = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "province",
        "supported_targets": "domicile",
        "notes": null
    },
    "ordered_province_epidemic": {
        "desc": "Gets epidemics affecting the scoped province",
        "usage": "ordered_province_epidemic = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "province",
        "supported_targets": "epidemic",
        "notes": null
    },
    "ordered_province_legend": {
        "desc": "Gets legends affecting the scoped province",
        "usage": "ordered_province_legend = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "province",
        "supported_targets": "legend",
        "notes": null
    },
    "random_army_in_location": {
        "desc": "Iterate through all armies currently located in the scoped province",
        "usage": "random_army_in_location = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "province",
        "supported_targets": "army",
        "notes": null
    },
    "random_character_in_location": {
        "desc": "Iterate through all characters currently located in the scoped province",
        "usage": "random_character_in_location = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "province",
        "supported_targets": "character",
        "notes": null
    },
    "random_neighboring_province": {
        "desc": "Iterate through all neighboring provinces of a province",
        "usage": "random_neighboring_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "province",
        "supported_targets": "province",
        "notes": null
    },
    "random_province_domicile": {
        "desc": "Iterate through all domiciles of scoped province",
        "usage": "random_province_domicile = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "province",
        "supported_targets": "domicile",
        "notes": null
    },
    "random_province_epidemic": {
        "desc": "Gets epidemics affecting the scoped province",
        "usage": "random_province_epidemic = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "province",
        "supported_targets": "epidemic",
        "notes": null
    },
    "random_province_legend": {
        "desc": "Gets legends affecting the scoped province",
        "usage": "random_province_legend = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "province",
        "supported_targets": "legend",
        "notes": null
    },
    "refill_garrison": {
        "desc": "The scoped province gets its garrison refilled. refill_levy = yes/no",
        "usage": "",
        "supported_scopes": "province",
        "supported_targets": null,
        "notes": null
    },
    "refill_levy": {
        "desc": "The scoped province gets its levy refilled. refill_levy = yes/no",
        "usage": "",
        "supported_scopes": "province",
        "supported_targets": null,
        "notes": null
    },
    "remove_all_province_modifier_instances": {
        "desc": "Remove all instances of a modifier from a province",
        "usage": "remove_all_province_modifier_instances = name",
        "supported_scopes": "province",
        "supported_targets": null,
        "notes": null
    },
    "remove_building": {
        "desc": "Remove building from the province<province> = { remove_building = <building_name> }",
        "usage": "",
        "supported_scopes": "province",
        "supported_targets": null,
        "notes": null
    },
    "remove_holding": {
        "desc": "Removes the holding in scoped province, cannot remove capital holdings",
        "usage": "",
        "supported_scopes": "province",
        "supported_targets": null,
        "notes": null
    },
    "remove_legend_spread": {
        "desc": "Removes the target legend as spread to the scoped province.",
        "usage": "remove_legend_spread = legend",
        "supported_scopes": "province",
        "supported_targets": "legend",
        "notes": null
    },
    "remove_province_modifier": {
        "desc": "Remove a modifier from a province",
        "usage": "remove_province_modifier = name",
        "supported_scopes": "province",
        "supported_targets": null,
        "notes": null
    },
    "remove_travel_point_of_interest": {
        "desc": "Remove a travel point of interest type in this province.",
        "usage": "remove_travel_point_of_interest = point_of_interest_type",
        "supported_scopes": "province",
        "supported_targets": null,
        "notes": null
    },
    "set_holding_type": {
        "desc": "Changes the scoped province's holding to another type, removing all buildings that are invalid for the new holding.",
        "usage": "",
        "supported_scopes": "province",
        "supported_targets": null,
        "notes": "This might also allow to construct a new holding in an empty province, but it is untested."
    },
    "add_attacker": {
        "desc": "adds the target character to the scope war as an attacker",
        "usage": "",
        "supported_scopes": "war",
        "supported_targets": "character",
        "notes": null
    },
    "add_defender": {
        "desc": "adds the target character to the scope war as a defender",
        "usage": "",
        "supported_scopes": "war",
        "supported_targets": "character",
        "notes": null
    },
    "clear_claimant": {
        "desc": "Removes the claimant from a war",
        "usage": "",
        "supported_scopes": "war",
        "supported_targets": null,
        "notes": null
    },
    "end_war": {
        "desc": "ends the war with the specified winner, end_war = attacker/defender/white_peace",
        "usage": "",
        "supported_scopes": "war",
        "supported_targets": null,
        "notes": null
    },
    "every_war_attacker": {
        "desc": "Iterate through all attackers in the war",
        "usage": "every_war_attacker = { limit = { <triggers> } <effects> }",
        "supported_scopes": "war",
        "supported_targets": "character",
        "notes": null
    },
    "every_war_defender": {
        "desc": "Iterate through all defenders in the war",
        "usage": "every_war_defender = { limit = { <triggers> } <effects> }",
        "supported_scopes": "war",
        "supported_targets": "character",
        "notes": null
    },
    "every_war_participant": {
        "desc": "Iterate through all participants in the war",
        "usage": "every_war_participant = { limit = { <triggers> } <effects> }",
        "supported_scopes": "war",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_war_attacker": {
        "desc": "Iterate through all attackers in the war",
        "usage": "ordered_war_attacker = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "war",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_war_defender": {
        "desc": "Iterate through all defenders in the war",
        "usage": "ordered_war_defender = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "war",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_war_participant": {
        "desc": "Iterate through all participants in the war",
        "usage": "ordered_war_participant = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "war",
        "supported_targets": "character",
        "notes": null
    },
    "random_war_attacker": {
        "desc": "Iterate through all attackers in the war",
        "usage": "random_war_attacker = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "war",
        "supported_targets": "character",
        "notes": null
    },
    "random_war_defender": {
        "desc": "Iterate through all defenders in the war",
        "usage": "random_war_defender = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "war",
        "supported_targets": "character",
        "notes": null
    },
    "random_war_participant": {
        "desc": "Iterate through all participants in the war",
        "usage": "random_war_participant = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "war",
        "supported_targets": "character",
        "notes": null
    },
    "remove_participant": {
        "desc": "removes the target character from the scope war",
        "usage": "",
        "supported_scopes": "war",
        "supported_targets": "character",
        "notes": null
    },
    "set_called_to": {
        "desc": "sets the target character as already called to the scope war",
        "usage": "",
        "supported_scopes": "war",
        "supported_targets": "character",
        "notes": null
    },
    "set_casus_belli": {
        "desc": "sets the casus belli of the scope war",
        "usage": "",
        "supported_scopes": "war",
        "supported_targets": null,
        "notes": null
    },
    "every_leased_title": {
        "desc": "Iterate through all titles leased to a holy order",
        "usage": "every_leased_title = { limit = { <triggers> } <effects> }",
        "supported_scopes": "holy_order",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_leased_title": {
        "desc": "Iterate through all titles leased to a holy order",
        "usage": "ordered_leased_title = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "holy_order",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_leased_title": {
        "desc": "Iterate through all titles leased to a holy order",
        "usage": "random_leased_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "holy_order",
        "supported_targets": "landed_title",
        "notes": null
    },
    "activate_accolade": {
        "desc": "Activates the scoped Accolade, if there are free slots available else it will be deactivated",
        "usage": "activate_accolade = yes",
        "supported_scopes": "accolade",
        "supported_targets": null,
        "notes": null
    },
    "add_glory": {
        "desc": "Add this much to the Accolades glory",
        "usage": "",
        "supported_scopes": "accolade",
        "supported_targets": null,
        "notes": null
    },
    "deactivate_accolade": {
        "desc": "Deactivates the scoped Accolade, does nothing if it's already inactive",
        "usage": "deactivate_accolade = yes",
        "supported_scopes": "accolade",
        "supported_targets": null,
        "notes": null
    },
    "remove_acclaimed_knight": {
        "desc": "Removes the acclaimed knight from this Accolade and passes it onto the successor ( if any )",
        "usage": "remove_acclaimed_knight = yes",
        "supported_scopes": "accolade",
        "supported_targets": null,
        "notes": null
    },
    "every_required_heir_government_type": {
        "desc": "Iterate through all defined required government types for a holding type",
        "usage": "every_required_heir_government_type = { limit = { <triggers> } <effects> }",
        "supported_scopes": "holding_type",
        "supported_targets": "government_type",
        "notes": null
    },
    "ordered_required_heir_government_type": {
        "desc": "Iterate through all defined required government types for a holding type",
        "usage": "ordered_required_heir_government_type = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "holding_type",
        "supported_targets": "government_type",
        "notes": null
    },
    "random_required_heir_government_type": {
        "desc": "Iterate through all defined required government types for a holding type",
        "usage": "random_required_heir_government_type = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "holding_type",
        "supported_targets": "government_type",
        "notes": null
    },
    "add_legend_county_modifier": {
        "desc": "Add a modifier to a legend whose effects should be applied to the county",
        "usage": "add_legend_county_modifier = name\nadd_legend_county_modifier = { modifier = name days/weeks/months/years = int }",
        "supported_scopes": "legend",
        "supported_targets": null,
        "notes": null
    },
    "add_legend_owner_modifier": {
        "desc": "Add a modifier to a legend whose effects should be applied to the owner",
        "usage": "add_legend_owner_modifier = name\nadd_legend_owner_modifier = { modifier = name days/weeks/months/years = int }",
        "supported_scopes": "legend",
        "supported_targets": null,
        "notes": null
    },
    "add_legend_province_modifier": {
        "desc": "Add a modifier to a legend whose effects should be applied to the provinces",
        "usage": "add_legend_province_modifier = name\nadd_legend_province_modifier = { modifier = name days/weeks/months/years = int }",
        "supported_scopes": "legend",
        "supported_targets": null,
        "notes": null
    },
    "clear_legend_chapter": {
        "desc": "Clears the localization key for the named chapter of the scoped legend.",
        "usage": "clear_legend_chapter = opening",
        "supported_scopes": "legend",
        "supported_targets": null,
        "notes": null
    },
    "every_legend_promoter": {
        "desc": "Gets all promoters of the scoped legend",
        "usage": "every_legend_promoter = { limit = { <triggers> } <effects> }",
        "supported_scopes": "legend",
        "supported_targets": "character",
        "notes": null
    },
    "every_spread_province": {
        "desc": "Gets all provinces the scoped legend has spread into",
        "usage": "every_spread_province = { limit = { <triggers> } <effects> }",
        "supported_scopes": "legend",
        "supported_targets": "province",
        "notes": null
    },
    "ordered_legend_promoter": {
        "desc": "Gets all promoters of the scoped legend",
        "usage": "ordered_legend_promoter = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "legend",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_spread_province": {
        "desc": "Gets all provinces the scoped legend has spread into",
        "usage": "ordered_spread_province = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "legend",
        "supported_targets": "province",
        "notes": null
    },
    "random_legend_promoter": {
        "desc": "Gets all promoters of the scoped legend",
        "usage": "random_legend_promoter = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "legend",
        "supported_targets": "character",
        "notes": null
    },
    "random_spread_province": {
        "desc": "Gets all provinces the scoped legend has spread into",
        "usage": "random_spread_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "legend",
        "supported_targets": "province",
        "notes": null
    },
    "remove_all_legend_county_modifier_instances": {
        "desc": "Remove all instances of a modifier from affecting the counties in a legend",
        "usage": "remove_all_legend_county_modifier_instances = name",
        "supported_scopes": "legend",
        "supported_targets": null,
        "notes": null
    },
    "remove_all_legend_owner_modifier_instances": {
        "desc": "Remove all instances of a modifier from affecting the owner of a legend",
        "usage": "remove_all_legend_owner_modifier_instances = name",
        "supported_scopes": "legend",
        "supported_targets": null,
        "notes": null
    },
    "remove_all_legend_province_modifier_instances": {
        "desc": "Remove all instances of a modifier from affecting the provinces in a legend",
        "usage": "remove_all_legend_province_modifier_instances = name",
        "supported_scopes": "legend",
        "supported_targets": null,
        "notes": null
    },
    "remove_legend_county_modifier": {
        "desc": "Remove a modifier from affecting the counties in a legend",
        "usage": "remove_legend_county_modifier = name",
        "supported_scopes": "legend",
        "supported_targets": null,
        "notes": null
    },
    "remove_legend_owner_modifier": {
        "desc": "Remove a modifier from affecting the owner of a legend",
        "usage": "remove_legend_owner_modifier = name",
        "supported_scopes": "legend",
        "supported_targets": null,
        "notes": null
    },
    "remove_legend_province_modifier": {
        "desc": "Remove a modifier from affecting the provinces in a legend",
        "usage": "remove_legend_province_modifier = name",
        "supported_scopes": "legend",
        "supported_targets": null,
        "notes": null
    },
    "set_legend_chapter": {
        "desc": "Sets the localization key for the named chapter of the scoped legend to the new value.",
        "usage": "set_legend_chapter = { name = opening localization_key = <loc_key> }",
        "supported_scopes": "legend",
        "supported_targets": null,
        "notes": null
    },
    "set_legend_property": {
        "desc": "Sets the object at the named property of the scoped legend to the new value.",
        "usage": "set_legend_property = { name = animal_type target = var:hunt_type }",
        "supported_scopes": "legend",
        "supported_targets": null,
        "notes": null
    },
    "set_legend_quality": {
        "desc": "Sets the legend quality to the new value.",
        "usage": "set_legend_quality = famed",
        "supported_scopes": "legend",
        "supported_targets": null,
        "notes": null
    },
    "add_manual_participant": {
        "desc": "add_manual_participant = scope:character",
        "usage": "",
        "supported_scopes": "situation",
        "supported_targets": "character",
        "notes": "Mark a character as a manual participant candidate for the Situation. They will be sorted into the first participant group that is valid for them. If no groups are valid, they will continue to be considered for participation in the future, but not be an actual participant until matched with a group.Use `remove_manual_participant` to remove them from consideration."
    },
    "change_top_phase": {
        "desc": "Change the phase of the top sub-region from the current one to a specific phase",
        "usage": "change_top_phase = my_first_phase\nchange_top_phase = { phase = my_first_phase }",
        "supported_scopes": "situation",
        "supported_targets": null,
        "notes": null
    },
    "end_situation": {
        "desc": "End a situation, end_situation = yes",
        "usage": "",
        "supported_scopes": "situation",
        "supported_targets": null,
        "notes": null
    },
    "every_participant_group": {
        "desc": "Iterate through all participant groups of the situation (in all sub-regions)",
        "usage": "every_participant_group = { limit = { <triggers> } <effects> }",
        "supported_scopes": "situation",
        "supported_targets": "situation_participant_group",
        "notes": null
    },
    "every_situation_county": {
        "desc": "Iterate through all counties that are involved in a situation",
        "usage": "every_situation_county = { limit = { <triggers> } <effects> }",
        "supported_scopes": "situation",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_situation_participant": {
        "desc": "Iterate through all characters that are participating in a situation.",
        "usage": "every_situation_participant = { limit = { <triggers> } <effects> }",
        "supported_scopes": "situation",
        "supported_targets": "character",
        "notes": null
    },
    "every_situation_sub_region": {
        "desc": "Iterate through all sub-regions of a situation",
        "usage": "every_situation_sub_region = { limit = { <triggers> } <effects> }",
        "supported_scopes": "situation",
        "supported_targets": "situation_sub_region",
        "notes": null
    },
    "ordered_participant_group": {
        "desc": "Iterate through all participant groups of the situation (in all sub-regions)",
        "usage": "ordered_participant_group = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "situation",
        "supported_targets": "situation_participant_group",
        "notes": null
    },
    "ordered_situation_county": {
        "desc": "Iterate through all counties that are involved in a situation",
        "usage": "ordered_situation_county = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "situation",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_situation_participant": {
        "desc": "Iterate through all characters that are participating in a situation.",
        "usage": "ordered_situation_participant = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "situation",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_situation_sub_region": {
        "desc": "Iterate through all sub-regions of a situation",
        "usage": "ordered_situation_sub_region = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "situation",
        "supported_targets": "situation_sub_region",
        "notes": null
    },
    "random_participant_group": {
        "desc": "Iterate through all participant groups of the situation (in all sub-regions)",
        "usage": "random_participant_group = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "situation",
        "supported_targets": "situation_participant_group",
        "notes": null
    },
    "random_situation_county": {
        "desc": "Iterate through all counties that are involved in a situation",
        "usage": "random_situation_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "situation",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_situation_participant": {
        "desc": "Iterate through all characters that are participating in a situation.",
        "usage": "random_situation_participant = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "situation",
        "supported_targets": "character",
        "notes": null
    },
    "random_situation_sub_region": {
        "desc": "Iterate through all sub-regions of a situation",
        "usage": "random_situation_sub_region = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "situation",
        "supported_targets": "situation_sub_region",
        "notes": null
    },
    "remove_manual_participant": {
        "desc": "remove_manual_participant = scope:character",
        "usage": "",
        "supported_scopes": "situation",
        "supported_targets": "character",
        "notes": "Remove a manual participant from a situation. They were added before with `add_manual_participant`."
    },
    "trigger_situation_catalyst": {
        "desc": "Trigger a Situation catalyst",
        "usage": "trigger_situation_catalyst = {\ncatalyst = X\n<character = Y>\nsimplified: activate_situation_catalyst = <catalyst_type>\nexample: activate_situation_catalyst = situation_catalyst_type:war_started",
        "supported_scopes": "situation",
        "supported_targets": null,
        "notes": null
    },
    "add_agent_slot": {
        "desc": "Add an agent slot of the specific type to the scoped scheme",
        "usage": "",
        "supported_scopes": "scheme",
        "supported_targets": null,
        "notes": null
    },
    "add_scheme_breach": {
        "desc": "Adds the specified amount of breaches the scoped scheme.",
        "usage": "",
        "supported_scopes": "scheme",
        "supported_targets": null,
        "notes": null
    },
    "add_scheme_modifier": {
        "desc": "adds the specified scheme modifier, add_scheme_modifier = { type = X days = Y } (days are optional, the modifier will expire in Y days if specified)",
        "usage": "",
        "supported_scopes": "scheme",
        "supported_targets": null,
        "notes": null
    },
    "add_scheme_progress": {
        "desc": "Add progress to the scope scheme. (progress is in 0.0 - 100.0 range)",
        "usage": "",
        "supported_scopes": "scheme",
        "supported_targets": null,
        "notes": null
    },
    "change_opportunities": {
        "desc": "Change schemes available opportunities with the given amount.",
        "usage": "",
        "supported_scopes": "scheme",
        "supported_targets": null,
        "notes": null
    },
    "end_scheme": {
        "desc": "Ends a specific scheme and removes it without any other effect",
        "usage": "",
        "supported_scopes": "scheme",
        "supported_targets": null,
        "notes": null
    },
    "every_scheme_agent_character": {
        "desc": "Iterate through all characters in agent slots in the scheme",
        "usage": "every_scheme_agent_character = { limit = { <triggers> } <effects> }",
        "supported_scopes": "scheme",
        "supported_targets": "character",
        "notes": null
    },
    "every_scheme_agent_slot": {
        "desc": "Iterate through all agent slots in the scheme",
        "usage": "every_scheme_agent_slot = { limit = { <triggers> } <effects> }",
        "supported_scopes": "scheme",
        "supported_targets": "agent_slot",
        "notes": null
    },
    "expose_scheme": {
        "desc": "Exposes the scheme to the defender",
        "usage": "",
        "supported_scopes": "scheme",
        "supported_targets": null,
        "notes": null
    },
    "expose_scheme_agent": {
        "desc": "Exposes the target character as an agent of the current scheme",
        "usage": "",
        "supported_scopes": "scheme",
        "supported_targets": "character",
        "notes": null
    },
    "invalidate_scheme": {
        "desc": "Ends a specific scheme and removes it. Also runs on_invalidate effects for the scheme and possible contract.",
        "usage": "",
        "supported_scopes": "scheme",
        "supported_targets": null,
        "notes": null
    },
    "ordered_scheme_agent_character": {
        "desc": "Iterate through all characters in agent slots in the scheme",
        "usage": "ordered_scheme_agent_character = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "scheme",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_scheme_agent_slot": {
        "desc": "Iterate through all agent slots in the scheme",
        "usage": "ordered_scheme_agent_slot = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "scheme",
        "supported_targets": "agent_slot",
        "notes": null
    },
    "random_scheme_agent_character": {
        "desc": "Iterate through all characters in agent slots in the scheme",
        "usage": "random_scheme_agent_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "scheme",
        "supported_targets": "character",
        "notes": null
    },
    "random_scheme_agent_slot": {
        "desc": "Iterate through all agent slots in the scheme",
        "usage": "random_scheme_agent_slot = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "scheme",
        "supported_targets": "agent_slot",
        "notes": null
    },
    "remove_agent_slot": {
        "desc": "Remove the target agent slot from the scoped scheme",
        "usage": "",
        "supported_scopes": "scheme",
        "supported_targets": null,
        "notes": null
    },
    "remove_scheme_modifier": {
        "desc": "removes the specified scheme modifier",
        "usage": "",
        "supported_scopes": "scheme",
        "supported_targets": null,
        "notes": null
    },
    "reset_scheme_progress": {
        "desc": "Resets the scheme's accumulated success chance growth, opportunities, and current phase progress.",
        "usage": "reset_scheme_progress = yes",
        "supported_scopes": "scheme",
        "supported_targets": null,
        "notes": null
    },
    "scheme_freeze": {
        "desc": "scheme_freeze = { reason = LOC_KEY days/months/years = X } freezes the scheme for duration X. 0 duration for indefinite freeze, until scheme_unfreeze is called.",
        "usage": "",
        "supported_scopes": "scheme",
        "supported_targets": null,
        "notes": null
    },
    "scheme_unfreeze": {
        "desc": "scheme_unfreeze = yes Unfreezes the scheme if it's frozen.",
        "usage": "",
        "supported_scopes": "scheme",
        "supported_targets": null,
        "notes": null
    },
    "end_story": {
        "desc": "Ends a story and executes it's on_end effect, the story can no longer be accessed after this",
        "usage": "",
        "supported_scopes": "story",
        "supported_targets": null,
        "notes": null
    },
    "make_story_owner": {
        "desc": "= character_target  makes the character the new owner of the story",
        "usage": "",
        "supported_scopes": "story",
        "supported_targets": "character",
        "notes": null
    },
    "accept_activity_invite": {
        "desc": "accept_activity_invite = activity",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "activity",
        "notes": "The scoped character accepts the invitation to the target activity, using their default travel plan."
    },
    "accept_activity_invite_without_travel": {
        "desc": "accept_activity_invite_without_travel = activity",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "activity",
        "notes": "The scoped character accepts the invitation to the target activity, without adding a travel plan. The character will need to be at the location or they will be kicked out of the activity."
    },
    "accept_task_contract": {
        "desc": "accept_task_contract = TASK_CONTRACT_SCOPE",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "task_contract",
        "notes": null
    },
    "add_amenity_level": {
        "desc": "add_amenity_level = { type = food value = 2 }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": "Increases the amenity type by the given value for the scoped character"
    },
    "add_character_flag": {
        "desc": "adds a character flag",
        "usage": "add_character_flag = X\nadd_character_flag = { flag = X days/weeks/years = Y }",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": "usage:"
    },
    "add_character_modifier": {
        "desc": "Add a modifier to a character",
        "usage": "add_character_modifier = name\nadd_character_modifier = { modifier = name days/weeks/months/years = int }",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "add_contact": {
        "desc": "Add the target character to the scoped character's list of contacts",
        "usage": "add_contact = CHARACTER_SCOPE",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "add_courtier": {
        "desc": "Add the target character to the scope character's court",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "add_dead_character_flag": {
        "desc": "add_dead_character_flag = {",
        "usage": "flag = <name> - name of the flag\nyears/weeks/days = { <min_number> <max_number> } - years/weeks/days this flag is supposed to last",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "add_diplomacy_lifestyle_perk_points": {
        "desc": "Adds lifestyle per points to the given character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "add_diplomacy_lifestyle_xp": {
        "desc": "Adds lifestyle XP to the given character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "add_dread": {
        "desc": "adds (or removes) dread to a character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "add_gold": {
        "desc": "adds gold to a character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "add_hook": {
        "desc": "Adds a hook on a character",
        "usage": "add_hook = { type = X, target = Y, secret = Z, days/months/years = W  }",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "add_hook_no_toast": {
        "desc": "Adds a hook on a character",
        "usage": "add_hook = { type = X, target = Y, secret = Z, days/months/years = W  }",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "add_intrigue_lifestyle_perk_points": {
        "desc": "Adds lifestyle per points to the given character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "add_intrigue_lifestyle_xp": {
        "desc": "Adds lifestyle XP to the given character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "add_joined_faction_discontent": {
        "desc": "add_joined_faction_discontent = X adds (or subtracts) discontent to the factions the scope character is in",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "add_knows_of_killer": {
        "desc": "Adds the right hand side character as knowing of the killer of the scoped object",
        "usage": "dead_person = { add_knows_of_killer = root }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "add_learning_lifestyle_perk_points": {
        "desc": "Adds lifestyle per points to the given character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "add_learning_lifestyle_xp": {
        "desc": "Adds lifestyle XP to the given character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "add_legitimacy": {
        "desc": "Add or remove legitimacy to the scoped living playable character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "add_long_term_gold": {
        "desc": "Add gold to 'long term' AI budget category, respecting maximums, overflow goes into Short Term budget. (gold will be created out of nowhere)character, add_long_term_gold = X",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "add_martial_lifestyle_perk_points": {
        "desc": "Adds lifestyle per points to the given character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "add_martial_lifestyle_xp": {
        "desc": "Adds lifestyle XP to the given character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "add_opinion": {
        "desc": "Adds a temporary opinion modifier, add_opinion = { modifier = X days/months/years = Y target = Z }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": "X is a scripted modifier name. Y can be a value or a range \"{ A B }\" If no timeout are specified, the modifier's scripted default timeout will be used."
    },
    "add_perk": {
        "desc": "Adds the perk for this character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "add_personal_artifact_claim": {
        "desc": "Adds a personal claim on the target artifact to the scoped character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "artifact",
        "notes": null
    },
    "add_piety": {
        "desc": "gives (or takes) piety to a character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "add_piety_experience": {
        "desc": "gives (or takes) piety experience to a character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "add_piety_level": {
        "desc": "increases (or decreases) the piety level of a character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "add_piety_no_experience": {
        "desc": "gives (or takes) piety without experience to a character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "add_pressed_claim": {
        "desc": "gives a pressed claim to a character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "add_prestige": {
        "desc": "gives (or takes) prestige to a character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "add_prestige_experience": {
        "desc": "gives (or takes) prestige experience to a character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "add_prestige_level": {
        "desc": "increases (or decreases) the prestige level of a character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "add_prestige_no_experience": {
        "desc": "gives (or takes) prestige without experience to a character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "add_realm_law": {
        "desc": "Adds the given law to the scoped character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "add_realm_law_skip_effects": {
        "desc": "Adds the given law to the scoped character. Skips the cost and the pass effect, and the revoke effects of the current law",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "add_relation_flag": {
        "desc": "Adds a flag to an existing relation",
        "usage": "add_relation_flag = {\nrelation = scripted_relation\nflag = flag_name (declared in the relation's script)\ntarget = other_character",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "add_reserved_gold": {
        "desc": "Add gold to 'reserved' AI budget category, respecting maximums, overflow goes into Short Term budget. (gold will be created out of nowhere)character, add_reserved_gold = X",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "add_scheme_cooldown": {
        "desc": "Sets a scheme cooldown for the scope character towards = { target=target_character type=scheme_type days/weeks/months/years = duration }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "add_secret": {
        "desc": "Adds a secret",
        "usage": "add_secret = { type = X target = Y }",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "add_short_term_gold": {
        "desc": "Add gold to 'short term' AI budget category, respecting maximums, overflow goes into Short Term budget. (gold will be created out of nowhere)character, add_short_term_gold = X",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "add_stewardship_lifestyle_perk_points": {
        "desc": "Adds lifestyle per points to the given character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "add_stewardship_lifestyle_xp": {
        "desc": "Adds lifestyle XP to the given character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "add_stress": {
        "desc": "increases (or decreases) stress of a character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "add_targeting_factions_discontent": {
        "desc": "add_targeting_factions_discontent = X adds (or subtracts) discontent to all the factions that are targeting the scope character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "add_to_activity": {
        "desc": "add_to_activity = activity",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "activity",
        "notes": "The scoped character is invited to and accepts an invitation to join the target activity, using their default travel plan"
    },
    "add_to_activity_without_travel": {
        "desc": "add_to_activity = activity",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "activity",
        "notes": "The scoped character is invited to and accepts an invitation to join the target activity, without adding a travel plan. The character will need to be at the location or they will be kicked out of the activity."
    },
    "add_to_agent_slot": {
        "desc": "Adds a character to a specific agent slot",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "add_trait": {
        "desc": "Adds a trait to a character (the trait will not be added and no tooltip will be shown if the character isn't eligible for the trait, i.e. when already having the trait, having an opposing trait, not fulfilling the trait's is_potential trigger or being outside of the trait's range)",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "trait",
        "notes": null
    },
    "add_trait_force_tooltip": {
        "desc": "Adds a trait to a character (if the add_trait effect would not add the trait - i.e. when already having the trait, having an opposing trait, not fulfilling the trait's is_potential trigger or being outside of the trait's range - a tooltip will be shown but the trait will not be added)",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "trait",
        "notes": null
    },
    "add_trait_xp": {
        "desc": "Adds XP to the trait level track for the scoped character. Track name is required if the trait has multiple tracks, otherwise should not be provided.",
        "usage": "add_trait_xp = { trait = <trait_key> track = <track_key> value = <script_value> }",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "add_truce_both_ways": {
        "desc": "Sets the both-way truce against the specified character",
        "usage": "add_truce_both_ways = { character = X years/months/days = Y override = yes/no result = victory/defeat/white_peace casus_belli/war = Z }",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": "'character' specifies the target character 'override' says whether it should replace the previous truce even if shorter 'years / months / days' sets the duration of the truce 'result' specifies the result from the scope character's point of view ('white_peace' by default) 'casus_belli' sets the casus belli scope that caused the truce, mutually exclusive with 'name' 'name' sets a custom description. Dynamic description with the current scope 'war' sets the war that caused the truce, mutually exclusive with 'casus_belli'"
    },
    "add_truce_one_way": {
        "desc": "Sets the truce against the specified character",
        "usage": "add_truce_one_way = { character = X years/months/days = Y override = yes/no result = victory/defeat/white_peace casus_belli/war = Z }",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": "'character' specifies the target character 'override' says whether it should replace the previous truce even if shorter 'years / months / days' sets the duration of the truce 'result' specifies the result from the scope character's point of view ('white_peace' by default) 'casus_belli' sets the casus belli scope that caused the truce, mutually exclusive with 'name' 'name' sets a custom description. Dynamic description with the current scope"
    },
    "add_tyranny": {
        "desc": "adds (or removes) tyranny to (or from) a character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "add_unpressed_claim": {
        "desc": "gives an unpressed claim to a character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "add_visiting_courtier": {
        "desc": "Add the target character as the scope character's guest",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "add_wanderer_lifestyle_perk_points": {
        "desc": "Adds lifestyle per points to the given character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "add_wanderer_lifestyle_xp": {
        "desc": "Adds lifestyle XP to the given character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "add_war_chest_gold": {
        "desc": "Add gold to 'war chest' AI budget category, respecting maximums, overflow goes into Short Term budget. (gold will be created out of nowhere)character, add_war_chest_gold = X",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "adopt": {
        "desc": "Set scoped character as parent ot the targetscope:new_parent = { adopt = scope:offspring }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ai_attempt_to_host_activity": {
        "desc": "Force the AI to re-evaluate the given activity type and see if they want to host it. This overrides the ai_check_interval and activity cooldown.",
        "usage": "ai_attempt_to_host_activity = activity_type",
        "supported_scopes": "character",
        "supported_targets": "activity_type",
        "notes": null
    },
    "ai_start_best_war": {
        "desc": "Starts the 'best' AI scored war possible, from the list of filtered possible wars available to the AI character.",
        "usage": "ai_start_best_war  = {\n# Optional list of CBs that the war must have\tcb = { <valid_casus_belli_type1> <valid_casus_belli_type2> }\n# If the cb target data from the AI should be recalculated. Otherwise uses current calculated data. (only use if needed!)   recalculate_cb_targets = no\nis_valid = { ... }\n# Effect called when war was successfully started (scopes are similar to is_valid)\ton_success = { ... }\n# Effect called when no war was found or successfully started\ton_failure = { ... }",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "allow_alliance": {
        "desc": "Allows (previously broken) alliance with the target character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "allow_in_scheme": {
        "desc": "Allow the character to join the scheme as an agent",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "scheme",
        "notes": null
    },
    "apply_ai_vassal_obligation_liege_most_desired": {
        "desc": "Apply the new level for the most desired AI obligation level the liege in the contract wants",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "apply_ai_vassal_obligation_vassal_most_desired": {
        "desc": "Apply the new level for the most desired AI obligation level the vassal in the contract wants",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "appoint_court_position": {
        "desc": "Appoints the target character in target court position within scoped character's court",
        "usage": "recipient = character scope - target character to receive the title\ncourt_position = court position type - court position type to assign the receiver",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "assign_council_task": {
        "desc": "Assigns the target character to the council task",
        "usage": "assign_council_task = {\ncouncil_task = council_task_scope\ntarget = character_taking_the_position    fire_on_actions = [yes]",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "assign_councillor_type": {
        "desc": "Assigns the target character to a council position of a specific type.",
        "usage": "If 'remove_existing_councillor = yes', any existing councillor is removed before assigning. (not fired)\nassign_councillor_type = {\ntype = <council_position_type_key>\ntarget = character_taking_the_position\nfire_on_actions = [yes]\nremove_existing_councillor = [no]",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "banish": {
        "desc": "The character gets banished.",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "becomes_independent": {
        "desc": "becomes and independent ruler. becomes_independent = { change = 'previously created title_and_vassal_change'",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "break_alliance": {
        "desc": "Breaks the alliance with the target character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "cancel_truce_both_ways": {
        "desc": "Ends the truce against the specified character, and theirs against the scoped character. cancel_truce_both_ways = scope:character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "cancel_truce_one_way": {
        "desc": "Ends the truce against the specified character. cancel_truce_one_way = scope:character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "change_age": {
        "desc": "Changes the character's age by the given amount. Sets age to 0 if it'd end up below 0. Note that this will completely bypass birthday on-actions, age-related health, and so on, just like the console command",
        "usage": "Usage: change_age = script value",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "change_current_court_grandeur": {
        "desc": "Changes the current court grandeur of a character with a royal court, clamped between NRoyalCourt::COURT_GRANDEUR_MIN and NRoyalCourt::COURT_GRANDEUR_MAX.",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "change_current_weight": {
        "desc": "Change the current weight of the scoped character",
        "usage": "change_current_weight = 20",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "change_diarchy_swing": {
        "desc": "Change scales of power swing for the active diarchy",
        "usage": "change_diarchy_swing = -5",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "change_first_name": {
        "desc": "Change the first name of a character",
        "usage": "change_first_name = <localization_key>\nchange_first_name = scope:name/var:name # containing a flag with a localization key\nchange_first_name = { template_character = scope:character } # copy name from the template character",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "change_government": {
        "desc": "changes the government type of a ruler",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "change_influence": {
        "desc": "changes influence of a character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "change_influence_experience": {
        "desc": "changes influence experience of a character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "change_influence_level": {
        "desc": "changes the influence level of a character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "change_influence_no_experience": {
        "desc": "changes influence (without experience) of a character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "change_liege": {
        "desc": "= { liege = 'Character that should become the new liege' change = 'previously created title_and_vassal_change', adds a liege change",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "change_prison_type": {
        "desc": "Changes the charater's prison type. Scoped character is the prisoner. Accepts any static modifier (see also improson effect).",
        "usage": "change_prison_type = house_arrest",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "change_strife_opinion": {
        "desc": "Change strife opinion caused by the scoped character",
        "usage": "scope:diarch = { change_strife_opinion = 15 }",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "change_target_weight": {
        "desc": "Change the target weight of the scoped character",
        "usage": "change_target_weight = 20",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "change_trait_rank": {
        "desc": "Changes the trait rank = { trait = trait_group rank = change max = maximum new rank }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "clear_designated_heir": {
        "desc": "Remove any currently set designated heir of a character.",
        "usage": "clear_designated_heir = yes",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "clear_forced_vote": {
        "desc": "Clears forced voting",
        "usage": "clear_forced_vote = yes",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "complete_activity_intent": {
        "desc": "complete_activity_intent = bool",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": "Complete the scoped character's current intent in their involved activity"
    },
    "consume_banish_reasons": {
        "desc": "'Consume' all banish reasons that the scoped character has on the target character. Until they get a new reason, they cannot banish the target again.",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "consume_divorce_reasons": {
        "desc": "'Consume' all divorce reason that the scoped character has on the target character. Until they get a new reason, they cannot divorce the target again.",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "consume_execute_reasons": {
        "desc": "'Consume' all execute reasons that the scoped character has on the target character. Until they get a new reason, they cannot execute the target again.",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "consume_imprisonment_reasons": {
        "desc": "'Consume' all imprisonment reasons that the scoped character has on the target character. Until they get a new reason, they cannot imprison the target again.",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "consume_revoke_title_reason": {
        "desc": "'Consume' 1 revoke title reason that the scoped character has on the target character.",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "copy_inheritable_appearance_from": {
        "desc": "copies the inheritable appearance attributes (inheritable genes in the character's DNA string) from the target character to the scoped character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "copy_localized_text": {
        "desc": "Copies a piece of localized text from the target character for the given key.",
        "usage": "copy_localized_text = { key = key target = character }",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "create_alliance": {
        "desc": "Create an alliance between the scoped character and the target. The allied through characters determine who gets checked against for if the alliance should persist or not.",
        "usage": "create_alliance = {\ntarget = scope\nallied_through_owner = scope\nallied_through_target = scope\ncreate_alliance = scope",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "create_artifact": {
        "desc": "Creates a new artifact and adds it to the inventory of the given character",
        "usage": "name = dynamic description - artifact name\ndescription = dynamic description - artifact description\nrarity = enum - artifact rarity, ex. legendary\ntype = flag - inventory slot type, ex. trinket\nmodifier = static modifier - applied to the character whom wields this artifact\ndurability = script value - new durability, will be max by default\nmax_durability = script value - Optional. A value for the max durability, which would override the one normally assigned by the defines\ndecaying = yes/no - Optional. Set if artifact decays with time. Yes by default\nhistory = artifact history entry - custom history entry to denote for example that this is artifact was reforged by someone else than the owner\ntype = artifact history entry type - available types:\ntemplate = artifact scripted template - a scripted base template with triggers and modifiers\nvisuals = artifact visual type - how this artifact should appear visually\ngenerate_history = bool - automatically generate a new history entry if none has been scripted?\nquality = script value - new quality, used in AI scoring\nwealth = script value - new wealth, used in AI scoring\ncreator = character scope - set a custom creator of the artifact ( default is the owner )\nvisuals_source = scope containing landed title, dynasty or house - set a source of coat of arms graphics for the artifact\nsave_scope_as = new artifact - an optional way to get a reference to the newly created artifact\ntitle_history = title - history entries of the given title will be added to the artifact history\ntitle_history_date = game date - from which date onwards to copy historical entries from given title\ncreator = character scope - set a custom creator of the artifact ( default is the owner )",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": "Be aware that we make use of the current scopes implicitly. This is done in common/artifacts/visuals"
    },
    "create_cadet_branch": {
        "desc": "The scope character creates a cadet branch of the house he is in [yes|no]",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "create_character_memory": {
        "desc": "Creates a memory for the character of a given type and participants plus an optional duration. Saved as scope:new_memory.",
        "usage": "create_character_memory = { type = memory_type participants = { tag = scope } duration = { years = 3 } }",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "create_confederation": {
        "desc": "Creates a confederation and adds the scoped character as a member.",
        "usage": "create_confederation = {\nname = key/dynamic description",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": "The confederation will be saved to scope:new_confederation usage:"
    },
    "create_divergent_culture": {
        "desc": "Creates a new divergent culture from the scope character's culture. The new culture will keep all pillars and traditions of the parent culture — it is up to the user to add or remove pillars and traditions as appropriate.The new divergent culture is saved as scope:new_culture.",
        "usage": "create_divergent_culture = yes",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "create_divergent_culture_with_side_effects": {
        "desc": "Creates a new divergent culture from the scope character's culture. This also incurs the cost, does conversion, and such, just as if you'd diverged via the UI. Unlike create_divergent_culture, it will change ethos and suchThe new culture is NOT saved as a scope due to technical limitations.",
        "usage": "create_divergent_culture_with_side_effects = yes",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "create_divergent_culture_with_side_effects_excluding_cost": {
        "desc": "Creates a new divergent culture from the scope character's culture. Ignores the cost, does conversion, and such, just as if you'd diverged via the UI. Unlike create_divergent_culture, it will change ethos and suchThe new culture is NOT saved as a scope due to technical limitations.",
        "usage": "create_divergent_culture_with_side_effects_excluding_cost = yes",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "create_faction": {
        "desc": "the scoped character creates a faction of the specified type against the specified target, create_faction = { type = X target = Y }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "create_hybrid_culture": {
        "desc": "Creates a new hybrid culture from the scope character's culture and the RHS culture. The new culture will have a random mix of pillars and traditions from both, like when the AI hybridizes. The new hybrid culture is saved as scope:new_culture.",
        "usage": "create_hybrid_culture = culture:anglo-saxon",
        "supported_scopes": "character",
        "supported_targets": "culture",
        "notes": null
    },
    "create_hybrid_culture_with_side_effects": {
        "desc": "Creates a new hybrid culture from the scope character's culture and the RHS culture. The new culture will have a random mix of pillars and traditions from both, like when the AI hybridizes. This also incurs the cost, does conversion, and such, just as if you'd hybridized via the UI. The new hybrid culture is NOT saved as a scope due to technical limitations.",
        "usage": "create_hybrid_culture_with_side_effects = culture:anglo-saxon",
        "supported_scopes": "character",
        "supported_targets": "culture",
        "notes": null
    },
    "create_inspiration": {
        "desc": "create_inspiration = inspiration_type",
        "usage": "create_inspiration = { type = inspiration_type gold = script_value }",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": "Creates an inspiration of a given type owned by scoped character, new inspiration is saved as scope:new_inspiration"
    },
    "create_legend": {
        "desc": "Creates a new legend owned by the scoped character.",
        "usage": "create_legend = {\ntype = heroic\nquality = famed\nchronicle = chronicle_type\nproperties = {\n<key> = scope\n<key> = scope\nprotagonist = character # optional, defaults to scoped character\nsave_scope_as = new_legend # optional",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "create_legend_seed": {
        "desc": "Creates a new legend ssed owned by the scoped character.",
        "usage": "create_legend_seed = {\ntype = heroic\nquality = famed\nchronicle = chronicle_type\nproperties = {\n<key> = scope\n<key> = scope",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "create_maa_regiment": {
        "desc": "Create MaA regiment for a ruler.",
        "usage": "scope:ruler = {\ncreate_maa_regiment = light_footmen\ncreate_maa_regiment = {\ntype = light_footmen          # mutually exclusive with type_of\ntype_of = scope:maa_regiment  # mutually exclusive with type. Take MaA type from the scoped regiment\ncheck_can_recruit = no\ntitle = scope:title\nsize = 5",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": "If title is set, MaA will be created as title troops"
    },
    "create_story": {
        "desc": "creates and initializes a story cycle with the current character as owner",
        "usage": "create_story = story_type\ncreate_story = {\ntype = story_type\nsave_scope_as/save_temporary_scope_as = scope_name # optional way to get a reference to the new story}",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "create_task_contract": {
        "desc": "create_task_contract = {",
        "usage": "task_contract_type = TYPE_NAME\ntask_task_contract_tier = VALUE\nlocation = PROVINCE_SCOPE\ntask_contract_employer = CHARACTER_SCOPE\ndestination = PROVINCE_SCOPE\ntarget = CHARACTER_SCOPE\nsave_scope_as = new_task_contract # optional",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": "#Mandatory parameters"
    },
    "death": {
        "desc": "kills a character, death = { killer = X death_reason = Y artifact = Z }, where X is a character and Y is one of the death reason keys. Optionally artifact Z will be used as the killing artifact instead of the defaulted one from the killer's slot for that death reason's definition. Or death = natural which will pick a natural death reason to kill the character from.",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "decline_activity_invite": {
        "desc": "decline_activity_invite = activity",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "activity",
        "notes": "The scoped character declines the invitation to the target activity"
    },
    "depose": {
        "desc": "The character gets deposed.",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "depose_diarch": {
        "desc": "Current scoped diarch is deposed and replaced with the next from the line of succession",
        "usage": "depose_diarch = yes/no",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "designate_diarch": {
        "desc": "Designated target character as a future diarch",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "destroy_title": {
        "desc": "Destroys a title",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "end_diarchy": {
        "desc": "End diarchy for the character",
        "usage": "end_diarchy = yes/no",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "end_pregnancy": {
        "desc": "end a pregnancy",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "end_tributary": {
        "desc": "Ends the scoped character's current tributary contract.",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "every_acclaimed_knight": {
        "desc": "Iterate through all acclaimed knights employed by a given character",
        "usage": "every_acclaimed_knight = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_accolade": {
        "desc": "Iterate through all ( active and inactive ) Accolades of a given liege character's Acclaimed Knights",
        "usage": "every_accolade = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "accolade",
        "notes": null
    },
    "every_active_accolade": {
        "desc": "Iterate through all active Accolades of a given liege character's Acclaimed Knights",
        "usage": "every_active_accolade = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "accolade",
        "notes": null
    },
    "every_alert_creatable_title": {
        "desc": "Iterate through all titles that can be created by the character. (only for alerts)",
        "usage": "every_alert_creatable_title = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_alert_usurpable_title": {
        "desc": "Iterate through all titles that can be usurped by the character. (only for alerts)",
        "usage": "every_alert_usurpable_title = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_ally": {
        "desc": "Iterate through all allies",
        "usage": "every_ally = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_ancestor": {
        "desc": "Iterate through all the ancestors of the scope character up to 5 generations",
        "usage": "every_ancestor = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_army": {
        "desc": "Iterate through all armies",
        "usage": "every_army = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "army",
        "notes": null
    },
    "every_available_task_contract": {
        "desc": "Iterate through all task contracts of location of root province",
        "usage": "every_available_task_contract = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "task_contract",
        "notes": null
    },
    "every_character_active_contract": {
        "desc": "Gets all accepted task contracts of the root character",
        "usage": "every_character_active_contract = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "task_contract",
        "notes": null
    },
    "every_character_artifact": {
        "desc": "Iterate through all artifacts in a given characters inventory",
        "usage": "every_character_artifact = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "artifact",
        "notes": null
    },
    "every_character_epidemic": {
        "desc": "Gets epidemics affecting the scoped character",
        "usage": "every_character_epidemic = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "epidemic",
        "notes": null
    },
    "every_character_situation": {
        "desc": "Iterate through all situations that a character is participating in",
        "usage": "every_character_situation = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "situation",
        "notes": null
    },
    "every_character_struggle": {
        "desc": "Iterate through all struggles that character is involved in. Optional: Narrow down the involvement status *_chracter_struggle = { involvement = involved | interloper }",
        "usage": "every_character_struggle = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "struggle",
        "notes": null
    },
    "every_character_task_contract": {
        "desc": "Gets all task contracts of the scoped character",
        "usage": "every_character_task_contract = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "task_contract",
        "notes": null
    },
    "every_character_to_title_neighboring_and_across_water_county": {
        "desc": "Scopes from a character to a neighboring county (incl. across water, looking trough the de Jure lieges)",
        "usage": "every_character_to_title_neighboring_and_across_water_county = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_character_to_title_neighboring_and_across_water_duchy": {
        "desc": "Scopes from a character to a neighboring duchy (incl. across water, looking trough the de Jure lieges)",
        "usage": "every_character_to_title_neighboring_and_across_water_duchy = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_character_to_title_neighboring_and_across_water_empire": {
        "desc": "Scopes from a character to a neighboring empire (incl. across water, looking trough the de Jure lieges)",
        "usage": "every_character_to_title_neighboring_and_across_water_empire = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_character_to_title_neighboring_and_across_water_kingdom": {
        "desc": "Scopes from a character to a neighboring kingdom (incl. across water, looking trough the de Jure lieges)",
        "usage": "every_character_to_title_neighboring_and_across_water_kingdom = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_character_to_title_neighboring_county": {
        "desc": "Scopes from a character to a neighboring county (looking trough the de Jure lieges)",
        "usage": "every_character_to_title_neighboring_county = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_character_to_title_neighboring_duchy": {
        "desc": "Scopes from a character to a neighboring duchy (looking trough the de Jure lieges)",
        "usage": "every_character_to_title_neighboring_duchy = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_character_to_title_neighboring_empire": {
        "desc": "Scopes from a character to a neighboring empire (looking trough the de Jure lieges)",
        "usage": "every_character_to_title_neighboring_empire = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_character_to_title_neighboring_kingdom": {
        "desc": "Scopes from a character to a neighboring kingdom (looking trough the de Jure lieges)",
        "usage": "every_character_to_title_neighboring_kingdom = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_character_trait": {
        "desc": "Iterate through all traits a character has",
        "usage": "every_character_trait = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "trait",
        "notes": null
    },
    "every_character_war": {
        "desc": "Wars of the scoped character",
        "usage": "every_character_war = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "war",
        "notes": null
    },
    "every_child": {
        "desc": "Iterate through all children",
        "usage": "every_child = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_claim": {
        "desc": "Iterate through the titles of all claims held by a character; parameters: explicit = yes/no/all pressed = yes/no/all",
        "usage": "every_claim = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_claimed_artifact": {
        "desc": "Iterate through all claimed artifacts of the scoped character",
        "usage": "every_claimed_artifact = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "artifact",
        "notes": null
    },
    "every_close_family_member": {
        "desc": "Iterate through all the close family [father, mother, siblings, children, grandparents]",
        "usage": "every_close_family_member = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_close_or_extended_family_member": {
        "desc": "Iterate through all the close and extended relatives [father, mother, siblings, children, grandparents, uncles/aunts, nephew/niece, cousins]",
        "usage": "every_close_or_extended_family_member = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_concubine": {
        "desc": "Iterate through all concubines",
        "usage": "every_concubine = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_consort": {
        "desc": "Iterate through all consorts (concubines and spouses)",
        "usage": "every_consort = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_contact": {
        "desc": "Iterate through all contact characters of the root character",
        "usage": "every_contact = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_councillor": {
        "desc": "Iterate through all councillors",
        "usage": "every_councillor = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_court_position_candidate": {
        "desc": "Iterate through all valid candidates for a court position type.",
        "usage": "*_court_position_candidate = {\ncourt_position = bodyguard_court_position\ncourt_position = scope:my_scoped_court_position_type\nevery_court_position_candidate = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_court_position_employer": {
        "desc": "Iterates through all characters that employ the scoped character in any court position.",
        "usage": "every_court_position_employer = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_court_position_holder": {
        "desc": "Iterates through all characters employed by the scoped character in the target court position.",
        "usage": "every_court_position_holder = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_courtier": {
        "desc": "Iterate through all courtiers",
        "usage": "every_courtier = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_courtier_away": {
        "desc": "Iterate through all courtiers that are away",
        "usage": "every_courtier_away = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_courtier_or_guest": {
        "desc": "Iterate through all courtiers and guests (pool and foreign court guests)",
        "usage": "every_courtier_or_guest = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_de_jure_claim": {
        "desc": "Iterate through all de jure claims for a character",
        "usage": "every_de_jure_claim = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_diarchy_succession_character": {
        "desc": "Iterate through all character in the diarchy line of succession.If there's no active diarchy or active one doesn't have succession,it iterates over regency candidates",
        "usage": "every_diarchy_succession_character = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_diplomacy_councillor": {
        "desc": "Iterate through all diplomacy-based councillors",
        "usage": "every_diplomacy_councillor = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_directly_owned_province": {
        "desc": "Iterate through all directly owned provinces",
        "usage": "every_directly_owned_province = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "province",
        "notes": null
    },
    "every_election_title": {
        "desc": "Iterate through all titles the scoped character can vote on",
        "usage": "every_election_title = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_equipped_character_artifact": {
        "desc": "Iterate through all equipped artifacts in a given characters inventory",
        "usage": "every_equipped_character_artifact = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "artifact",
        "notes": null
    },
    "every_extended_family_member": {
        "desc": "Iterate through all the extended family [uncles/aunts, nephew/niece, cousins]",
        "usage": "every_extended_family_member = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_foreign_court_guest": {
        "desc": "Iterate through all guests visiting from another court (in contrast to pool_guest they have a liege)",
        "usage": "every_foreign_court_guest = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_former_concubine": {
        "desc": "Iterate through all former concubines. Not persisted past death",
        "usage": "every_former_concubine = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_former_concubinist": {
        "desc": "Iterate through all former concubinists. Not persisted past death",
        "usage": "every_former_concubinist = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_former_spouse": {
        "desc": "Iterate through all former spouses",
        "usage": "every_former_spouse = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_general_councillor": {
        "desc": "Iterate through all councillors that are not related to a skill",
        "usage": "every_general_councillor = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_heir": {
        "desc": "Heirs of the scoped character",
        "usage": "every_heir = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_heir_title": {
        "desc": "Iterate through all titles the scoped character is heir to",
        "usage": "every_heir_title = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_held_title": {
        "desc": "Iterate through all held landed titles",
        "usage": "every_held_title = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_hired_mercenary": {
        "desc": "Iterate through all hired mercenary companies",
        "usage": "every_hired_mercenary = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "mercenary_company",
        "notes": null
    },
    "every_home_court_hostage": {
        "desc": "Iterate through all hostages currently abroad",
        "usage": "every_home_court_hostage = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_hooked_character": {
        "desc": "Iterate through all characters this character has a hook on",
        "usage": "every_hooked_character = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_hostile_raider": {
        "desc": "Iterate through anyone the character is hostile to due to their top-liege's realm having been raided",
        "usage": "every_hostile_raider = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_intrigue_councillor": {
        "desc": "Iterate through all intrigue-based councillors",
        "usage": "every_intrigue_councillor = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_invited_activity": {
        "desc": "Iterate through all activities a character has been invited to",
        "usage": "every_invited_activity = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "activity",
        "notes": null
    },
    "every_knight": {
        "desc": "Iterate through all knights",
        "usage": "every_knight = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_known_secret": {
        "desc": "Iterate through all secrets known by the character",
        "usage": "every_known_secret = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "secret",
        "notes": null
    },
    "every_land_neighboring_realm_with_tributaries": {
        "desc": "A realm with a different top liege neighboring the realm of the scope character's top liege; switches to the realm's top title. Can be based on borders a day or two out of date. Includes land borders extended due to tributaries.",
        "usage": "every_land_neighboring_realm_with_tributaries = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_land_neighboring_realm_with_tributaries_owner": {
        "desc": "A realm with a different top liege neighboring the realm of the scope character's top liege; switches to the holder of the realm. Can be based on borders a day or two out of date. Includes land borders extended due to tributaries.",
        "usage": "every_land_neighboring_realm_with_tributaries_owner = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_learning_councillor": {
        "desc": "Iterate through all learning-based councillors",
        "usage": "every_learning_councillor = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_liege_or_above": {
        "desc": "Iterate through all lieges above a character (skipping the character themselves)",
        "usage": "every_liege_or_above = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_maa_regiment": {
        "desc": "Iterate through all MaA regiments",
        "usage": "every_maa_regiment = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "regiment",
        "notes": null
    },
    "every_martial_councillor": {
        "desc": "Iterate through all martial-based councillors",
        "usage": "every_martial_councillor = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_memory": {
        "desc": "Iterate through all memories of a character",
        "usage": "every_memory = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character_memory",
        "notes": null
    },
    "every_neighboring_and_across_water_realm_same_rank_owner": {
        "desc": "A sub-realm or realm bordering the scope character's realm (including across water) and has the same rank as the scope character (look for lieges of he owner of the land if necessary)",
        "usage": "every_neighboring_and_across_water_realm_same_rank_owner = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_neighboring_and_across_water_top_liege_realm": {
        "desc": "A realm with a different top liege neighboring the realm of the scope character's top liege (including across water); switches to the realm's top title. Can be based on borders a day or two out of date",
        "usage": "every_neighboring_and_across_water_top_liege_realm = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_neighboring_and_across_water_top_liege_realm_owner": {
        "desc": "A realm with a different top liege neighboring the realm of the scope character's top liege (including across water); switches to the holder of the realm. Can be based on borders a day or two out of date",
        "usage": "every_neighboring_and_across_water_top_liege_realm_owner = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_neighboring_and_across_water_top_suzerain_realm": {
        "desc": "A realm with a different top suzerain neighboring the realm of the scope character's top suzerain (including across water); switches to the realm's top title. Can be based on borders a day or two out of date",
        "usage": "every_neighboring_and_across_water_top_suzerain_realm = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_neighboring_and_across_water_top_suzerain_realm_owner": {
        "desc": "A realm with a different top suzerain neighboring the realm of the scope character's top suzerain (including across water); switches to the holder of the realm. Can be based on borders a day or two out of date",
        "usage": "every_neighboring_and_across_water_top_suzerain_realm_owner = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_neighboring_realm_same_rank_owner": {
        "desc": "A sub-realm or realm bordering the scope character's realm and has the same rank as the scope character (look for lieges of he owner of the land if necessary)",
        "usage": "every_neighboring_realm_same_rank_owner = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_neighboring_top_liege_realm": {
        "desc": "A realm with a different top liege neighboring the realm of the scope character's top liege; switches to the realm's top title. Can be based on borders a day or two out of date",
        "usage": "every_neighboring_top_liege_realm = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_neighboring_top_liege_realm_owner": {
        "desc": "A realm with a different top liege neighboring the realm of the scope character's top liege; switches to the holder of the realm. Can be based on borders a day or two out of date",
        "usage": "every_neighboring_top_liege_realm_owner = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_neighboring_top_suzerain_realm": {
        "desc": "A realm with a different top suzerain neighboring the realm of the scope character's top suzerain; switches to the realm's top title. Can be based on borders a day or two out of date",
        "usage": "every_neighboring_top_suzerain_realm = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_neighboring_top_suzerain_realm_owner": {
        "desc": "A realm with a different top suzerain neighboring the realm of the scope character's top suzerain; switches to the holder of the realm. Can be based on borders a day or two out of date",
        "usage": "every_neighboring_top_suzerain_realm_owner = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_noble_family": {
        "desc": "Iterate through all noble family titles in the realm of scoped character",
        "usage": "every_noble_family = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_opposite_sex_spouse_candidate": {
        "desc": "Iterate through all the spouse candidates of the opposite sex of a character.",
        "usage": "every_opposite_sex_spouse_candidate = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": "WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN."
    },
    "every_owned_story": {
        "desc": "Iterate through all owned stories for a character",
        "usage": "every_owned_story = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "story",
        "notes": null
    },
    "every_parent": {
        "desc": "Iterate through all (both) parents",
        "usage": "every_parent = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_patroned_holy_order": {
        "desc": "Iterate through all holy orders that the scoped character is a patron of",
        "usage": "every_patroned_holy_order = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "holy_order",
        "notes": null
    },
    "every_personal_claimed_artifact": {
        "desc": "Iterate through all personally claimed artifacts of the scoped character",
        "usage": "every_personal_claimed_artifact = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "artifact",
        "notes": null
    },
    "every_pinned_character": {
        "desc": "Iterate through characters this player has pinned",
        "usage": "every_pinned_character = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_pinning_character": {
        "desc": "Iterate through characters whose player has this character pinned",
        "usage": "every_pinning_character = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_played_character": {
        "desc": "Iterate through all characters the player playing this character has played. Matches the game over legacy, except for excluding the currently played character",
        "usage": "every_played_character = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_player_heir": {
        "desc": "Iterate through player heirs, capped at the first 10",
        "usage": "every_player_heir = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_player_legend_library": {
        "desc": "Get all legends in a player character library.",
        "usage": "every_player_legend_library = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "legend",
        "notes": null
    },
    "every_pool_guest": {
        "desc": "Iterate through all guests visiting the court from the pool (in contrast to foreign_court_guest they don't have a liege)",
        "usage": "every_pool_guest = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_potential_marriage_option": {
        "desc": "Iterate through all potential selectable marriage or betrohed options",
        "usage": "every_potential_marriage_option = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_powerful_family": {
        "desc": "Iterate through all directly owned provinces",
        "usage": "every_powerful_family = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "dynasty_house",
        "notes": null
    },
    "every_powerful_vassal": {
        "desc": "Iterate through the all powerful vassals of a character",
        "usage": "every_powerful_vassal = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_pretender_title": {
        "desc": "Iterate through all landed titles character is pretender to",
        "usage": "every_pretender_title = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_primary_war_enemy": {
        "desc": "Iterate through all primary war enemies",
        "usage": "every_primary_war_enemy = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_prisoner": {
        "desc": "Iterate through all prisoners",
        "usage": "every_prisoner = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_prowess_councillor": {
        "desc": "Iterate through all prowess-based councillors",
        "usage": "every_prowess_councillor = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_raid_target": {
        "desc": "Iterate through anyone the character is hostile to due to having raided them. Only returns top lieges",
        "usage": "every_raid_target = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_realm_border_county": {
        "desc": "Iterate through all counties that are on the edge of your realm bordering a different neighboring realm.",
        "usage": "every_realm_border_county = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_realm_county": {
        "desc": "Iterate through all counties in the realm. Based on top liege",
        "usage": "every_realm_county = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_realm_de_jure_duchy": {
        "desc": "Iterate through all de jure duchies that have at least one county in the realm. Based on top liege",
        "usage": "every_realm_de_jure_duchy = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_realm_de_jure_empire": {
        "desc": "Iterate through all de jure empire that have at least one county in the realm. Based on top liege",
        "usage": "every_realm_de_jure_empire = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_realm_de_jure_kingdom": {
        "desc": "Iterate through all de jure kingdom that have at least one county in the realm. Based on top liege",
        "usage": "every_realm_de_jure_kingdom = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_realm_province": {
        "desc": "Iterate through all realm provinces of a character",
        "usage": "every_realm_province = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "province",
        "notes": null
    },
    "every_relation": {
        "desc": "Iterate through scripted relations of a given type or multiple types, if someone is multiple relations they will only be in the list once",
        "usage": "every_relation = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_same_sex_spouse_candidate": {
        "desc": "Iterate through all the spouse candidates of the same sex of a character.",
        "usage": "every_same_sex_spouse_candidate = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": "WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN."
    },
    "every_scheme": {
        "desc": "Iterate through all schemes owned by the character",
        "usage": "every_scheme = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "scheme",
        "notes": null
    },
    "every_secret": {
        "desc": "Iterate through all secrets of the character",
        "usage": "every_secret = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "secret",
        "notes": null
    },
    "every_sibling": {
        "desc": "Iterate through all siblings",
        "usage": "every_sibling = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_sponsored_inspiration": {
        "desc": "Iterate through all sponsored inspirations",
        "usage": "every_sponsored_inspiration = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "inspiration",
        "notes": null
    },
    "every_spouse": {
        "desc": "Iterate through all spouses",
        "usage": "every_spouse = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_spouse_candidate": {
        "desc": "Iterate through all the spouse candidates of a character.",
        "usage": "every_spouse_candidate = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": "WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN."
    },
    "every_stewardship_councillor": {
        "desc": "Iterate through all stewardship-based councillors",
        "usage": "every_stewardship_councillor = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_sub_realm_barony": {
        "desc": "Iterate through all baronies in sub-realm",
        "usage": "every_sub_realm_barony = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_sub_realm_county": {
        "desc": "Iterate through all counties in sub-realm",
        "usage": "every_sub_realm_county = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_sub_realm_duchy": {
        "desc": "Iterate through all duchies in sub-realm",
        "usage": "every_sub_realm_duchy = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_sub_realm_empire": {
        "desc": "Iterate through all empires in sub-realm",
        "usage": "every_sub_realm_empire = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_sub_realm_kingdom": {
        "desc": "Iterate through all kingdoms in sub-realm",
        "usage": "every_sub_realm_kingdom = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_sub_realm_title": {
        "desc": "Iterate through all titles in sub-realm",
        "usage": "every_sub_realm_title = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_succession_appointment_invested_candidate": {
        "desc": "Iterate through all candidates supported by the scoped investor character for any title",
        "usage": "every_succession_appointment_invested_candidate = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": "It may contain people outside of investor's top realm or no longer valid for appointment"
    },
    "every_succession_appointment_invested_title": {
        "desc": "Iterate through all titles that has candidates supported by the scoped investor",
        "usage": "every_succession_appointment_invested_title = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": "It may contain titles outside of investor's top realm, and so invalid for appointment, and candidates may be already dead"
    },
    "every_targeting_faction": {
        "desc": "Iterate through all factions targeting the scope character",
        "usage": "every_targeting_faction = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "faction",
        "notes": null
    },
    "every_targeting_scheme": {
        "desc": "Iterate through all schemes targeting the character",
        "usage": "every_targeting_scheme = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "scheme",
        "notes": null
    },
    "every_targeting_secret": {
        "desc": "Iterate through all secrets that target the specified scope",
        "usage": "every_targeting_secret = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "secret",
        "notes": null
    },
    "every_tax_collector": {
        "desc": "Iterates through all Tax Collectors employed by the scoped character",
        "usage": "every_tax_collector = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_tax_collector_vassal": {
        "desc": "Iterates through all Vassals the scoped Character is the Tax Collector for",
        "usage": "every_tax_collector_vassal = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_tax_slot": {
        "desc": "Iterates through all Tax Slots the scoped character has",
        "usage": "every_tax_slot = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "tax_slot",
        "notes": null
    },
    "every_top_realm_border_county": {
        "desc": "Iterate through all counties that are on the edge of your realm bordering a different neighboring top realm.",
        "usage": "every_top_realm_border_county = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_traveling_family_member": {
        "desc": "Iterate though all characters that should travel with the scoped one (when moving between courts for instance); includes the scoped character",
        "usage": "every_traveling_family_member = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_tributary": {
        "desc": "Iterate through all tributaries",
        "usage": "every_tributary = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_truce_holder": {
        "desc": "Iterate through all characters that have a truce on this character",
        "usage": "every_truce_holder = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_truce_target": {
        "desc": "Iterate through all characters this character has a truce on",
        "usage": "every_truce_target = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_unassigned_taxpayers": {
        "desc": "Iterates through all unassigned taxpayers for scoped Character",
        "usage": "every_unassigned_taxpayers = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_unspent_known_secret": {
        "desc": "Iterate through all unspent secrets known by the character",
        "usage": "every_unspent_known_secret = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "secret",
        "notes": null
    },
    "every_vassal": {
        "desc": "Iterate through all DIRECT vassals",
        "usage": "every_vassal = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_vassal_or_below": {
        "desc": "Iterate through ALL vassals, not just direct vassals",
        "usage": "every_vassal_or_below = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_war_ally": {
        "desc": "Iterate through all direct war allies",
        "usage": "every_war_ally = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_war_enemy": {
        "desc": "Iterate through all direct war enemies",
        "usage": "every_war_enemy = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_warden_hostage": {
        "desc": "Iterate through all hostages having this warden",
        "usage": "every_warden_hostage = { limit = { <triggers> } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "execute_decision": {
        "desc": "Execute the specified decision for the scoped character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "decision",
        "notes": null
    },
    "finish_council_task": {
        "desc": "The councillor finish the current assigned task successfully.",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "fire_councillor": {
        "desc": "The scope character fires the target character from the council.",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "fire_councillor_skip_effects": {
        "desc": "The scope character fires the target character from the council without running on_actions.",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "fire_tax_collector": {
        "desc": "The scoped character fires the target character.",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "forbid_from_scheme": {
        "desc": "Forbid the scope character from joining the target scheme as an agent (and kick the character out if already in the scheme)",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "scheme",
        "notes": null
    },
    "force_add_to_agent_slot": {
        "desc": "Adds a character as an agent to a scheme agent slot and forces them to stay",
        "usage": "agent_slot = target_Slot\ndays/months/years = duration",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": "{"
    },
    "force_character_skill_recalculation": {
        "desc": "Forces a character's skills to be recalculated immediately, bypassing the wait for the daily tick.",
        "usage": "Usage: force_character_skill_recalculation = yes/no",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": "NOTE: Only use this when *absolutely* necessary, as it will impact performance negatively if misused"
    },
    "force_step_down_landed_titles": {
        "desc": "Make ruler step down - less harsh than abdicate or depose.",
        "usage": "scope:ruler = {\nforce_step_down_landed_titles = yes",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": "If ruler has any title that allows them to remain landless playable, then pass all landed titles to heirs - counties and any higher tier title with dejure land. Keep all titular titles. If no such title exists, then it works identical to depose"
    },
    "force_vote_as": {
        "desc": "Forces the character to vote the same as the target",
        "usage": "force_vote_as = { target = someone days/months/years = x }",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "get_title": {
        "desc": "gives a title to a character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "give_domain_to_herders": {
        "desc": "Give each county in the scoped character's domain to herders and destroy all held duchy titles and above.",
        "usage": "give_domain_to_herds = yes",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "give_nickname": {
        "desc": "Give a nickname to this character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "give_noble_family_title": {
        "desc": "Give a noble family title to the <root> character.",
        "usage": "give_noble_family_title = {\nname = key/dynamic description\ngovernment = administrative_government # optional government, default is administrative\nsave_scope_as = <name>",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": "usage:"
    },
    "imprison": {
        "desc": "Imprisons the target character as this character's prisoner, imprison = { target = X reason = Y type = Z }, where X is a character, Y is a flag, Z is a static modifier",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "infect_with_epidemic": {
        "desc": "Infect the scoped character with the target epidemic.",
        "usage": "infect_with_epidemic = epidemic",
        "supported_scopes": "character",
        "supported_targets": "epidemic",
        "notes": null
    },
    "invalidate_diarch_if_needed": {
        "desc": "Immediately check if diarch should be invalidated",
        "usage": "scope:diarch = { invalidate_diarch_if_needed = yes/no }",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": "If needed, current scoped diarch is removed and replaced with the next one from the line of succession"
    },
    "invite_to_activity": {
        "desc": "invite_to_activity = activity",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "activity",
        "notes": "The scoped character is invited to the target activity"
    },
    "join_faction": {
        "desc": "the character in the scope joins the assigned faction",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "faction",
        "notes": null
    },
    "join_faction_forced": {
        "desc": "the character in the scope is forced to join a faction by a character for a defined time,",
        "usage": "join_faction_forced = {\nfaction = X\nforced_by = Y\ndays/months/years = duration",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "join_faction_skip_check": {
        "desc": "the character in the scope joins the assigned faction skiping the can_character_join trigger",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "faction",
        "notes": null
    },
    "learn_court_language_of": {
        "desc": "The character learns the court language of the target characterlearn_court_language_of = scope:target_character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "learn_language": {
        "desc": "The character learns the languagelearn_language = language_norwegian",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "learn_language_of_culture": {
        "desc": "The character learns the language of the target culturelearn_language_of_culture = scope:target_culture",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "culture",
        "notes": null
    },
    "leave_faction": {
        "desc": "the charcter in the scope leaves the assigned faction",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "faction",
        "notes": null
    },
    "make_claim_strong": {
        "desc": "makes a claim strong (character adds the claim if not having it already)",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "make_claim_weak": {
        "desc": "makes a claim weak (character adds the claim if not having it already)",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "make_concubine": {
        "desc": "Makes the target character a concubine of the scope character, the target should not be imprisoned",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "make_pregnant": {
        "desc": "makes a character pregnant",
        "usage": "father= 'the real father'\nnumber_of_children= X\nknown_bastard=yes/no",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "make_pregnant_no_checks": {
        "desc": "makes a character pregnant. Doesn't error on things like celibacy",
        "usage": "father= 'the real father'\nnumber_of_children= X\nknown_bastard=yes/no",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "make_trait_active": {
        "desc": "Activates an inactive trait. Tooltip will not be shown if the character cannot have the trait.",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "trait",
        "notes": null
    },
    "make_trait_active_force_tooltip": {
        "desc": "Activates an inactive trait. Tooltip will be shown even if the character cannot have the trait.",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "trait",
        "notes": null
    },
    "make_trait_inactive": {
        "desc": "Makes a current trait of a character inactive. Tooltip will not be shown if the character doesn't have the trait.",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "trait",
        "notes": null
    },
    "make_trait_inactive_force_tooltip": {
        "desc": "Makes a current trait of a character inactive. Tooltip will be shown even if the character doesn't have the trait.",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "trait",
        "notes": null
    },
    "make_unprunable": {
        "desc": "The scope character will no longer be prunable after their death. Use with care, as this will make everyone related to them unprunable too. So you should only use this if someone absolutely *needs* to stick around several years after their death. Example: make_unprunable = yes",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "marry": {
        "desc": "Marries the scoped character to the target character.",
        "usage": "marry = target",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "marry_matrilineal": {
        "desc": "Marries the scoped character to the target character matrilineally.",
        "usage": "marry_matrilineal = target",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "move_budget_gold": {
        "desc": "Move gold from one AI budget category to the other, will not move more than is available in the source budget or what can fit in the target budget.character, move_budget_gold = { gold = X from = Z to = Y }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": "('budget_war_chest', 'budget_reserved', 'budget_short_term', 'budget_long_term')"
    },
    "move_to_pool": {
        "desc": "The scoped character (courtier or guest) leaves their current court and moves into the pool",
        "usage": "scope:guest = { move_to_pool = yes }",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "move_to_pool_at": {
        "desc": "The scoped character (courtier/guest/pool character) leaves their current court (if any) and moves into the pool of the specified province",
        "usage": "scope:guest = { move_to_pool_at = scope:some_province }",
        "supported_scopes": "character",
        "supported_targets": "province",
        "notes": null
    },
    "open_appoint_court_position_window": {
        "desc": "Opens the appointment window for the specified court position with scoped character as liege",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "ordered_acclaimed_knight": {
        "desc": "Iterate through all acclaimed knights employed by a given character",
        "usage": "ordered_acclaimed_knight = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_accolade": {
        "desc": "Iterate through all ( active and inactive ) Accolades of a given liege character's Acclaimed Knights",
        "usage": "ordered_accolade = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "accolade",
        "notes": null
    },
    "ordered_active_accolade": {
        "desc": "Iterate through all active Accolades of a given liege character's Acclaimed Knights",
        "usage": "ordered_active_accolade = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "accolade",
        "notes": null
    },
    "ordered_alert_creatable_title": {
        "desc": "Iterate through all titles that can be created by the character. (only for alerts)",
        "usage": "ordered_alert_creatable_title = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_alert_usurpable_title": {
        "desc": "Iterate through all titles that can be usurped by the character. (only for alerts)",
        "usage": "ordered_alert_usurpable_title = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_ally": {
        "desc": "Iterate through all allies",
        "usage": "ordered_ally = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_ancestor": {
        "desc": "Iterate through all the ancestors of the scope character up to 5 generations",
        "usage": "ordered_ancestor = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_army": {
        "desc": "Iterate through all armies",
        "usage": "ordered_army = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "army",
        "notes": null
    },
    "ordered_available_task_contract": {
        "desc": "Iterate through all task contracts of location of root province",
        "usage": "ordered_available_task_contract = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "task_contract",
        "notes": null
    },
    "ordered_character_active_contract": {
        "desc": "Gets all accepted task contracts of the root character",
        "usage": "ordered_character_active_contract = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "task_contract",
        "notes": null
    },
    "ordered_character_artifact": {
        "desc": "Iterate through all artifacts in a given characters inventory",
        "usage": "ordered_character_artifact = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "artifact",
        "notes": null
    },
    "ordered_character_epidemic": {
        "desc": "Gets epidemics affecting the scoped character",
        "usage": "ordered_character_epidemic = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "epidemic",
        "notes": null
    },
    "ordered_character_situation": {
        "desc": "Iterate through all situations that a character is participating in",
        "usage": "ordered_character_situation = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "situation",
        "notes": null
    },
    "ordered_character_struggle": {
        "desc": "Iterate through all struggles that character is involved in. Optional: Narrow down the involvement status *_chracter_struggle = { involvement = involved | interloper }",
        "usage": "ordered_character_struggle = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "struggle",
        "notes": null
    },
    "ordered_character_task_contract": {
        "desc": "Gets all task contracts of the scoped character",
        "usage": "ordered_character_task_contract = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "task_contract",
        "notes": null
    },
    "ordered_character_to_title_neighboring_and_across_water_county": {
        "desc": "Scopes from a character to a neighboring county (incl. across water, looking trough the de Jure lieges)",
        "usage": "ordered_character_to_title_neighboring_and_across_water_county = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_character_to_title_neighboring_and_across_water_duchy": {
        "desc": "Scopes from a character to a neighboring duchy (incl. across water, looking trough the de Jure lieges)",
        "usage": "ordered_character_to_title_neighboring_and_across_water_duchy = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_character_to_title_neighboring_and_across_water_empire": {
        "desc": "Scopes from a character to a neighboring empire (incl. across water, looking trough the de Jure lieges)",
        "usage": "ordered_character_to_title_neighboring_and_across_water_empire = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_character_to_title_neighboring_and_across_water_kingdom": {
        "desc": "Scopes from a character to a neighboring kingdom (incl. across water, looking trough the de Jure lieges)",
        "usage": "ordered_character_to_title_neighboring_and_across_water_kingdom = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_character_to_title_neighboring_county": {
        "desc": "Scopes from a character to a neighboring county (looking trough the de Jure lieges)",
        "usage": "ordered_character_to_title_neighboring_county = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_character_to_title_neighboring_duchy": {
        "desc": "Scopes from a character to a neighboring duchy (looking trough the de Jure lieges)",
        "usage": "ordered_character_to_title_neighboring_duchy = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_character_to_title_neighboring_empire": {
        "desc": "Scopes from a character to a neighboring empire (looking trough the de Jure lieges)",
        "usage": "ordered_character_to_title_neighboring_empire = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_character_to_title_neighboring_kingdom": {
        "desc": "Scopes from a character to a neighboring kingdom (looking trough the de Jure lieges)",
        "usage": "ordered_character_to_title_neighboring_kingdom = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_character_trait": {
        "desc": "Iterate through all traits a character has",
        "usage": "ordered_character_trait = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "trait",
        "notes": null
    },
    "ordered_character_war": {
        "desc": "Wars of the scoped character",
        "usage": "ordered_character_war = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "war",
        "notes": null
    },
    "ordered_child": {
        "desc": "Iterate through all children",
        "usage": "ordered_child = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_claim": {
        "desc": "Iterate through the titles of all claims held by a character; parameters: explicit = yes/no/all pressed = yes/no/all",
        "usage": "ordered_claim = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_claimed_artifact": {
        "desc": "Iterate through all claimed artifacts of the scoped character",
        "usage": "ordered_claimed_artifact = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "artifact",
        "notes": null
    },
    "ordered_close_family_member": {
        "desc": "Iterate through all the close family [father, mother, siblings, children, grandparents]",
        "usage": "ordered_close_family_member = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_close_or_extended_family_member": {
        "desc": "Iterate through all the close and extended relatives [father, mother, siblings, children, grandparents, uncles/aunts, nephew/niece, cousins]",
        "usage": "ordered_close_or_extended_family_member = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_concubine": {
        "desc": "Iterate through all concubines",
        "usage": "ordered_concubine = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_consort": {
        "desc": "Iterate through all consorts (concubines and spouses)",
        "usage": "ordered_consort = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_contact": {
        "desc": "Iterate through all contact characters of the root character",
        "usage": "ordered_contact = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_councillor": {
        "desc": "Iterate through all councillors",
        "usage": "ordered_councillor = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_court_position_candidate": {
        "desc": "Iterate through all valid candidates for a court position type.",
        "usage": "*_court_position_candidate = {\ncourt_position = bodyguard_court_position\ncourt_position = scope:my_scoped_court_position_type\nordered_court_position_candidate = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_court_position_employer": {
        "desc": "Iterates through all characters that employ the scoped character in any court position.",
        "usage": "ordered_court_position_employer = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_court_position_holder": {
        "desc": "Iterates through all characters employed by the scoped character in the target court position.",
        "usage": "ordered_court_position_holder = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_courtier": {
        "desc": "Iterate through all courtiers",
        "usage": "ordered_courtier = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_courtier_away": {
        "desc": "Iterate through all courtiers that are away",
        "usage": "ordered_courtier_away = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_courtier_or_guest": {
        "desc": "Iterate through all courtiers and guests (pool and foreign court guests)",
        "usage": "ordered_courtier_or_guest = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_de_jure_claim": {
        "desc": "Iterate through all de jure claims for a character",
        "usage": "ordered_de_jure_claim = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_diarchy_succession_character": {
        "desc": "Iterate through all character in the diarchy line of succession.If there's no active diarchy or active one doesn't have succession,it iterates over regency candidates",
        "usage": "ordered_diarchy_succession_character = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_diplomacy_councillor": {
        "desc": "Iterate through all diplomacy-based councillors",
        "usage": "ordered_diplomacy_councillor = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_directly_owned_province": {
        "desc": "Iterate through all directly owned provinces",
        "usage": "ordered_directly_owned_province = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "province",
        "notes": null
    },
    "ordered_election_title": {
        "desc": "Iterate through all titles the scoped character can vote on",
        "usage": "ordered_election_title = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_equipped_character_artifact": {
        "desc": "Iterate through all equipped artifacts in a given characters inventory",
        "usage": "ordered_equipped_character_artifact = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "artifact",
        "notes": null
    },
    "ordered_extended_family_member": {
        "desc": "Iterate through all the extended family [uncles/aunts, nephew/niece, cousins]",
        "usage": "ordered_extended_family_member = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_foreign_court_guest": {
        "desc": "Iterate through all guests visiting from another court (in contrast to pool_guest they have a liege)",
        "usage": "ordered_foreign_court_guest = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_former_concubine": {
        "desc": "Iterate through all former concubines. Not persisted past death",
        "usage": "ordered_former_concubine = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_former_concubinist": {
        "desc": "Iterate through all former concubinists. Not persisted past death",
        "usage": "ordered_former_concubinist = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_former_spouse": {
        "desc": "Iterate through all former spouses",
        "usage": "ordered_former_spouse = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_general_councillor": {
        "desc": "Iterate through all councillors that are not related to a skill",
        "usage": "ordered_general_councillor = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_heir": {
        "desc": "Heirs of the scoped character",
        "usage": "ordered_heir = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_heir_title": {
        "desc": "Iterate through all titles the scoped character is heir to",
        "usage": "ordered_heir_title = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_held_title": {
        "desc": "Iterate through all held landed titles",
        "usage": "ordered_held_title = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_hired_mercenary": {
        "desc": "Iterate through all hired mercenary companies",
        "usage": "ordered_hired_mercenary = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "mercenary_company",
        "notes": null
    },
    "ordered_home_court_hostage": {
        "desc": "Iterate through all hostages currently abroad",
        "usage": "ordered_home_court_hostage = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_hooked_character": {
        "desc": "Iterate through all characters this character has a hook on",
        "usage": "ordered_hooked_character = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_hostile_raider": {
        "desc": "Iterate through anyone the character is hostile to due to their top-liege's realm having been raided",
        "usage": "ordered_hostile_raider = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_intrigue_councillor": {
        "desc": "Iterate through all intrigue-based councillors",
        "usage": "ordered_intrigue_councillor = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_invited_activity": {
        "desc": "Iterate through all activities a character has been invited to",
        "usage": "ordered_invited_activity = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "activity",
        "notes": null
    },
    "ordered_knight": {
        "desc": "Iterate through all knights",
        "usage": "ordered_knight = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_known_secret": {
        "desc": "Iterate through all secrets known by the character",
        "usage": "ordered_known_secret = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "secret",
        "notes": null
    },
    "ordered_land_neighboring_realm_with_tributaries": {
        "desc": "A realm with a different top liege neighboring the realm of the scope character's top liege; switches to the realm's top title. Can be based on borders a day or two out of date. Includes land borders extended due to tributaries.",
        "usage": "ordered_land_neighboring_realm_with_tributaries = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_land_neighboring_realm_with_tributaries_owner": {
        "desc": "A realm with a different top liege neighboring the realm of the scope character's top liege; switches to the holder of the realm. Can be based on borders a day or two out of date. Includes land borders extended due to tributaries.",
        "usage": "ordered_land_neighboring_realm_with_tributaries_owner = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_learning_councillor": {
        "desc": "Iterate through all learning-based councillors",
        "usage": "ordered_learning_councillor = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_liege_or_above": {
        "desc": "Iterate through all lieges above a character (skipping the character themselves)",
        "usage": "ordered_liege_or_above = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_maa_regiment": {
        "desc": "Iterate through all MaA regiments",
        "usage": "ordered_maa_regiment = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "regiment",
        "notes": null
    },
    "ordered_martial_councillor": {
        "desc": "Iterate through all martial-based councillors",
        "usage": "ordered_martial_councillor = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_memory": {
        "desc": "Iterate through all memories of a character",
        "usage": "ordered_memory = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character_memory",
        "notes": null
    },
    "ordered_neighboring_and_across_water_realm_same_rank_owner": {
        "desc": "A sub-realm or realm bordering the scope character's realm (including across water) and has the same rank as the scope character (look for lieges of he owner of the land if necessary)",
        "usage": "ordered_neighboring_and_across_water_realm_same_rank_owner = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_neighboring_and_across_water_top_liege_realm": {
        "desc": "A realm with a different top liege neighboring the realm of the scope character's top liege (including across water); switches to the realm's top title. Can be based on borders a day or two out of date",
        "usage": "ordered_neighboring_and_across_water_top_liege_realm = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_neighboring_and_across_water_top_liege_realm_owner": {
        "desc": "A realm with a different top liege neighboring the realm of the scope character's top liege (including across water); switches to the holder of the realm. Can be based on borders a day or two out of date",
        "usage": "ordered_neighboring_and_across_water_top_liege_realm_owner = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_neighboring_and_across_water_top_suzerain_realm": {
        "desc": "A realm with a different top suzerain neighboring the realm of the scope character's top suzerain (including across water); switches to the realm's top title. Can be based on borders a day or two out of date",
        "usage": "ordered_neighboring_and_across_water_top_suzerain_realm = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_neighboring_and_across_water_top_suzerain_realm_owner": {
        "desc": "A realm with a different top suzerain neighboring the realm of the scope character's top suzerain (including across water); switches to the holder of the realm. Can be based on borders a day or two out of date",
        "usage": "ordered_neighboring_and_across_water_top_suzerain_realm_owner = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_neighboring_realm_same_rank_owner": {
        "desc": "A sub-realm or realm bordering the scope character's realm and has the same rank as the scope character (look for lieges of he owner of the land if necessary)",
        "usage": "ordered_neighboring_realm_same_rank_owner = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_neighboring_top_liege_realm": {
        "desc": "A realm with a different top liege neighboring the realm of the scope character's top liege; switches to the realm's top title. Can be based on borders a day or two out of date",
        "usage": "ordered_neighboring_top_liege_realm = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_neighboring_top_liege_realm_owner": {
        "desc": "A realm with a different top liege neighboring the realm of the scope character's top liege; switches to the holder of the realm. Can be based on borders a day or two out of date",
        "usage": "ordered_neighboring_top_liege_realm_owner = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_neighboring_top_suzerain_realm": {
        "desc": "A realm with a different top suzerain neighboring the realm of the scope character's top suzerain; switches to the realm's top title. Can be based on borders a day or two out of date",
        "usage": "ordered_neighboring_top_suzerain_realm = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_neighboring_top_suzerain_realm_owner": {
        "desc": "A realm with a different top suzerain neighboring the realm of the scope character's top suzerain; switches to the holder of the realm. Can be based on borders a day or two out of date",
        "usage": "ordered_neighboring_top_suzerain_realm_owner = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_noble_family": {
        "desc": "Iterate through all noble family titles in the realm of scoped character",
        "usage": "ordered_noble_family = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_opposite_sex_spouse_candidate": {
        "desc": "Iterate through all the spouse candidates of the opposite sex of a character.",
        "usage": "ordered_opposite_sex_spouse_candidate = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": "WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN."
    },
    "ordered_owned_story": {
        "desc": "Iterate through all owned stories for a character",
        "usage": "ordered_owned_story = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "story",
        "notes": null
    },
    "ordered_parent": {
        "desc": "Iterate through all (both) parents",
        "usage": "ordered_parent = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_patroned_holy_order": {
        "desc": "Iterate through all holy orders that the scoped character is a patron of",
        "usage": "ordered_patroned_holy_order = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "holy_order",
        "notes": null
    },
    "ordered_personal_claimed_artifact": {
        "desc": "Iterate through all personally claimed artifacts of the scoped character",
        "usage": "ordered_personal_claimed_artifact = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "artifact",
        "notes": null
    },
    "ordered_pinned_character": {
        "desc": "Iterate through characters this player has pinned",
        "usage": "ordered_pinned_character = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_pinning_character": {
        "desc": "Iterate through characters whose player has this character pinned",
        "usage": "ordered_pinning_character = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_played_character": {
        "desc": "Iterate through all characters the player playing this character has played. Matches the game over legacy, except for excluding the currently played character",
        "usage": "ordered_played_character = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_player_heir": {
        "desc": "Iterate through player heirs, capped at the first 10",
        "usage": "ordered_player_heir = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_player_legend_library": {
        "desc": "Get all legends in a player character library.",
        "usage": "ordered_player_legend_library = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "legend",
        "notes": null
    },
    "ordered_pool_guest": {
        "desc": "Iterate through all guests visiting the court from the pool (in contrast to foreign_court_guest they don't have a liege)",
        "usage": "ordered_pool_guest = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_potential_marriage_option": {
        "desc": "Iterate through all potential selectable marriage or betrohed options",
        "usage": "ordered_potential_marriage_option = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_powerful_family": {
        "desc": "Iterate through all directly owned provinces",
        "usage": "ordered_powerful_family = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "dynasty_house",
        "notes": null
    },
    "ordered_powerful_vassal": {
        "desc": "Iterate through the all powerful vassals of a character",
        "usage": "ordered_powerful_vassal = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_pretender_title": {
        "desc": "Iterate through all landed titles character is pretender to",
        "usage": "ordered_pretender_title = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_primary_war_enemy": {
        "desc": "Iterate through all primary war enemies",
        "usage": "ordered_primary_war_enemy = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_prisoner": {
        "desc": "Iterate through all prisoners",
        "usage": "ordered_prisoner = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_prowess_councillor": {
        "desc": "Iterate through all prowess-based councillors",
        "usage": "ordered_prowess_councillor = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_raid_target": {
        "desc": "Iterate through anyone the character is hostile to due to having raided them. Only returns top lieges",
        "usage": "ordered_raid_target = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_realm_border_county": {
        "desc": "Iterate through all counties that are on the edge of your realm bordering a different neighboring realm.",
        "usage": "ordered_realm_border_county = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_realm_county": {
        "desc": "Iterate through all counties in the realm. Based on top liege",
        "usage": "ordered_realm_county = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_realm_de_jure_duchy": {
        "desc": "Iterate through all de jure duchies that have at least one county in the realm. Based on top liege",
        "usage": "ordered_realm_de_jure_duchy = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_realm_de_jure_empire": {
        "desc": "Iterate through all de jure empire that have at least one county in the realm. Based on top liege",
        "usage": "ordered_realm_de_jure_empire = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_realm_de_jure_kingdom": {
        "desc": "Iterate through all de jure kingdom that have at least one county in the realm. Based on top liege",
        "usage": "ordered_realm_de_jure_kingdom = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_realm_province": {
        "desc": "Iterate through all realm provinces of a character",
        "usage": "ordered_realm_province = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "province",
        "notes": null
    },
    "ordered_relation": {
        "desc": "Iterate through scripted relations of a given type or multiple types, if someone is multiple relations they will only be in the list once",
        "usage": "ordered_relation = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_same_sex_spouse_candidate": {
        "desc": "Iterate through all the spouse candidates of the same sex of a character.",
        "usage": "ordered_same_sex_spouse_candidate = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": "WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN."
    },
    "ordered_scheme": {
        "desc": "Iterate through all schemes owned by the character",
        "usage": "ordered_scheme = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "scheme",
        "notes": null
    },
    "ordered_secret": {
        "desc": "Iterate through all secrets of the character",
        "usage": "ordered_secret = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "secret",
        "notes": null
    },
    "ordered_sibling": {
        "desc": "Iterate through all siblings",
        "usage": "ordered_sibling = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_sponsored_inspiration": {
        "desc": "Iterate through all sponsored inspirations",
        "usage": "ordered_sponsored_inspiration = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "inspiration",
        "notes": null
    },
    "ordered_spouse": {
        "desc": "Iterate through all spouses",
        "usage": "ordered_spouse = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_spouse_candidate": {
        "desc": "Iterate through all the spouse candidates of a character.",
        "usage": "ordered_spouse_candidate = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": "WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN."
    },
    "ordered_stewardship_councillor": {
        "desc": "Iterate through all stewardship-based councillors",
        "usage": "ordered_stewardship_councillor = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_sub_realm_barony": {
        "desc": "Iterate through all baronies in sub-realm",
        "usage": "ordered_sub_realm_barony = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_sub_realm_county": {
        "desc": "Iterate through all counties in sub-realm",
        "usage": "ordered_sub_realm_county = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_sub_realm_duchy": {
        "desc": "Iterate through all duchies in sub-realm",
        "usage": "ordered_sub_realm_duchy = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_sub_realm_empire": {
        "desc": "Iterate through all empires in sub-realm",
        "usage": "ordered_sub_realm_empire = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_sub_realm_kingdom": {
        "desc": "Iterate through all kingdoms in sub-realm",
        "usage": "ordered_sub_realm_kingdom = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_sub_realm_title": {
        "desc": "Iterate through all titles in sub-realm",
        "usage": "ordered_sub_realm_title = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_succession_appointment_invested_candidate": {
        "desc": "Iterate through all candidates supported by the scoped investor character for any title",
        "usage": "ordered_succession_appointment_invested_candidate = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": "It may contain people outside of investor's top realm or no longer valid for appointment"
    },
    "ordered_succession_appointment_invested_title": {
        "desc": "Iterate through all titles that has candidates supported by the scoped investor",
        "usage": "ordered_succession_appointment_invested_title = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": "It may contain titles outside of investor's top realm, and so invalid for appointment, and candidates may be already dead"
    },
    "ordered_targeting_faction": {
        "desc": "Iterate through all factions targeting the scope character",
        "usage": "ordered_targeting_faction = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "faction",
        "notes": null
    },
    "ordered_targeting_scheme": {
        "desc": "Iterate through all schemes targeting the character",
        "usage": "ordered_targeting_scheme = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "scheme",
        "notes": null
    },
    "ordered_targeting_secret": {
        "desc": "Iterate through all secrets that target the specified scope",
        "usage": "ordered_targeting_secret = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "secret",
        "notes": null
    },
    "ordered_tax_collector": {
        "desc": "Iterates through all Tax Collectors employed by the scoped character",
        "usage": "ordered_tax_collector = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_tax_collector_vassal": {
        "desc": "Iterates through all Vassals the scoped Character is the Tax Collector for",
        "usage": "ordered_tax_collector_vassal = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_tax_slot": {
        "desc": "Iterates through all Tax Slots the scoped character has",
        "usage": "ordered_tax_slot = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "tax_slot",
        "notes": null
    },
    "ordered_top_realm_border_county": {
        "desc": "Iterate through all counties that are on the edge of your realm bordering a different neighboring top realm.",
        "usage": "ordered_top_realm_border_county = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_traveling_family_member": {
        "desc": "Iterate though all characters that should travel with the scoped one (when moving between courts for instance); includes the scoped character",
        "usage": "ordered_traveling_family_member = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_tributary": {
        "desc": "Iterate through all tributaries",
        "usage": "ordered_tributary = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_truce_holder": {
        "desc": "Iterate through all characters that have a truce on this character",
        "usage": "ordered_truce_holder = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_truce_target": {
        "desc": "Iterate through all characters this character has a truce on",
        "usage": "ordered_truce_target = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_unassigned_taxpayers": {
        "desc": "Iterates through all unassigned taxpayers for scoped Character",
        "usage": "ordered_unassigned_taxpayers = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_unspent_known_secret": {
        "desc": "Iterate through all unspent secrets known by the character",
        "usage": "ordered_unspent_known_secret = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "secret",
        "notes": null
    },
    "ordered_vassal": {
        "desc": "Iterate through all DIRECT vassals",
        "usage": "ordered_vassal = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_vassal_or_below": {
        "desc": "Iterate through ALL vassals, not just direct vassals",
        "usage": "ordered_vassal_or_below = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_war_ally": {
        "desc": "Iterate through all direct war allies",
        "usage": "ordered_war_ally = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_war_enemy": {
        "desc": "Iterate through all direct war enemies",
        "usage": "ordered_war_enemy = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_warden_hostage": {
        "desc": "Iterate through all hostages having this warden",
        "usage": "ordered_warden_hostage = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "overlord_contract_set_obligation_level": {
        "desc": "change the obligation level of the scoped character's overlord contract",
        "usage": "vassal_contract_set_obligation_level = { type = name level = 1 } # index to obligation level\nvassal_contract_set_obligation_level = { type = name level = feudal_obligation_low }\nvassal_contract_set_obligation_level = { type = name level = scope:obligation }",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "pay_herd": {
        "desc": "the scoped character pays herd to the target character",
        "usage": "pay_herd = { target = X value = Y }",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "pay_long_term_gold": {
        "desc": "the scope character pays gold to the target character, pay_long_term_gold = { target = X gold = Y } (from AI budget category 'long term' first, then rest)",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "pay_long_term_income": {
        "desc": "the scope character immediately pays gold corresponding to their income to the target character, pay_long_term_income = { target = X days/months/years = Y } (AI budget 'long term' first, then rest)",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "pay_reserved_gold": {
        "desc": "the scope character pays gold to the target character, pay_reserved_gold = { target = X gold = Y } (from AI budget category 'reserved' first, then rest)",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "pay_reserved_income": {
        "desc": "the scope character immediately pays gold corresponding to their income to the target character, pay_reserved_income = { target = X days/months/years = Y } (AI budget 'reserved' first, then rest)",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "pay_short_term_gold": {
        "desc": "the scope character pays gold to the target character, pay_short_term_gold = { target = X gold = Y } (from AI budget category 'short term' first, then rest)",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "pay_short_term_income": {
        "desc": "the scope character immediately pays gold corresponding to their income to the target character, pay_short_term_income = { target = X days/months/years = Y } (AI budget 'short term' first, then rest)",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "pay_war_chest_gold": {
        "desc": "the scope character pays gold to the target character, pay_war_chest_gold = { target = X gold = Y } (from AI budget category 'war chest' first, then rest)",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "pay_war_chest_income": {
        "desc": "the scope character immediately pays gold corresponding to their income to the target character, pay_war_chest_income = { target = X days/months/years = Y } (AI budget 'war chest' first, then rest)",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "play_music_cue": {
        "desc": "Plays the specified music cue.",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "play_sound_effect": {
        "desc": "Plays the specified sound effect.",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "populate_task_contracts_for_area": {
        "desc": "Populate area around location with task contracts up to specified amount",
        "usage": "populate_task_contracts_for_area = {\nlocation = scope:province\namount = { value = 5 }\ngroup = { rescue assasination gardening }",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "random_acclaimed_knight": {
        "desc": "Iterate through all acclaimed knights employed by a given character",
        "usage": "random_acclaimed_knight = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_accolade": {
        "desc": "Iterate through all ( active and inactive ) Accolades of a given liege character's Acclaimed Knights",
        "usage": "random_accolade = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "accolade",
        "notes": null
    },
    "random_active_accolade": {
        "desc": "Iterate through all active Accolades of a given liege character's Acclaimed Knights",
        "usage": "random_active_accolade = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "accolade",
        "notes": null
    },
    "random_alert_creatable_title": {
        "desc": "Iterate through all titles that can be created by the character. (only for alerts)",
        "usage": "random_alert_creatable_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_alert_usurpable_title": {
        "desc": "Iterate through all titles that can be usurped by the character. (only for alerts)",
        "usage": "random_alert_usurpable_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_ally": {
        "desc": "Iterate through all allies",
        "usage": "random_ally = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_ancestor": {
        "desc": "Iterate through all the ancestors of the scope character up to 5 generations",
        "usage": "random_ancestor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_army": {
        "desc": "Iterate through all armies",
        "usage": "random_army = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "army",
        "notes": null
    },
    "random_available_task_contract": {
        "desc": "Iterate through all task contracts of location of root province",
        "usage": "random_available_task_contract = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "task_contract",
        "notes": null
    },
    "random_character_active_contract": {
        "desc": "Gets all accepted task contracts of the root character",
        "usage": "random_character_active_contract = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "task_contract",
        "notes": null
    },
    "random_character_artifact": {
        "desc": "Iterate through all artifacts in a given characters inventory",
        "usage": "random_character_artifact = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "artifact",
        "notes": null
    },
    "random_character_epidemic": {
        "desc": "Gets epidemics affecting the scoped character",
        "usage": "random_character_epidemic = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "epidemic",
        "notes": null
    },
    "random_character_situation": {
        "desc": "Iterate through all situations that a character is participating in",
        "usage": "random_character_situation = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "situation",
        "notes": null
    },
    "random_character_struggle": {
        "desc": "Iterate through all struggles that character is involved in. Optional: Narrow down the involvement status *_chracter_struggle = { involvement = involved | interloper }",
        "usage": "random_character_struggle = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "struggle",
        "notes": null
    },
    "random_character_task_contract": {
        "desc": "Gets all task contracts of the scoped character",
        "usage": "random_character_task_contract = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "task_contract",
        "notes": null
    },
    "random_character_to_title_neighboring_and_across_water_county": {
        "desc": "Scopes from a character to a neighboring county (incl. across water, looking trough the de Jure lieges)",
        "usage": "random_character_to_title_neighboring_and_across_water_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_character_to_title_neighboring_and_across_water_duchy": {
        "desc": "Scopes from a character to a neighboring duchy (incl. across water, looking trough the de Jure lieges)",
        "usage": "random_character_to_title_neighboring_and_across_water_duchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_character_to_title_neighboring_and_across_water_empire": {
        "desc": "Scopes from a character to a neighboring empire (incl. across water, looking trough the de Jure lieges)",
        "usage": "random_character_to_title_neighboring_and_across_water_empire = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_character_to_title_neighboring_and_across_water_kingdom": {
        "desc": "Scopes from a character to a neighboring kingdom (incl. across water, looking trough the de Jure lieges)",
        "usage": "random_character_to_title_neighboring_and_across_water_kingdom = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_character_to_title_neighboring_county": {
        "desc": "Scopes from a character to a neighboring county (looking trough the de Jure lieges)",
        "usage": "random_character_to_title_neighboring_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_character_to_title_neighboring_duchy": {
        "desc": "Scopes from a character to a neighboring duchy (looking trough the de Jure lieges)",
        "usage": "random_character_to_title_neighboring_duchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_character_to_title_neighboring_empire": {
        "desc": "Scopes from a character to a neighboring empire (looking trough the de Jure lieges)",
        "usage": "random_character_to_title_neighboring_empire = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_character_to_title_neighboring_kingdom": {
        "desc": "Scopes from a character to a neighboring kingdom (looking trough the de Jure lieges)",
        "usage": "random_character_to_title_neighboring_kingdom = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_character_trait": {
        "desc": "Iterate through all traits a character has",
        "usage": "random_character_trait = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "trait",
        "notes": null
    },
    "random_character_war": {
        "desc": "Wars of the scoped character",
        "usage": "random_character_war = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "war",
        "notes": null
    },
    "random_child": {
        "desc": "Iterate through all children",
        "usage": "random_child = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_claim": {
        "desc": "Iterate through the titles of all claims held by a character; parameters: explicit = yes/no/all pressed = yes/no/all",
        "usage": "random_claim = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_claimed_artifact": {
        "desc": "Iterate through all claimed artifacts of the scoped character",
        "usage": "random_claimed_artifact = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "artifact",
        "notes": null
    },
    "random_close_family_member": {
        "desc": "Iterate through all the close family [father, mother, siblings, children, grandparents]",
        "usage": "random_close_family_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_close_or_extended_family_member": {
        "desc": "Iterate through all the close and extended relatives [father, mother, siblings, children, grandparents, uncles/aunts, nephew/niece, cousins]",
        "usage": "random_close_or_extended_family_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_concubine": {
        "desc": "Iterate through all concubines",
        "usage": "random_concubine = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_consort": {
        "desc": "Iterate through all consorts (concubines and spouses)",
        "usage": "random_consort = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_contact": {
        "desc": "Iterate through all contact characters of the root character",
        "usage": "random_contact = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_councillor": {
        "desc": "Iterate through all councillors",
        "usage": "random_councillor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_court_position_candidate": {
        "desc": "Iterate through all valid candidates for a court position type.",
        "usage": "*_court_position_candidate = {\ncourt_position = bodyguard_court_position\ncourt_position = scope:my_scoped_court_position_type\nrandom_court_position_candidate = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_court_position_employer": {
        "desc": "Iterates through all characters that employ the scoped character in any court position.",
        "usage": "random_court_position_employer = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_court_position_holder": {
        "desc": "Iterates through all characters employed by the scoped character in the target court position.",
        "usage": "random_court_position_holder = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_courtier": {
        "desc": "Iterate through all courtiers",
        "usage": "random_courtier = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_courtier_away": {
        "desc": "Iterate through all courtiers that are away",
        "usage": "random_courtier_away = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_courtier_or_guest": {
        "desc": "Iterate through all courtiers and guests (pool and foreign court guests)",
        "usage": "random_courtier_or_guest = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_de_jure_claim": {
        "desc": "Iterate through all de jure claims for a character",
        "usage": "random_de_jure_claim = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_diarchy_succession_character": {
        "desc": "Iterate through all character in the diarchy line of succession.If there's no active diarchy or active one doesn't have succession,it iterates over regency candidates",
        "usage": "random_diarchy_succession_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_diplomacy_councillor": {
        "desc": "Iterate through all diplomacy-based councillors",
        "usage": "random_diplomacy_councillor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_directly_owned_province": {
        "desc": "Iterate through all directly owned provinces",
        "usage": "random_directly_owned_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "province",
        "notes": null
    },
    "random_election_title": {
        "desc": "Iterate through all titles the scoped character can vote on",
        "usage": "random_election_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_equipped_character_artifact": {
        "desc": "Iterate through all equipped artifacts in a given characters inventory",
        "usage": "random_equipped_character_artifact = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "artifact",
        "notes": null
    },
    "random_extended_family_member": {
        "desc": "Iterate through all the extended family [uncles/aunts, nephew/niece, cousins]",
        "usage": "random_extended_family_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_foreign_court_guest": {
        "desc": "Iterate through all guests visiting from another court (in contrast to pool_guest they have a liege)",
        "usage": "random_foreign_court_guest = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_former_concubine": {
        "desc": "Iterate through all former concubines. Not persisted past death",
        "usage": "random_former_concubine = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_former_concubinist": {
        "desc": "Iterate through all former concubinists. Not persisted past death",
        "usage": "random_former_concubinist = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_former_spouse": {
        "desc": "Iterate through all former spouses",
        "usage": "random_former_spouse = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_general_councillor": {
        "desc": "Iterate through all councillors that are not related to a skill",
        "usage": "random_general_councillor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_heir": {
        "desc": "Heirs of the scoped character",
        "usage": "random_heir = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_heir_title": {
        "desc": "Iterate through all titles the scoped character is heir to",
        "usage": "random_heir_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_held_title": {
        "desc": "Iterate through all held landed titles",
        "usage": "random_held_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_hired_mercenary": {
        "desc": "Iterate through all hired mercenary companies",
        "usage": "random_hired_mercenary = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "mercenary_company",
        "notes": null
    },
    "random_home_court_hostage": {
        "desc": "Iterate through all hostages currently abroad",
        "usage": "random_home_court_hostage = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_hooked_character": {
        "desc": "Iterate through all characters this character has a hook on",
        "usage": "random_hooked_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_hostile_raider": {
        "desc": "Iterate through anyone the character is hostile to due to their top-liege's realm having been raided",
        "usage": "random_hostile_raider = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_intrigue_councillor": {
        "desc": "Iterate through all intrigue-based councillors",
        "usage": "random_intrigue_councillor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_invited_activity": {
        "desc": "Iterate through all activities a character has been invited to",
        "usage": "random_invited_activity = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "activity",
        "notes": null
    },
    "random_knight": {
        "desc": "Iterate through all knights",
        "usage": "random_knight = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_known_secret": {
        "desc": "Iterate through all secrets known by the character",
        "usage": "random_known_secret = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "secret",
        "notes": null
    },
    "random_land_neighboring_realm_with_tributaries": {
        "desc": "A realm with a different top liege neighboring the realm of the scope character's top liege; switches to the realm's top title. Can be based on borders a day or two out of date. Includes land borders extended due to tributaries.",
        "usage": "random_land_neighboring_realm_with_tributaries = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_land_neighboring_realm_with_tributaries_owner": {
        "desc": "A realm with a different top liege neighboring the realm of the scope character's top liege; switches to the holder of the realm. Can be based on borders a day or two out of date. Includes land borders extended due to tributaries.",
        "usage": "random_land_neighboring_realm_with_tributaries_owner = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_learning_councillor": {
        "desc": "Iterate through all learning-based councillors",
        "usage": "random_learning_councillor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_liege_or_above": {
        "desc": "Iterate through all lieges above a character (skipping the character themselves)",
        "usage": "random_liege_or_above = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_maa_regiment": {
        "desc": "Iterate through all MaA regiments",
        "usage": "random_maa_regiment = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "regiment",
        "notes": null
    },
    "random_martial_councillor": {
        "desc": "Iterate through all martial-based councillors",
        "usage": "random_martial_councillor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_memory": {
        "desc": "Iterate through all memories of a character",
        "usage": "random_memory = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character_memory",
        "notes": null
    },
    "random_neighboring_and_across_water_realm_same_rank_owner": {
        "desc": "A sub-realm or realm bordering the scope character's realm (including across water) and has the same rank as the scope character (look for lieges of he owner of the land if necessary)",
        "usage": "random_neighboring_and_across_water_realm_same_rank_owner = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_neighboring_and_across_water_top_liege_realm": {
        "desc": "A realm with a different top liege neighboring the realm of the scope character's top liege (including across water); switches to the realm's top title. Can be based on borders a day or two out of date",
        "usage": "random_neighboring_and_across_water_top_liege_realm = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_neighboring_and_across_water_top_liege_realm_owner": {
        "desc": "A realm with a different top liege neighboring the realm of the scope character's top liege (including across water); switches to the holder of the realm. Can be based on borders a day or two out of date",
        "usage": "random_neighboring_and_across_water_top_liege_realm_owner = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_neighboring_and_across_water_top_suzerain_realm": {
        "desc": "A realm with a different top suzerain neighboring the realm of the scope character's top suzerain (including across water); switches to the realm's top title. Can be based on borders a day or two out of date",
        "usage": "random_neighboring_and_across_water_top_suzerain_realm = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_neighboring_and_across_water_top_suzerain_realm_owner": {
        "desc": "A realm with a different top suzerain neighboring the realm of the scope character's top suzerain (including across water); switches to the holder of the realm. Can be based on borders a day or two out of date",
        "usage": "random_neighboring_and_across_water_top_suzerain_realm_owner = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_neighboring_realm_same_rank_owner": {
        "desc": "A sub-realm or realm bordering the scope character's realm and has the same rank as the scope character (look for lieges of he owner of the land if necessary)",
        "usage": "random_neighboring_realm_same_rank_owner = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_neighboring_top_liege_realm": {
        "desc": "A realm with a different top liege neighboring the realm of the scope character's top liege; switches to the realm's top title. Can be based on borders a day or two out of date",
        "usage": "random_neighboring_top_liege_realm = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_neighboring_top_liege_realm_owner": {
        "desc": "A realm with a different top liege neighboring the realm of the scope character's top liege; switches to the holder of the realm. Can be based on borders a day or two out of date",
        "usage": "random_neighboring_top_liege_realm_owner = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_neighboring_top_suzerain_realm": {
        "desc": "A realm with a different top suzerain neighboring the realm of the scope character's top suzerain; switches to the realm's top title. Can be based on borders a day or two out of date",
        "usage": "random_neighboring_top_suzerain_realm = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_neighboring_top_suzerain_realm_owner": {
        "desc": "A realm with a different top suzerain neighboring the realm of the scope character's top suzerain; switches to the holder of the realm. Can be based on borders a day or two out of date",
        "usage": "random_neighboring_top_suzerain_realm_owner = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_noble_family": {
        "desc": "Iterate through all noble family titles in the realm of scoped character",
        "usage": "random_noble_family = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_opposite_sex_spouse_candidate": {
        "desc": "Iterate through all the spouse candidates of the opposite sex of a character.",
        "usage": "random_opposite_sex_spouse_candidate = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": "WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN."
    },
    "random_owned_story": {
        "desc": "Iterate through all owned stories for a character",
        "usage": "random_owned_story = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "story",
        "notes": null
    },
    "random_parent": {
        "desc": "Iterate through all (both) parents",
        "usage": "random_parent = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_patroned_holy_order": {
        "desc": "Iterate through all holy orders that the scoped character is a patron of",
        "usage": "random_patroned_holy_order = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "holy_order",
        "notes": null
    },
    "random_personal_claimed_artifact": {
        "desc": "Iterate through all personally claimed artifacts of the scoped character",
        "usage": "random_personal_claimed_artifact = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "artifact",
        "notes": null
    },
    "random_pinned_character": {
        "desc": "Iterate through characters this player has pinned",
        "usage": "random_pinned_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_pinning_character": {
        "desc": "Iterate through characters whose player has this character pinned",
        "usage": "random_pinning_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_played_character": {
        "desc": "Iterate through all characters the player playing this character has played. Matches the game over legacy, except for excluding the currently played character",
        "usage": "random_played_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_player_heir": {
        "desc": "Iterate through player heirs, capped at the first 10",
        "usage": "random_player_heir = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_player_legend_library": {
        "desc": "Get all legends in a player character library.",
        "usage": "random_player_legend_library = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "legend",
        "notes": null
    },
    "random_pool_guest": {
        "desc": "Iterate through all guests visiting the court from the pool (in contrast to foreign_court_guest they don't have a liege)",
        "usage": "random_pool_guest = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_potential_marriage_option": {
        "desc": "Iterate through all potential selectable marriage or betrohed options",
        "usage": "random_potential_marriage_option = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_powerful_family": {
        "desc": "Iterate through all directly owned provinces",
        "usage": "random_powerful_family = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "dynasty_house",
        "notes": null
    },
    "random_powerful_vassal": {
        "desc": "Iterate through the all powerful vassals of a character",
        "usage": "random_powerful_vassal = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_pretender_title": {
        "desc": "Iterate through all landed titles character is pretender to",
        "usage": "random_pretender_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_primary_war_enemy": {
        "desc": "Iterate through all primary war enemies",
        "usage": "random_primary_war_enemy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_prisoner": {
        "desc": "Iterate through all prisoners",
        "usage": "random_prisoner = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_prowess_councillor": {
        "desc": "Iterate through all prowess-based councillors",
        "usage": "random_prowess_councillor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_raid_target": {
        "desc": "Iterate through anyone the character is hostile to due to having raided them. Only returns top lieges",
        "usage": "random_raid_target = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_realm_border_county": {
        "desc": "Iterate through all counties that are on the edge of your realm bordering a different neighboring realm.",
        "usage": "random_realm_border_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_realm_county": {
        "desc": "Iterate through all counties in the realm. Based on top liege",
        "usage": "random_realm_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_realm_de_jure_duchy": {
        "desc": "Iterate through all de jure duchies that have at least one county in the realm. Based on top liege",
        "usage": "random_realm_de_jure_duchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_realm_de_jure_empire": {
        "desc": "Iterate through all de jure empire that have at least one county in the realm. Based on top liege",
        "usage": "random_realm_de_jure_empire = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_realm_de_jure_kingdom": {
        "desc": "Iterate through all de jure kingdom that have at least one county in the realm. Based on top liege",
        "usage": "random_realm_de_jure_kingdom = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_realm_province": {
        "desc": "Iterate through all realm provinces of a character",
        "usage": "random_realm_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "province",
        "notes": null
    },
    "random_relation": {
        "desc": "Iterate through scripted relations of a given type or multiple types, if someone is multiple relations they will only be in the list once",
        "usage": "random_relation = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_same_sex_spouse_candidate": {
        "desc": "Iterate through all the spouse candidates of the same sex of a character.",
        "usage": "random_same_sex_spouse_candidate = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": "WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN."
    },
    "random_scheme": {
        "desc": "Iterate through all schemes owned by the character",
        "usage": "random_scheme = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "scheme",
        "notes": null
    },
    "random_secret": {
        "desc": "Iterate through all secrets of the character",
        "usage": "random_secret = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "secret",
        "notes": null
    },
    "random_sibling": {
        "desc": "Iterate through all siblings",
        "usage": "random_sibling = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_sponsored_inspiration": {
        "desc": "Iterate through all sponsored inspirations",
        "usage": "random_sponsored_inspiration = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "inspiration",
        "notes": null
    },
    "random_spouse": {
        "desc": "Iterate through all spouses",
        "usage": "random_spouse = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_spouse_candidate": {
        "desc": "Iterate through all the spouse candidates of a character.",
        "usage": "random_spouse_candidate = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": "WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN."
    },
    "random_stewardship_councillor": {
        "desc": "Iterate through all stewardship-based councillors",
        "usage": "random_stewardship_councillor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_sub_realm_barony": {
        "desc": "Iterate through all baronies in sub-realm",
        "usage": "random_sub_realm_barony = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_sub_realm_county": {
        "desc": "Iterate through all counties in sub-realm",
        "usage": "random_sub_realm_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_sub_realm_duchy": {
        "desc": "Iterate through all duchies in sub-realm",
        "usage": "random_sub_realm_duchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_sub_realm_empire": {
        "desc": "Iterate through all empires in sub-realm",
        "usage": "random_sub_realm_empire = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_sub_realm_kingdom": {
        "desc": "Iterate through all kingdoms in sub-realm",
        "usage": "random_sub_realm_kingdom = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_sub_realm_title": {
        "desc": "Iterate through all titles in sub-realm",
        "usage": "random_sub_realm_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_succession_appointment_invested_candidate": {
        "desc": "Iterate through all candidates supported by the scoped investor character for any title",
        "usage": "random_succession_appointment_invested_candidate = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": "It may contain people outside of investor's top realm or no longer valid for appointment"
    },
    "random_succession_appointment_invested_title": {
        "desc": "Iterate through all titles that has candidates supported by the scoped investor",
        "usage": "random_succession_appointment_invested_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": "It may contain titles outside of investor's top realm, and so invalid for appointment, and candidates may be already dead"
    },
    "random_targeting_faction": {
        "desc": "Iterate through all factions targeting the scope character",
        "usage": "random_targeting_faction = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "faction",
        "notes": null
    },
    "random_targeting_scheme": {
        "desc": "Iterate through all schemes targeting the character",
        "usage": "random_targeting_scheme = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "scheme",
        "notes": null
    },
    "random_targeting_secret": {
        "desc": "Iterate through all secrets that target the specified scope",
        "usage": "random_targeting_secret = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "secret",
        "notes": null
    },
    "random_tax_collector": {
        "desc": "Iterates through all Tax Collectors employed by the scoped character",
        "usage": "random_tax_collector = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_tax_collector_vassal": {
        "desc": "Iterates through all Vassals the scoped Character is the Tax Collector for",
        "usage": "random_tax_collector_vassal = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_tax_slot": {
        "desc": "Iterates through all Tax Slots the scoped character has",
        "usage": "random_tax_slot = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "tax_slot",
        "notes": null
    },
    "random_top_realm_border_county": {
        "desc": "Iterate through all counties that are on the edge of your realm bordering a different neighboring top realm.",
        "usage": "random_top_realm_border_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_traveling_family_member": {
        "desc": "Iterate though all characters that should travel with the scoped one (when moving between courts for instance); includes the scoped character",
        "usage": "random_traveling_family_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_tributary": {
        "desc": "Iterate through all tributaries",
        "usage": "random_tributary = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_truce_holder": {
        "desc": "Iterate through all characters that have a truce on this character",
        "usage": "random_truce_holder = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_truce_target": {
        "desc": "Iterate through all characters this character has a truce on",
        "usage": "random_truce_target = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_unassigned_taxpayers": {
        "desc": "Iterates through all unassigned taxpayers for scoped Character",
        "usage": "random_unassigned_taxpayers = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_unspent_known_secret": {
        "desc": "Iterate through all unspent secrets known by the character",
        "usage": "random_unspent_known_secret = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "secret",
        "notes": null
    },
    "random_vassal": {
        "desc": "Iterate through all DIRECT vassals",
        "usage": "random_vassal = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_vassal_or_below": {
        "desc": "Iterate through ALL vassals, not just direct vassals",
        "usage": "random_vassal_or_below = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_war_ally": {
        "desc": "Iterate through all direct war allies",
        "usage": "random_war_ally = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_war_enemy": {
        "desc": "Iterate through all direct war enemies",
        "usage": "random_war_enemy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "random_warden_hostage": {
        "desc": "Iterate through all hostages having this warden",
        "usage": "random_warden_hostage = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "refund_all_perks": {
        "desc": "Refunds all perks of the character. Example: refund_all_perks = yes",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "refund_perks": {
        "desc": "Refunds all perks of the RHS lifestyle. Example: refund_perks = intrigue_lifestyle",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "release_from_prison": {
        "desc": "releases the character from the prison, imprison = X, where X is a boolean value",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "remove_all_character_modifier_instances": {
        "desc": "Remove all instances of a modifier from a character",
        "usage": "remove_all_character_modifier_instances = name",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "remove_character_flag": {
        "desc": "removes a character flag",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "remove_character_modifier": {
        "desc": "Remove a modifier from a character",
        "usage": "remove_character_modifier = name",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "remove_character_secret_faith": {
        "desc": "Removes the characters secret_faith",
        "usage": "remove_character_secret_faith = yes",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "remove_claim": {
        "desc": "removes an explicit (not from a living parent/grand parent) claim",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "remove_concubine": {
        "desc": "Removes the target character as a concubine of the scope character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "remove_courtier_or_guest": {
        "desc": "Removes the target character (guest or courtier) from the scope character's court",
        "usage": "scope:host = { remove_courtier_or_guest = scope:guest } # move to pool, staying in same province\nscope:host = {\nremove_courtier_or_guest = {\ncharacter = scope:guest\nnew_location = scope:some_province # optionally specify a new location",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "remove_dead_character_variable": {
        "desc": "remove_dead_character_variable = <name>",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": "Remove a variable from a dead character."
    },
    "remove_decision_cooldown": {
        "desc": "Remove the cooldown on taking a decision for the scoped character",
        "usage": "remove_decision_cooldown = decision_name",
        "supported_scopes": "character",
        "supported_targets": "decision",
        "notes": null
    },
    "remove_from_activity": {
        "desc": "remove_from_activity = activity",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "activity",
        "notes": "The scoped character is removed from the target activity"
    },
    "remove_hook": {
        "desc": "Removes a hook on a character, remove_hook = { target = X, type = Y }, if type is specified, the hook will only be removed if it is of that type",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "remove_interaction_cooldown": {
        "desc": "Remove the cooldown on using an interaction for the scoped character",
        "usage": "remove_interaction_cooldown = interaction_name",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "remove_interaction_cooldown_against": {
        "desc": "Remove the cooldown on using an interaction against the target character for the scoped character",
        "usage": "remove_interaction_cooldown_against = { interaction = interaction_name target = character }",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "remove_localized_text": {
        "desc": "Removes a piece of localized text from being stored on the character with a given key, you should do this whenever you are done with the custom text so as to not bloat saves",
        "usage": "remove_localized_text = key",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "remove_long_term_gold": {
        "desc": "removes gold from a character (from AI's 'long term' budget first, then rest)",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "remove_nickname": {
        "desc": "Removes any nickname from the current character [yes|no]",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "remove_opinion": {
        "desc": "Removes a temporary opinion modifier, remove_opinion = { target = X modifier = Y single = Z (no by default) } where X is a character, Y is the opinion modifier, Z tells whether to remove all instances of the modifier or just one",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "remove_perk": {
        "desc": "Remove the perk for this character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "remove_personal_artifact_claim": {
        "desc": "Removes a personal claim on the target artifact from the scoped character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "artifact",
        "notes": null
    },
    "remove_realm_law": {
        "desc": "Removes the given law from the scoped character. This will leave the law group empty, so only do this if you're getting rid of a law group",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "remove_relation_activity_recurrer": {
        "desc": "Removes scripted relationship",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "remove_relation_antiquarian": {
        "desc": "Removes scripted relationship",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "remove_relation_best_friend": {
        "desc": "Removes scripted relationship",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "remove_relation_blood_brother": {
        "desc": "Removes scripted relationship",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "remove_relation_bully": {
        "desc": "Removes scripted relationship",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "remove_relation_court_physician": {
        "desc": "Removes scripted relationship",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "remove_relation_crush": {
        "desc": "Removes scripted relationship",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "remove_relation_event_recurrer": {
        "desc": "Removes scripted relationship",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "remove_relation_favorite_child": {
        "desc": "Removes scripted relationship",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "remove_relation_flag": {
        "desc": "Removed a flag from an existing relation flag = flag_name (declared in scripted_relation) target = other_character relation = scripted_relation",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "remove_relation_friend": {
        "desc": "Removes scripted relationship",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "remove_relation_grudge": {
        "desc": "Removes scripted relationship",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "remove_relation_guardian": {
        "desc": "Removes scripted relationship",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "remove_relation_intrigue_mentor": {
        "desc": "Removes scripted relationship",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "remove_relation_intrigue_student": {
        "desc": "Removes scripted relationship",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "remove_relation_lover": {
        "desc": "Removes scripted relationship",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "remove_relation_mentor": {
        "desc": "Removes scripted relationship",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "remove_relation_nemesis": {
        "desc": "Removes scripted relationship",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "remove_relation_nursed_child": {
        "desc": "Removes scripted relationship",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "remove_relation_oaf": {
        "desc": "Removes scripted relationship",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "remove_relation_old_flame": {
        "desc": "Removes scripted relationship",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "remove_relation_potential_friend": {
        "desc": "Removes scripted relationship",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "remove_relation_potential_hook": {
        "desc": "Removes scripted relationship",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "remove_relation_potential_lover": {
        "desc": "Removes scripted relationship",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "remove_relation_potential_rival": {
        "desc": "Removes scripted relationship",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "remove_relation_rival": {
        "desc": "Removes scripted relationship",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "remove_relation_soldier_friend": {
        "desc": "Removes scripted relationship",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "remove_relation_soulmate": {
        "desc": "Removes scripted relationship",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "remove_relation_student": {
        "desc": "Removes scripted relationship",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "remove_relation_victim": {
        "desc": "Removes scripted relationship",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "remove_relation_ward": {
        "desc": "Removes scripted relationship",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "remove_relation_wedding_bad_fertility": {
        "desc": "Removes scripted relationship",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "remove_relation_wedding_good_fertility": {
        "desc": "Removes scripted relationship",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "remove_relation_wedding_very_bad_fertility": {
        "desc": "Removes scripted relationship",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "remove_relation_wedding_very_good_fertility": {
        "desc": "Removes scripted relationship",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "remove_relation_wet_nurse": {
        "desc": "Removes scripted relationship",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "remove_reserved_gold": {
        "desc": "removes gold from a character (from AI's 'reserved' budget first, then rest)",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "remove_scheme_cooldown_against": {
        "desc": "Remove the cooldown on using a scheme against the target character for the scoped character",
        "usage": "remove_scheme_cooldown_against = { scheme = scheme_name target = character }",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "remove_short_term_gold": {
        "desc": "removes gold from a character (from AI's 'short term' budget first, then rest)",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "remove_trait": {
        "desc": "Removes a trait from a character. Tooltip will not be shown if the character doesn't have the trait.",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "trait",
        "notes": null
    },
    "remove_trait_force_tooltip": {
        "desc": "Removes a trait from a character. Tooltip will be shown even if the character doesn't have the trait.",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "trait",
        "notes": null
    },
    "remove_war_chest_gold": {
        "desc": "removes gold from a character (from AI's 'war chest' budget first, then rest)",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "replace_court_position": {
        "desc": "Replaces the target character holding target court position within scoped character's court with target character",
        "usage": "recipient = character scope - target character to receive the title\nholder = character scope - target character to revoke the target court position of in favour of recipient\ncourt_position = court position type - court position type to assign the receiver",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "reset_beneficiary": {
        "desc": "The target character stops having a beneficiary. reset_beneficiary = yes",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "return_home": {
        "desc": "Start a travel plan for the character to return home, using their current travel plan info if they have any or starting a new travel plan if they do not.",
        "usage": "return_home = yes\\no",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": "Saving this as a scope will not work for player characters if they have to use the planner."
    },
    "return_hostage": {
        "desc": "Release scoped character from hostage and return to home court",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "return_to_court": {
        "desc": "Returns the scope character to the employers court.",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "reverse_add_opinion": {
        "desc": "Adds a temporary reverse opinion modifier, reverse_add_opinion = { modifier = X days/months/years = Y target = Z }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": "X is a scripted modifier name. Y can be a value or a range \"{ A B }\" If no timeout are specified, the modifier's scripted default timeout will be used."
    },
    "revoke_court_position": {
        "desc": "Revokes target position from scoped character.",
        "usage": "court_position = court position type - court position type to revoke from scoped character's court\nrecipient = character - optional - target current holder of position to revoke\nholder = character - optional - same as recipient",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "scriptedtests_recalculate_character_modifier": {
        "desc": "Recalculates the modifier of the scoped character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "scriptedtests_recalculate_succession": {
        "desc": "Recalculates the line of succession of the scoped character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "send_interface_message": {
        "desc": "Sends a message to the player playing the character in the scope and then executes any effects inside.",
        "usage": "send_interface_message = {\ntype = message_type # default: send_interface_message\ntitle = LOCALIZATION # optional, otherwise takes it from the message type\ndesc = LOCALIZATION # optional, otherwise takes it from the message type\ntooltip = LOCALIZATION # optional, otherwise takes it from the message type\nleft_icon = scope:recipient # optional, character, artifact, or title\nright_icon = scope:the_title # optional, character, artifact, or title\nadd_dread = 5\nscope:someone = { add_gold = 5 }",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": "For the message text and tooltip, $EFFECT$ contains the text description of the effects in the past tense. And $DESC$ contains the text from the desc field."
    },
    "send_interface_popup": {
        "desc": "Sends a message to the player playing the character in the scope and then executes any effects inside.",
        "usage": "send_interface_popup = {\ntype = message_type # default: send_interface_popup\ntitle = LOCALIZATION # optional, otherwise takes it from the message type\ndesc = LOCALIZATION # optional, otherwise takes it from the message type\ntooltip = LOCALIZATION # optional, otherwise takes it from the message type\nleft_icon = scope:recipient # optional, character, artifact, or title\nright_icon = scope:the_title # optional, character, artifact, or title\nadd_dread = 5\nscope:someone = { add_gold = 5 }",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": "For the message text and tooltip, $EFFECT$ contains the text description of the effects in the past tense. And $DESC$ contains the text from the desc field."
    },
    "send_interface_toast": {
        "desc": "Sends a message to the player playing the character in the scope and then executes any effects inside.",
        "usage": "send_interface_toast = {\ntype = message_type # default: send_interface_toast\ntitle = LOCALIZATION # optional, otherwise takes it from the message type\ndesc = LOCALIZATION # optional, otherwise takes it from the message type\ntooltip = LOCALIZATION # optional, otherwise takes it from the message type\nleft_icon = scope:recipient # optional, character, artifact, or title\nright_icon = scope:the_title # optional, character, artifact, or title\nadd_dread = 5\nscope:someone = { add_gold = 5 }",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": "For the message text and tooltip, $EFFECT$ contains the text description of the effects in the past tense. And $DESC$ contains the text from the desc field."
    },
    "set_absolute_country_control": {
        "desc": "Sets if this character has absolute country control, unlock_character_movement = yes/no/boolean event target",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_age": {
        "desc": "Sets the character's age. Note that this will completely bypass birthday on-actions, age-related health, and so on, just like the console command",
        "usage": "Usage: set_age = script value",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_amenity_level": {
        "desc": "set_amenity_level = { type = food value = 2 }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": "Sets the amenity type to the given value for the scoped character"
    },
    "set_beneficiary": {
        "desc": "The target character becomes the beneficiary of the scoped character. set_beneficiary = some character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "set_character_faith": {
        "desc": "Changes what faith a character has executing the effects for it. For history setup use 'set_character_faith_history' instead.",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "faith",
        "notes": null
    },
    "set_character_faith_history": {
        "desc": "Changes what faith a character has NOT executing the effects for it. USE ONLY IN HISOTRY SETUP!",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "faith",
        "notes": null
    },
    "set_character_faith_with_conversion": {
        "desc": "Changes what faith a character has, as if they used the faith-view interaction (minus the piety cost). So vassals who'd accept will get converted, as will capitals",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "faith",
        "notes": null
    },
    "set_character_secret_faith": {
        "desc": "Changes the characters secret_faith",
        "usage": "set_character_secret_faith = faith:rabbinism",
        "supported_scopes": "character",
        "supported_targets": "faith",
        "notes": null
    },
    "set_child_of_concubine_on_pregnancy": {
        "desc": "Sets the child to be (or not be) a child of a concubine during pregnancy",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_council_task": {
        "desc": "Sets the task of the scope councillor { task_type = council_position_type_key target = for_targeted_tasks  }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_court_language": {
        "desc": "Set the character's court language to the given languageset_court_language = language_norwegian",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_court_type": {
        "desc": "Set the court type for this character's royal court",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_culture": {
        "desc": "Set the culture for this character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "culture",
        "notes": null
    },
    "set_culture_same_as": {
        "desc": "sets the culture of the character to be the same as the culture of the target",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "set_current_court_grandeur": {
        "desc": "Sets the current court grandeur of a character with a royal court, clamped between NRoyalCourt::COURT_GRANDEUR_MIN and NRoyalCourt::COURT_GRANDEUR_MAX.",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": "Does not apply a grace period, and removes any existing one."
    },
    "set_dead_character_variable": {
        "desc": "set_dead_character_variable = {",
        "usage": "name = <name> - name of the variable\nvalue = <value> - any event target, bool, value, script value or flag\nyears/weeks/days = { <min_number> <max_number> } - years/weeks/days this flag is supposed to last",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_death_reason": {
        "desc": "set_death_reason = { killer = X death_reason = Y artifact = Z }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": "All parameters are optional. Sets the death reason, the killer, and artifact used in the death of a dead character"
    },
    "set_default_education": {
        "desc": "Set the default education focus for this character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_designated_heir": {
        "desc": "Sets one the given direct child character as designated heir.",
        "usage": "set_designated_heir = my_character_scope",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "set_designated_heir_unsafe": {
        "desc": "Sets the given character as designated heir. This is unsafe if the designated heirs loop. Ensure that there is no loop of heirs when using this. This is purely for mod supports and designers should never use this.",
        "usage": "set_designated_heir_unsafe = my_character_scope",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "set_diarch": {
        "desc": "Set target character as new diarch. Requires an active diarchy",
        "usage": "set_diarch = scope:new_diarch",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "set_diarchy_mandate": {
        "desc": "Set mandate for the diarch. Takes mandate type as argument",
        "usage": "scope:diarch = { set_diarchy_mandate = live_long_and_prosper }",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_diarchy_swing": {
        "desc": "Set scales of power swing for the active diarchy",
        "usage": "set_diarchy_swing = 55",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_diarchy_type": {
        "desc": "Set diarthy type for the character. Takes diarchy type as argument",
        "usage": "set_diarchy_type = regency",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_employer": {
        "desc": "Add the scope character to the target character's court",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "set_ethnicity": {
        "desc": "Set the ethnicity for this character, if it is of a different portrait group and they have DNA it will be randomized",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_father": {
        "desc": "sets the father of a character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "set_focus": {
        "desc": "Set the focus for this character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_house": {
        "desc": "Sets the dynasty house of the character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "dynasty_house",
        "notes": null
    },
    "set_immortal_age": {
        "desc": "Changes what age the character became immortal at. Only works if already immortal",
        "usage": "set_immortal_age = 20",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_killer_public": {
        "desc": "Sets the scoped character's killer as being publicly known",
        "usage": "set_killer_public = bool",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_knight_status": {
        "desc": "Sets the knight status of the character to Forced/Default/Disallowed",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_known_bastard_on_pregnancy": {
        "desc": "Sets the child to a known or unknown bastard during pregnancy",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_location": {
        "desc": "Moves the character to a specific location.",
        "usage": "stick_to_location can be used to prevent the safety checks that sometimes return characters to their default location automatically.Usage:   set_location = province\nset_location = { location = province   stick_to_location = yes/no }",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_location_to_default": {
        "desc": "Moves the character to its \"default\" location.This is usually the realm capital for landed characters, or court location for courtiers.",
        "usage": "Usage: set_location_to_default = yes/no",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_mother": {
        "desc": "Sets the mother of a character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "set_num_pregnancy_children": {
        "desc": "Set the number of children",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_override_designated_winner": {
        "desc": "The scoped character will put their beneficiary on the throne if they're the #1 participant if this is called with 'yes'. Call with 'no' to turn it off again. set_override_designate_winner = yes/no",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_owned_legend": {
        "desc": "Sets the owner of the target legend to the scoped character.",
        "usage": "set_owned_legend = legend",
        "supported_scopes": "character",
        "supported_targets": "legend",
        "notes": null
    },
    "set_player_character": {
        "desc": "The scope character's player will now play as the target character. Scope must be player-controlled. Target cannot be player-controlled. Example:set_player_character = scope:title_recipient",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "set_pregnancy_assumed_father": {
        "desc": "Set the assumed father of the pregnancy",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "set_primary_spouse": {
        "desc": "Set the primary spouse of a character",
        "usage": "set_primary_spouse = scope",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "set_primary_title_to": {
        "desc": "Sets the primary title for a character",
        "usage": "set_primary_title_to = <title>",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "set_promoted_legend": {
        "desc": "Adds the scoped character as a promoter of the target legend.",
        "usage": "set_promoted_legend = legend",
        "supported_scopes": "character",
        "supported_targets": "legend",
        "notes": null
    },
    "set_real_father": {
        "desc": "Changes the real father of the scoped character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "set_real_mother": {
        "desc": "Changes the real mother of the scoped character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "set_realm_capital": {
        "desc": "Set a new realm capital",
        "usage": "character = { set_realm_capital = new_title }",
        "supported_scopes": "character",
        "supported_targets": "landed_title",
        "notes": null
    },
    "set_relation_activity_recurrer": {
        "desc": "Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_relation_antiquarian": {
        "desc": "Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_relation_best_friend": {
        "desc": "Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_relation_blood_brother": {
        "desc": "Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_relation_bully": {
        "desc": "Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_relation_court_physician": {
        "desc": "Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_relation_crush": {
        "desc": "Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_relation_event_recurrer": {
        "desc": "Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_relation_favorite_child": {
        "desc": "Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_relation_friend": {
        "desc": "Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_relation_grudge": {
        "desc": "Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_relation_guardian": {
        "desc": "Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_relation_intrigue_mentor": {
        "desc": "Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_relation_intrigue_student": {
        "desc": "Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_relation_lover": {
        "desc": "Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_relation_mentor": {
        "desc": "Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_relation_nemesis": {
        "desc": "Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_relation_nursed_child": {
        "desc": "Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_relation_oaf": {
        "desc": "Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_relation_old_flame": {
        "desc": "Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_relation_potential_friend": {
        "desc": "Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_relation_potential_hook": {
        "desc": "Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_relation_potential_lover": {
        "desc": "Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_relation_potential_rival": {
        "desc": "Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_relation_rival": {
        "desc": "Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_relation_soldier_friend": {
        "desc": "Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_relation_soulmate": {
        "desc": "Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_relation_student": {
        "desc": "Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_relation_victim": {
        "desc": "Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_relation_ward": {
        "desc": "Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_relation_wedding_bad_fertility": {
        "desc": "Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_relation_wedding_good_fertility": {
        "desc": "Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_relation_wedding_very_bad_fertility": {
        "desc": "Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_relation_wedding_very_good_fertility": {
        "desc": "Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_relation_wet_nurse": {
        "desc": "Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_reserved_gold_maximum": {
        "desc": "Set the maximum (and also desired value) for the 'reserved' gold AI budget. This budget is saved up, even before the war chest budget. It will not correct the current gold in that budget to conform to the new maximum.character, set_reserved_gold_maximum = X",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_sexuality": {
        "desc": "Sets the sexuality of the character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_subject_contract_modification_blocked": {
        "desc": "Blocks the subject contract from being modified with regards to being checked by 'subject_contract_is_blocked_from_modification'",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_to_lowborn": {
        "desc": "Set the character to lowborn",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_trait_rank": {
        "desc": "Sets the trait rank = { trait = trait_group rank = new rank }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "set_vassal_contract_modification_blocked": {
        "desc": "Blocks the vassal contract from being modified with regards to being checked by 'vassal_contract_is_blocked_from_modification'",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "spawn_army": {
        "desc": "Spawns an army for this character. If the character is not at war, the regiments will be created, but the army will not be spawned.",
        "usage": "spawn_army = {\nlevies = int/script value # optional, number of men\nmen_at_arms = { # optional, multiple can be specified. Need either levies or MAA\ntype = key\nmen/stacks = int/script value\nlocation = province\norigin = province # optional, location used if not set. This is used for where to base bonuses and the like on\nwar = war # optional. If set, the stack will disband after the war ends\nwar_keep_on_attacker_victory = yes/no # Default: no. Tied to a war. Normally the stack will disband upon victory (if a war is specified), but this parameter prevents that from happening upon attacker victory\ninheritable = yes/no # Default: yes\nuses_supply = yes/no # Default: yes\narmy = army # optional. If set, the stack will merge into this army\nsave_scope_as/save_temporary_scope_as = new_army # optional way to get a reference to the new army. Note this might not be set if the army wasn't spawned (e.g. if the character is not at war)\nname = description # gives the troops a specific name that shows up in interfaces",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": "Usage:"
    },
    "sponsor_inspiration": {
        "desc": "sponsor_inspiration = inspiration",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "inspiration",
        "notes": "Sets the sponsor of the target inspiration to the scoped character"
    },
    "start_default_task": {
        "desc": "Force the Councillor to revert to the default task. Any relevant percentage progress will be lost (even if the councillor was performing the default task already).",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "start_scheme": {
        "desc": "starts a scheme  = { type = X",
        "usage": "contract = (Optional) CONTRACTtarget_character = CHARACTER\ntarget_title = TITLE\ntarget_culture = CULTURE\ntarget_faith = FAITH\ntargets_nothing = yes/no (default no) }\nOnly one target can be specified (or 0 if target_nothing = yes)",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "start_travel_plan": {
        "desc": "Start a travel plan. Saving this as a scope will not work for player characters if they have to use the planner.",
        "usage": "start_travel_plan = {\ndestination = scope:province (repeatable)\ntravel_leader = scope:character (optional)\ncompanion = scope:character (optional & repeatable)\ntravel_with_domicile = no\nplayers_use_planner = yes\nreturn_trip = yes\ncan_cancel_planning = yes\non_arrival_event = event_id\non_arrival_on_action = onaction_id\non_start_event = event_id\non_start_on_action = onaction_id\non_travel_planner_cancel_event = event_id\non_travel_planner_cancel_on_action = onaction_id\non_arrival_destinations = all_but_last/all/first/last",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "start_tributary": {
        "desc": "starts a tributary = {",
        "usage": "contract_group = SUBJECT CONTRACT GROUPsuzerain = CHARACTER",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "start_war": {
        "desc": "starts a war  = { casus_belli/cb = X target = Y claimant = Z target_title = W1 target_title = W2 ... } where X is a casus belli type, Y is the target character, Z i the (optional) claimant, W1, W2.... are targeted titles.",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": "If there are no title targets, the effect will pick one of possible title targets."
    },
    "stop_promoting_legend": {
        "desc": "Remove the scoped character as the owner/promoter of their current promoted legend if they have one.",
        "usage": "stop_promoting_legend = yes",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "store_localized_text_in_death": {
        "desc": "Makes a piece of localized text with the given key be stored on the character even after death, you should use this sparingly to avoid save bloat and use 'remove_localized_text' if you no longer need itsaves",
        "usage": "store_localized_text_in_death = key",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "stress_impact": {
        "desc": "Stress impact according to specified traits (trait = value), use base = value for a base value that's always added",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "take_hostage": {
        "desc": "Take target character as a hostagescope:warden = { take_hostage = scope:hostage }",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "tributary_contract_set_obligation_level": {
        "desc": "change the obligation level of the scoped character's tributary contract",
        "usage": "vassal_contract_set_obligation_level = { type = name level = 1 } # index to obligation level\nvassal_contract_set_obligation_level = { type = name level = herd_obligation_low }\nvassal_contract_set_obligation_level = { type = name level = scope:obligation }",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "try_start_diarchy": {
        "desc": "Attempts to start a diarchy for the character. Takes diarchy type as argument",
        "usage": "Use `exists = my_ruler_scope.diarch` to test if it's valid afterwards if needed.\nstart_diarchy = regency",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": "NB: this effect will silently fail if a valid diarch cannot be found."
    },
    "unlearn_court_language_of": {
        "desc": "The character unlearns the court language of the target character. Cannot unlearn the language of your cultureunlearn_court_language_of = scope:target_character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "unlearn_language": {
        "desc": "The character unlearns the language. Cannot unlearn the language of your cultureunlearn_language = language_norwegian",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "unlearn_language_of_culture": {
        "desc": "The character unlearns the language of the target culture. Cannot unlearn the language of your cultureunlearn_language_of_culture = scope:target_culture",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "culture",
        "notes": null
    },
    "use_hook": {
        "desc": "Uses a hook a character has (removes if weak, puts on cooldown if strong), use_hook = some_character",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "vassal_contract_decrease_obligation_level": {
        "desc": "decrease the obligation level of the scoped character's vassal contract",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "vassal_contract_increase_obligation_level": {
        "desc": "increase the obligation level of the scoped character's vassal contract",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "vassal_contract_set_obligation_level": {
        "desc": "change the obligation level of the scoped character's vassal contract",
        "usage": "vassal_contract_set_obligation_level = { type = name level = 1 } # index to obligation level\nvassal_contract_set_obligation_level = { type = name level = feudal_obligation_low }\nvassal_contract_set_obligation_level = { type = name level = scope:obligation }",
        "supported_scopes": "character",
        "supported_targets": null,
        "notes": null
    },
    "visit_court_of": {
        "desc": "Add the scope character as the target character's guest",
        "usage": "",
        "supported_scopes": "character",
        "supported_targets": "character",
        "notes": null
    },
    "every_combat_side": {
        "desc": "Iterate over both sides ( attacker and defender ) of the given combat",
        "usage": "every_combat_side = { limit = { <triggers> } <effects> }",
        "supported_scopes": "combat",
        "supported_targets": "combat_side",
        "notes": null
    },
    "ordered_combat_side": {
        "desc": "Iterate over both sides ( attacker and defender ) of the given combat",
        "usage": "ordered_combat_side = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "combat",
        "supported_targets": "combat_side",
        "notes": null
    },
    "random_combat_side": {
        "desc": "Iterate over both sides ( attacker and defender ) of the given combat",
        "usage": "random_combat_side = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "combat",
        "supported_targets": "combat_side",
        "notes": null
    },
    "add_county_modifier": {
        "desc": "Add a modifier to a county",
        "usage": "add_county_modifier = name\nadd_county_modifier = { modifier = name days/weeks/months/years = int }",
        "supported_scopes": "landed_title",
        "supported_targets": null,
        "notes": null
    },
    "change_appointment_investment": {
        "desc": "Increase appointment score of a character for a title",
        "usage": "change_appointment_investment = {\ntarget = scope:target_character\ninvestor = scope:investor_character # Optional, the character who made this investment\nvalue = <script_value>",
        "supported_scopes": "landed_title",
        "supported_targets": null,
        "notes": null
    },
    "change_county_control": {
        "desc": "Changes the county control of a title. If the title has higher tier than county, the effect will propagate down to all counties below it.",
        "usage": "",
        "supported_scopes": "landed_title",
        "supported_targets": null,
        "notes": null
    },
    "change_county_fertility": {
        "desc": "Changes the County Fertility of the scoped county title by the given amount",
        "usage": "scope:county = { change_county_fertility = 5.5 }",
        "supported_scopes": "landed_title",
        "supported_targets": null,
        "notes": null
    },
    "change_de_jure_drift_progress": {
        "desc": "Change the progress of de jure drift of a title<drifting_title> = { change_de_jure_drift_progress = {    target = <drift_target_title>    values = <progress_change_value> } }",
        "usage": "",
        "supported_scopes": "landed_title",
        "supported_targets": null,
        "notes": null
    },
    "change_development_level": {
        "desc": "Changes the development level of a title. If the title has higher tier than county, the effect will propagate down to all counties below it.",
        "usage": "",
        "supported_scopes": "landed_title",
        "supported_targets": null,
        "notes": null
    },
    "change_development_progress": {
        "desc": "Changes the development progress of a title. If the title has higher tier than county, the effect will propagate down to all counties below it.",
        "usage": "",
        "supported_scopes": "landed_title",
        "supported_targets": null,
        "notes": null
    },
    "change_development_progress_with_overflow": {
        "desc": "Changes the development progress of a title. If the title has higher tier than county, the effect will propagate down to all counties below it. Will overflow, so adding +100 to a county with 50 progress left will increase the level by 1 and result in 50 progress towards the next level",
        "usage": "",
        "supported_scopes": "landed_title",
        "supported_targets": null,
        "notes": null
    },
    "clear_title_laws": {
        "desc": "remove all title laws from the scoped title. DOES NOT apply law removal costs and effects.",
        "usage": "clear_title_laws = yes",
        "supported_scopes": "landed_title",
        "supported_targets": null,
        "notes": null
    },
    "clear_title_laws_effects": {
        "desc": "remove all title laws from the scoped title. DOES apply law removal costs and effects.",
        "usage": "clear_title_laws_effects = yes",
        "supported_scopes": "landed_title",
        "supported_targets": null,
        "notes": null
    },
    "copy_title_history": {
        "desc": "Copy title history from another title",
        "usage": "copy_title_history = source_title",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_claimant": {
        "desc": "Iterate through all claimants to title. parameters: explicit = yes/no/all - default yes",
        "usage": "every_claimant = { limit = { <triggers> } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "character",
        "notes": null
    },
    "every_connected_county": {
        "desc": "Iterate through all counties connected to this one. Is based on top liege",
        "usage": "any/every/whatever_connectec_county = {\nmax_naval_distance = 500\nallow_one_county_land_gap = yes\nevery_connected_county = { limit = { <triggers> } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_controlled_faith": {
        "desc": "Iterate through all faiths headed by a title",
        "usage": "every_controlled_faith = { limit = { <triggers> } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "faith",
        "notes": null
    },
    "every_controlled_title_maa_regiment": {
        "desc": "Iterate through controlled title regiments",
        "usage": "every_controlled_title_maa_regiment = { limit = { <triggers> } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "regiment",
        "notes": null
    },
    "every_county_province": {
        "desc": "Iterate through all provinces in a county",
        "usage": "every_county_province = { limit = { <triggers> } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "province",
        "notes": null
    },
    "every_county_situation": {
        "desc": "Iterate through all situations that a county is involved in.",
        "usage": "every_county_situation = { limit = { <triggers> } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "situation",
        "notes": null
    },
    "every_county_situation_sub_region": {
        "desc": "Iterate through all situation sub-regions that a county is involved in.",
        "usage": "every_county_situation_sub_region = { limit = { <triggers> } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "situation_sub_region",
        "notes": null
    },
    "every_county_struggle": {
        "desc": "Iterate through all struggles that a county is involved in.",
        "usage": "every_county_struggle = { limit = { <triggers> } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "struggle",
        "notes": null
    },
    "every_de_jure_county": {
        "desc": "Iterate through all counties within this dejure title",
        "usage": "every_de_jure_county = { limit = { <triggers> } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_de_jure_county_holder": {
        "desc": "Iterate through all characters directly holding counties within this dejure title",
        "usage": "every_de_jure_county_holder = { limit = { <triggers> } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "character",
        "notes": null
    },
    "every_de_jure_top_liege": {
        "desc": "Iterate through all top lieges of the counts within this dejure title",
        "usage": "every_de_jure_top_liege = { limit = { <triggers> } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "character",
        "notes": null
    },
    "every_dejure_vassal_title_holder": {
        "desc": "Iterate through all the vassal holders of the title",
        "usage": "every_dejure_vassal_title_holder = { limit = { <triggers> } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "character",
        "notes": null
    },
    "every_direct_de_facto_vassal_title": {
        "desc": "Iterate through all de facto vassal titles",
        "usage": "every_direct_de_facto_vassal_title = { limit = { <triggers> } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_direct_de_jure_vassal_title": {
        "desc": "Iterate through the all de jure vassals titles",
        "usage": "every_direct_de_jure_vassal_title = { limit = { <triggers> } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_election_candidate": {
        "desc": "Iterate through all characters who are valid candidates in an election for a title",
        "usage": "every_election_candidate = { limit = { <triggers> } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "character",
        "notes": null
    },
    "every_elector": {
        "desc": "Iterate through all characters who are valid electors in an election for a title",
        "usage": "every_elector = { limit = { <triggers> } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "character",
        "notes": null
    },
    "every_important_location_for_title": {
        "desc": "Iterate through all counties that are important for the scoped title",
        "usage": "every_important_location_for_title = { limit = { <triggers> } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_in_de_facto_hierarchy": {
        "desc": "Iterate through the title itself, all de facto vassals, and below. The continue trigger specifies whether to recursively iterate through the vassal's vassal",
        "usage": "..._de_jure_vassal_and_below = { continue = { conditions } }\nevery_in_de_facto_hierarchy = { limit = { <triggers> } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": "This is unrelated to the limit; if the limit is met it is added to the list, but its vassals will get checked even if the limit isn't met as long as the 'continue' trigger is"
    },
    "every_in_de_jure_hierarchy": {
        "desc": "Iterate through the title itself, all de jure vassals, and below. The continue trigger specifies whether to recursively iterate through the vassal's vassal",
        "usage": "..._de_jure_vassal_and_below = { continue = { conditions } }\nevery_in_de_jure_hierarchy = { limit = { <triggers> } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": "This is unrelated to the limit; if the limit is met it is added to the list, but its vassals will get checked even if the limit isn't met as long as the 'continue' trigger is"
    },
    "every_neighboring_county": {
        "desc": "Iterate through all neighboring counties. Can only be used in county scope",
        "usage": "every_neighboring_county = { limit = { <triggers> } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_owned_title_maa_regiment": {
        "desc": "Iterate through owned title MaA regiments",
        "usage": "every_owned_title_maa_regiment = { limit = { <triggers> } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "regiment",
        "notes": null
    },
    "every_past_holder": {
        "desc": "Iterate through all past owners of a title from earliest to latest",
        "usage": "every_past_holder = { limit = { <triggers> } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "character",
        "notes": null
    },
    "every_past_holder_reversed": {
        "desc": "Iterate through all past owners of a title from latest to earliest",
        "usage": "every_past_holder_reversed = { limit = { <triggers> } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "character",
        "notes": null
    },
    "every_succession_appointment_investors": {
        "desc": "Iterate through all investors of target candidate within the scoped title. Optionally specify a value to filter by investment amount",
        "usage": "scope:landed_title = {\nany/every/ordered/random_succession_appointment_investors = {\ncandidate = scope:character\nvalue = 100\t\t# only have characters that\nadd = 10\t\t# have invested this much.\nevery_succession_appointment_investors = { limit = { <triggers> } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "character",
        "notes": null
    },
    "every_this_title_or_de_jure_above": {
        "desc": "Iterate through this title and all its dejure liege titles",
        "usage": "every_this_title_or_de_jure_above = { limit = { <triggers> } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_title_heir": {
        "desc": "Line of succession for the scoped title",
        "usage": "every_title_heir = { limit = { <triggers> } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "character",
        "notes": null
    },
    "every_title_interested_in_location": {
        "desc": "Iterate through titles that consider scoped county an important location",
        "usage": "every_title_interested_in_location = { limit = { <triggers> } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_title_joined_faction": {
        "desc": "Iterate through all factions joined the scope landed title",
        "usage": "every_title_joined_faction = { limit = { <triggers> } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "faction",
        "notes": null
    },
    "every_title_maa_regiment": {
        "desc": "Iterate through title all MaA regiments",
        "usage": "every_title_maa_regiment = { limit = { <triggers> } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "regiment",
        "notes": null
    },
    "every_title_to_title_neighboring_and_across_water_county": {
        "desc": "Scopes from a title to a neighboring county (incl. across water, looking trough the de Jure lieges)",
        "usage": "every_title_to_title_neighboring_and_across_water_county = { limit = { <triggers> } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_title_to_title_neighboring_and_across_water_duchy": {
        "desc": "Scopes from a title to a neighboring duchy (incl. across water, looking trough the de Jure lieges)",
        "usage": "every_title_to_title_neighboring_and_across_water_duchy = { limit = { <triggers> } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_title_to_title_neighboring_and_across_water_empire": {
        "desc": "Scopes from a title to a neighboring empire (incl. across water, looking trough the de Jure lieges)",
        "usage": "every_title_to_title_neighboring_and_across_water_empire = { limit = { <triggers> } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_title_to_title_neighboring_and_across_water_kingdom": {
        "desc": "Scopes from a title to a neighboring kingdom (incl. across water, looking trough the de Jure lieges)",
        "usage": "every_title_to_title_neighboring_and_across_water_kingdom = { limit = { <triggers> } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_title_to_title_neighboring_county": {
        "desc": "Scopes from a title to a neighboring county (looking trough the de Jure lieges)",
        "usage": "every_title_to_title_neighboring_county = { limit = { <triggers> } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_title_to_title_neighboring_duchy": {
        "desc": "Scopes from a title to a neighboring duchy (looking trough the de Jure lieges)",
        "usage": "every_title_to_title_neighboring_duchy = { limit = { <triggers> } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_title_to_title_neighboring_empire": {
        "desc": "Scopes from a title to a neighboring empire (looking trough the de Jure lieges)",
        "usage": "every_title_to_title_neighboring_empire = { limit = { <triggers> } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_title_to_title_neighboring_kingdom": {
        "desc": "Scopes from a title to a neighboring kingdom (looking trough the de Jure lieges)",
        "usage": "every_title_to_title_neighboring_kingdom = { limit = { <triggers> } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "lease_out_to": {
        "desc": "Lease out the scoped title",
        "usage": "lease_out_to = scope:a_holy_order",
        "supported_scopes": "landed_title",
        "supported_targets": "holy_order",
        "notes": null
    },
    "ordered_claimant": {
        "desc": "Iterate through all claimants to title. parameters: explicit = yes/no/all - default yes",
        "usage": "ordered_claimant = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_connected_county": {
        "desc": "Iterate through all counties connected to this one. Is based on top liege",
        "usage": "any/every/whatever_connectec_county = {\nmax_naval_distance = 500\nallow_one_county_land_gap = yes\nordered_connected_county = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_controlled_faith": {
        "desc": "Iterate through all faiths headed by a title",
        "usage": "ordered_controlled_faith = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "faith",
        "notes": null
    },
    "ordered_controlled_title_maa_regiment": {
        "desc": "Iterate through controlled title regiments",
        "usage": "ordered_controlled_title_maa_regiment = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "regiment",
        "notes": null
    },
    "ordered_county_province": {
        "desc": "Iterate through all provinces in a county",
        "usage": "ordered_county_province = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "province",
        "notes": null
    },
    "ordered_county_situation": {
        "desc": "Iterate through all situations that a county is involved in.",
        "usage": "ordered_county_situation = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "situation",
        "notes": null
    },
    "ordered_county_situation_sub_region": {
        "desc": "Iterate through all situation sub-regions that a county is involved in.",
        "usage": "ordered_county_situation_sub_region = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "situation_sub_region",
        "notes": null
    },
    "ordered_county_struggle": {
        "desc": "Iterate through all struggles that a county is involved in.",
        "usage": "ordered_county_struggle = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "struggle",
        "notes": null
    },
    "ordered_de_jure_county": {
        "desc": "Iterate through all counties within this dejure title",
        "usage": "ordered_de_jure_county = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_de_jure_county_holder": {
        "desc": "Iterate through all characters directly holding counties within this dejure title",
        "usage": "ordered_de_jure_county_holder = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_de_jure_top_liege": {
        "desc": "Iterate through all top lieges of the counts within this dejure title",
        "usage": "ordered_de_jure_top_liege = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_dejure_vassal_title_holder": {
        "desc": "Iterate through all the vassal holders of the title",
        "usage": "ordered_dejure_vassal_title_holder = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_direct_de_facto_vassal_title": {
        "desc": "Iterate through all de facto vassal titles",
        "usage": "ordered_direct_de_facto_vassal_title = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_direct_de_jure_vassal_title": {
        "desc": "Iterate through the all de jure vassals titles",
        "usage": "ordered_direct_de_jure_vassal_title = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_election_candidate": {
        "desc": "Iterate through all characters who are valid candidates in an election for a title",
        "usage": "ordered_election_candidate = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_elector": {
        "desc": "Iterate through all characters who are valid electors in an election for a title",
        "usage": "ordered_elector = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_important_location_for_title": {
        "desc": "Iterate through all counties that are important for the scoped title",
        "usage": "ordered_important_location_for_title = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_in_de_facto_hierarchy": {
        "desc": "Iterate through the title itself, all de facto vassals, and below. The continue trigger specifies whether to recursively iterate through the vassal's vassal",
        "usage": "..._de_jure_vassal_and_below = { continue = { conditions } }\nordered_in_de_facto_hierarchy = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": "This is unrelated to the limit; if the limit is met it is added to the list, but its vassals will get checked even if the limit isn't met as long as the 'continue' trigger is"
    },
    "ordered_in_de_jure_hierarchy": {
        "desc": "Iterate through the title itself, all de jure vassals, and below. The continue trigger specifies whether to recursively iterate through the vassal's vassal",
        "usage": "..._de_jure_vassal_and_below = { continue = { conditions } }\nordered_in_de_jure_hierarchy = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": "This is unrelated to the limit; if the limit is met it is added to the list, but its vassals will get checked even if the limit isn't met as long as the 'continue' trigger is"
    },
    "ordered_neighboring_county": {
        "desc": "Iterate through all neighboring counties. Can only be used in county scope",
        "usage": "ordered_neighboring_county = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_owned_title_maa_regiment": {
        "desc": "Iterate through owned title MaA regiments",
        "usage": "ordered_owned_title_maa_regiment = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "regiment",
        "notes": null
    },
    "ordered_past_holder": {
        "desc": "Iterate through all past owners of a title from earliest to latest",
        "usage": "ordered_past_holder = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_past_holder_reversed": {
        "desc": "Iterate through all past owners of a title from latest to earliest",
        "usage": "ordered_past_holder_reversed = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_succession_appointment_investors": {
        "desc": "Iterate through all investors of target candidate within the scoped title. Optionally specify a value to filter by investment amount",
        "usage": "scope:landed_title = {\nany/every/ordered/random_succession_appointment_investors = {\ncandidate = scope:character\nvalue = 100\t\t# only have characters that\nadd = 10\t\t# have invested this much.\nordered_succession_appointment_investors = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_this_title_or_de_jure_above": {
        "desc": "Iterate through this title and all its dejure liege titles",
        "usage": "ordered_this_title_or_de_jure_above = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_title_heir": {
        "desc": "Line of succession for the scoped title",
        "usage": "ordered_title_heir = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_title_interested_in_location": {
        "desc": "Iterate through titles that consider scoped county an important location",
        "usage": "ordered_title_interested_in_location = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_title_joined_faction": {
        "desc": "Iterate through all factions joined the scope landed title",
        "usage": "ordered_title_joined_faction = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "faction",
        "notes": null
    },
    "ordered_title_maa_regiment": {
        "desc": "Iterate through title all MaA regiments",
        "usage": "ordered_title_maa_regiment = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "regiment",
        "notes": null
    },
    "ordered_title_to_title_neighboring_and_across_water_county": {
        "desc": "Scopes from a title to a neighboring county (incl. across water, looking trough the de Jure lieges)",
        "usage": "ordered_title_to_title_neighboring_and_across_water_county = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_title_to_title_neighboring_and_across_water_duchy": {
        "desc": "Scopes from a title to a neighboring duchy (incl. across water, looking trough the de Jure lieges)",
        "usage": "ordered_title_to_title_neighboring_and_across_water_duchy = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_title_to_title_neighboring_and_across_water_empire": {
        "desc": "Scopes from a title to a neighboring empire (incl. across water, looking trough the de Jure lieges)",
        "usage": "ordered_title_to_title_neighboring_and_across_water_empire = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_title_to_title_neighboring_and_across_water_kingdom": {
        "desc": "Scopes from a title to a neighboring kingdom (incl. across water, looking trough the de Jure lieges)",
        "usage": "ordered_title_to_title_neighboring_and_across_water_kingdom = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_title_to_title_neighboring_county": {
        "desc": "Scopes from a title to a neighboring county (looking trough the de Jure lieges)",
        "usage": "ordered_title_to_title_neighboring_county = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_title_to_title_neighboring_duchy": {
        "desc": "Scopes from a title to a neighboring duchy (looking trough the de Jure lieges)",
        "usage": "ordered_title_to_title_neighboring_duchy = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_title_to_title_neighboring_empire": {
        "desc": "Scopes from a title to a neighboring empire (looking trough the de Jure lieges)",
        "usage": "ordered_title_to_title_neighboring_empire = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_title_to_title_neighboring_kingdom": {
        "desc": "Scopes from a title to a neighboring kingdom (looking trough the de Jure lieges)",
        "usage": "ordered_title_to_title_neighboring_kingdom = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_claimant": {
        "desc": "Iterate through all claimants to title. parameters: explicit = yes/no/all - default yes",
        "usage": "random_claimant = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "character",
        "notes": null
    },
    "random_connected_county": {
        "desc": "Iterate through all counties connected to this one. Is based on top liege",
        "usage": "any/every/whatever_connectec_county = {\nmax_naval_distance = 500\nallow_one_county_land_gap = yes\nrandom_connected_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_controlled_faith": {
        "desc": "Iterate through all faiths headed by a title",
        "usage": "random_controlled_faith = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "faith",
        "notes": null
    },
    "random_controlled_title_maa_regiment": {
        "desc": "Iterate through controlled title regiments",
        "usage": "random_controlled_title_maa_regiment = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "regiment",
        "notes": null
    },
    "random_county_province": {
        "desc": "Iterate through all provinces in a county",
        "usage": "random_county_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "province",
        "notes": null
    },
    "random_county_situation": {
        "desc": "Iterate through all situations that a county is involved in.",
        "usage": "random_county_situation = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "situation",
        "notes": null
    },
    "random_county_situation_sub_region": {
        "desc": "Iterate through all situation sub-regions that a county is involved in.",
        "usage": "random_county_situation_sub_region = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "situation_sub_region",
        "notes": null
    },
    "random_county_struggle": {
        "desc": "Iterate through all struggles that a county is involved in.",
        "usage": "random_county_struggle = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "struggle",
        "notes": null
    },
    "random_de_jure_county": {
        "desc": "Iterate through all counties within this dejure title",
        "usage": "random_de_jure_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_de_jure_county_holder": {
        "desc": "Iterate through all characters directly holding counties within this dejure title",
        "usage": "random_de_jure_county_holder = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "character",
        "notes": null
    },
    "random_de_jure_top_liege": {
        "desc": "Iterate through all top lieges of the counts within this dejure title",
        "usage": "random_de_jure_top_liege = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "character",
        "notes": null
    },
    "random_dejure_vassal_title_holder": {
        "desc": "Iterate through all the vassal holders of the title",
        "usage": "random_dejure_vassal_title_holder = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "character",
        "notes": null
    },
    "random_direct_de_facto_vassal_title": {
        "desc": "Iterate through all de facto vassal titles",
        "usage": "random_direct_de_facto_vassal_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_direct_de_jure_vassal_title": {
        "desc": "Iterate through the all de jure vassals titles",
        "usage": "random_direct_de_jure_vassal_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_election_candidate": {
        "desc": "Iterate through all characters who are valid candidates in an election for a title",
        "usage": "random_election_candidate = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "character",
        "notes": null
    },
    "random_elector": {
        "desc": "Iterate through all characters who are valid electors in an election for a title",
        "usage": "random_elector = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "character",
        "notes": null
    },
    "random_important_location_for_title": {
        "desc": "Iterate through all counties that are important for the scoped title",
        "usage": "random_important_location_for_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_in_de_facto_hierarchy": {
        "desc": "Iterate through the title itself, all de facto vassals, and below. The continue trigger specifies whether to recursively iterate through the vassal's vassal",
        "usage": "..._de_jure_vassal_and_below = { continue = { conditions } }\nrandom_in_de_facto_hierarchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": "This is unrelated to the limit; if the limit is met it is added to the list, but its vassals will get checked even if the limit isn't met as long as the 'continue' trigger is"
    },
    "random_in_de_jure_hierarchy": {
        "desc": "Iterate through the title itself, all de jure vassals, and below. The continue trigger specifies whether to recursively iterate through the vassal's vassal",
        "usage": "..._de_jure_vassal_and_below = { continue = { conditions } }\nrandom_in_de_jure_hierarchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": "This is unrelated to the limit; if the limit is met it is added to the list, but its vassals will get checked even if the limit isn't met as long as the 'continue' trigger is"
    },
    "random_neighboring_county": {
        "desc": "Iterate through all neighboring counties. Can only be used in county scope",
        "usage": "random_neighboring_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_owned_title_maa_regiment": {
        "desc": "Iterate through owned title MaA regiments",
        "usage": "random_owned_title_maa_regiment = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "regiment",
        "notes": null
    },
    "random_past_holder": {
        "desc": "Iterate through all past owners of a title from earliest to latest",
        "usage": "random_past_holder = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "character",
        "notes": null
    },
    "random_past_holder_reversed": {
        "desc": "Iterate through all past owners of a title from latest to earliest",
        "usage": "random_past_holder_reversed = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "character",
        "notes": null
    },
    "random_succession_appointment_investors": {
        "desc": "Iterate through all investors of target candidate within the scoped title. Optionally specify a value to filter by investment amount",
        "usage": "scope:landed_title = {\nany/every/ordered/random_succession_appointment_investors = {\ncandidate = scope:character\nvalue = 100\t\t# only have characters that\nadd = 10\t\t# have invested this much.\nrandom_succession_appointment_investors = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "character",
        "notes": null
    },
    "random_this_title_or_de_jure_above": {
        "desc": "Iterate through this title and all its dejure liege titles",
        "usage": "random_this_title_or_de_jure_above = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_title_heir": {
        "desc": "Line of succession for the scoped title",
        "usage": "random_title_heir = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "character",
        "notes": null
    },
    "random_title_interested_in_location": {
        "desc": "Iterate through titles that consider scoped county an important location",
        "usage": "random_title_interested_in_location = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_title_joined_faction": {
        "desc": "Iterate through all factions joined the scope landed title",
        "usage": "random_title_joined_faction = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "faction",
        "notes": null
    },
    "random_title_maa_regiment": {
        "desc": "Iterate through title all MaA regiments",
        "usage": "random_title_maa_regiment = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "regiment",
        "notes": null
    },
    "random_title_to_title_neighboring_and_across_water_county": {
        "desc": "Scopes from a title to a neighboring county (incl. across water, looking trough the de Jure lieges)",
        "usage": "random_title_to_title_neighboring_and_across_water_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_title_to_title_neighboring_and_across_water_duchy": {
        "desc": "Scopes from a title to a neighboring duchy (incl. across water, looking trough the de Jure lieges)",
        "usage": "random_title_to_title_neighboring_and_across_water_duchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_title_to_title_neighboring_and_across_water_empire": {
        "desc": "Scopes from a title to a neighboring empire (incl. across water, looking trough the de Jure lieges)",
        "usage": "random_title_to_title_neighboring_and_across_water_empire = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_title_to_title_neighboring_and_across_water_kingdom": {
        "desc": "Scopes from a title to a neighboring kingdom (incl. across water, looking trough the de Jure lieges)",
        "usage": "random_title_to_title_neighboring_and_across_water_kingdom = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_title_to_title_neighboring_county": {
        "desc": "Scopes from a title to a neighboring county (looking trough the de Jure lieges)",
        "usage": "random_title_to_title_neighboring_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_title_to_title_neighboring_duchy": {
        "desc": "Scopes from a title to a neighboring duchy (looking trough the de Jure lieges)",
        "usage": "random_title_to_title_neighboring_duchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_title_to_title_neighboring_empire": {
        "desc": "Scopes from a title to a neighboring empire (looking trough the de Jure lieges)",
        "usage": "random_title_to_title_neighboring_empire = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_title_to_title_neighboring_kingdom": {
        "desc": "Scopes from a title to a neighboring kingdom (looking trough the de Jure lieges)",
        "usage": "random_title_to_title_neighboring_kingdom = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "raze_county": {
        "desc": "Changes the county capital province holding to the designated type. If purge_secondary_holdings = yes, then all secondary province holdings in the county will be destroyed, unless their holding type is excluded with excluded_holding_type = <holding_type>",
        "usage": "scope:county_title = {\nraze_county = {\nholding_type = nomad_holding\npurge_secondary_holdings = yes (optional, default = no)\nexcluded_holding_type = temple_holding (optional, can be repeated)",
        "supported_scopes": "landed_title",
        "supported_targets": null,
        "notes": null
    },
    "remove_all_county_modifier_instances": {
        "desc": "Remove all instances of a modifier from a county",
        "usage": "remove_all_county_modifier_instances = name",
        "supported_scopes": "landed_title",
        "supported_targets": null,
        "notes": null
    },
    "remove_county_modifier": {
        "desc": "Remove a modifier from a county",
        "usage": "remove_county_modifier = name",
        "supported_scopes": "landed_title",
        "supported_targets": null,
        "notes": null
    },
    "remove_important_location": {
        "desc": "Scoped county is no longer important for anyone",
        "usage": "scope:county = {\nremove_important_location = yes",
        "supported_scopes": "landed_title",
        "supported_targets": null,
        "notes": null
    },
    "remove_title_from_important_location": {
        "desc": "Scoped county is no longer important for the target title",
        "usage": "scope:county = {\nremove_title_from_important_location = scope:title",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "reset_title_name": {
        "desc": "Sets the name and adjective of the scoped title back to being based on its key. Won't cause the prefix to change",
        "usage": "reset_title_name = yes",
        "supported_scopes": "landed_title",
        "supported_targets": null,
        "notes": null
    },
    "reset_title_prefix": {
        "desc": "Sets the prefix of the scoped title back to being based on its key. Won't cause its adjective or name to change",
        "usage": "reset_title_prefix = yes",
        "supported_scopes": "landed_title",
        "supported_targets": null,
        "notes": null
    },
    "revoke_lease": {
        "desc": "Revoke the lease of the scoped title",
        "usage": "revoke_lease = yes",
        "supported_scopes": "landed_title",
        "supported_targets": null,
        "notes": null
    },
    "set_always_follows_primary_heir": {
        "desc": "Sets if the title should always go to the primary heir in partition succession",
        "usage": "set_always_follows_primary_heir = yes",
        "supported_scopes": "landed_title",
        "supported_targets": null,
        "notes": null
    },
    "set_can_be_named_after_dynasty": {
        "desc": "Sets if the title can be named after it's holder's dynasty. set_can_be_named_after_dynasty_effect = no",
        "usage": "",
        "supported_scopes": "landed_title",
        "supported_targets": null,
        "notes": null
    },
    "set_can_use_nomadic_naming": {
        "desc": "Sets if the title can use the dynamic naming for nomads. set_can_use_nomadic_naming = no",
        "usage": "",
        "supported_scopes": "landed_title",
        "supported_targets": null,
        "notes": null
    },
    "set_capital_barony": {
        "desc": "Sets scoped barony to be the county capital",
        "usage": "set_capital_barony = yes",
        "supported_scopes": "landed_title",
        "supported_targets": null,
        "notes": null
    },
    "set_capital_county": {
        "desc": "Sets the capital county of the title to the target county",
        "usage": "set_capital_county = <some county title>",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "set_color_from_title": {
        "desc": "Sets the color of the title to the same as the target title (shifted very slightly to not be identical)",
        "usage": "set_color_from_title = <some title>",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "set_county_culture": {
        "desc": "sets the culture of a county",
        "usage": "set_county_culture = culture:english/root.character_culture",
        "supported_scopes": "landed_title",
        "supported_targets": "culture",
        "notes": "usage:"
    },
    "set_county_faith": {
        "desc": "Changes what faith a county has",
        "usage": "",
        "supported_scopes": "landed_title",
        "supported_targets": "faith",
        "notes": null
    },
    "set_de_jure_liege_title": {
        "desc": "Set a new DeJure liege title",
        "usage": "set_de_jure_liege_title = new_de_jure_liege",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "set_definitive_form": {
        "desc": "Sets if the title should use a definitive form name (no 'Kingdom of')",
        "usage": "set_definitive_form = yes",
        "supported_scopes": "landed_title",
        "supported_targets": null,
        "notes": null
    },
    "set_delete_on_destroy": {
        "desc": "Sets if the title should be deleted from the gamestate completely when it is destroyed. set_delete_on_destroy = yes",
        "usage": "",
        "supported_scopes": "landed_title",
        "supported_targets": null,
        "notes": null
    },
    "set_destroy_if_invalid_heir": {
        "desc": "Sets if the title should be destroyed on succession if there's no heir matching its restrictions. set_destroy_if_invalid_heir = yes",
        "usage": "",
        "supported_scopes": "landed_title",
        "supported_targets": null,
        "notes": null
    },
    "set_destroy_on_gain_same_tier": {
        "desc": "Sets if the title should be deleted from the gamestate completely when character gains or create a new title with the same tier.set_destroy_on_gain_same_tier = yes",
        "usage": "",
        "supported_scopes": "landed_title",
        "supported_targets": null,
        "notes": null
    },
    "set_destroy_on_succession": {
        "desc": "Sets if the title should be destroyed on succession. set_destroy_on_succession = yes",
        "usage": "",
        "supported_scopes": "landed_title",
        "supported_targets": null,
        "notes": null
    },
    "set_important_location": {
        "desc": "Scoped county is set as important for the target title",
        "usage": "scope:county = {\nset_important_location = {\ntitle = scope:higher_tier_title\nenter_realm_event = event_name\nenter_realm_on_action = onaction_name\nleave_realm_event = event_name\nleave_realm_on_action = onaction_name",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "set_landless_title": {
        "desc": "Sets if the title is landless (can be held by rulers with no land)",
        "usage": "set_landless_title = yes",
        "supported_scopes": "landed_title",
        "supported_targets": null,
        "notes": null
    },
    "set_no_automatic_claims": {
        "desc": "Sets if the title should disallow automatic claims (meaning claims will only be added by script, and by pressed claims being inherited).",
        "usage": "set_no_automatic_claims = yes",
        "supported_scopes": "landed_title",
        "supported_targets": null,
        "notes": null
    },
    "set_noble_family_title": {
        "desc": "Change if the scoped title is for a noble family, allowing landless playable. Title must be at least a duchy",
        "usage": "",
        "supported_scopes": "landed_title",
        "supported_targets": null,
        "notes": null
    },
    "set_state_faith": {
        "desc": "Set the State Faith of a Title whose holder has the state_faith government rule",
        "usage": "<landed_title> = { set_state_faith = <faith> }",
        "supported_scopes": "landed_title",
        "supported_targets": "faith",
        "notes": null
    },
    "set_title_name": {
        "desc": "sets the name (localization key) of the scoped title. The adjective will be constructed by adding '_adj' to the localisation key. Won't cause the prefix to change",
        "usage": "set_title_name = TEST_NAME_PLEASE_IGNORE",
        "supported_scopes": "landed_title",
        "supported_targets": null,
        "notes": null
    },
    "set_title_prefix": {
        "desc": "sets the prefix of the scoped title. Won't cause its name or adjective to change",
        "usage": "set_title_prefix = PREFIX_THE",
        "supported_scopes": "landed_title",
        "supported_targets": null,
        "notes": null
    },
    "title_create_faction": {
        "desc": "the scoped landed title creates a faction of the specified type against the specified target, title_create_faction = { type = X target = Y }",
        "usage": "",
        "supported_scopes": "landed_title",
        "supported_targets": null,
        "notes": null
    },
    "title_join_faction": {
        "desc": "the landed title in the scope joins the assigned faction",
        "usage": "",
        "supported_scopes": "landed_title",
        "supported_targets": "faction",
        "notes": null
    },
    "title_leave_faction": {
        "desc": "the title in the scope leaves the assigned faction",
        "usage": "",
        "supported_scopes": "landed_title",
        "supported_targets": "faction",
        "notes": null
    },
    "transfer_owned_maa_control": {
        "desc": "Transfers control of the scoped title's owned MaA to the target title",
        "usage": "",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "transfer_title_maa_ownership": {
        "desc": "Transfers ownership of the scoped title's owned MaA to the target title",
        "usage": "",
        "supported_scopes": "landed_title",
        "supported_targets": "landed_title",
        "notes": null
    },
    "update_dynamic_coa": {
        "desc": "update_dynamic_coa = yes",
        "usage": "",
        "supported_scopes": "landed_title",
        "supported_targets": null,
        "notes": "Updates the dynamic coat of arms definition of a given title picking a new one and overwriting the existing set coat of arms with it if picked"
    },
    "add_faction_discontent": {
        "desc": "add_faction_discontent = X adds (or subtracts) discontent to the scope faction",
        "usage": "",
        "supported_scopes": "faction",
        "supported_targets": null,
        "notes": null
    },
    "destroy_faction": {
        "desc": "the scoped faction is destroyed [yes|no]",
        "usage": "",
        "supported_scopes": "faction",
        "supported_targets": null,
        "notes": null
    },
    "every_faction_county_member": {
        "desc": "Iterate through all faction county members",
        "usage": "every_faction_county_member = { limit = { <triggers> } <effects> }",
        "supported_scopes": "faction",
        "supported_targets": "landed_title",
        "notes": null
    },
    "every_faction_member": {
        "desc": "Iterate through all faction character members",
        "usage": "every_faction_member = { limit = { <triggers> } <effects> }",
        "supported_scopes": "faction",
        "supported_targets": "character",
        "notes": null
    },
    "faction_remove_war": {
        "desc": "Removes the war currently associated with the faction",
        "usage": "faction_remove_war = yes",
        "supported_scopes": "faction",
        "supported_targets": null,
        "notes": null
    },
    "faction_start_war": {
        "desc": "The scope faction starts the war agains their target.",
        "usage": "faction_start_war = {\ntitle = [optional]",
        "supported_scopes": "faction",
        "supported_targets": null,
        "notes": null
    },
    "ordered_faction_county_member": {
        "desc": "Iterate through all faction county members",
        "usage": "ordered_faction_county_member = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "faction",
        "supported_targets": "landed_title",
        "notes": null
    },
    "ordered_faction_member": {
        "desc": "Iterate through all faction character members",
        "usage": "ordered_faction_member = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "faction",
        "supported_targets": "character",
        "notes": null
    },
    "random_faction_county_member": {
        "desc": "Iterate through all faction county members",
        "usage": "random_faction_county_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "faction",
        "supported_targets": "landed_title",
        "notes": null
    },
    "random_faction_member": {
        "desc": "Iterate through all faction character members",
        "usage": "random_faction_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "faction",
        "supported_targets": "character",
        "notes": null
    },
    "remove_special_character": {
        "desc": "Removes the special character for the scope faction",
        "usage": "",
        "supported_scopes": "faction",
        "supported_targets": null,
        "notes": null
    },
    "remove_special_title": {
        "desc": "Removes the special character for the scope faction",
        "usage": "",
        "supported_scopes": "faction",
        "supported_targets": null,
        "notes": null
    },
    "set_special_character": {
        "desc": "Sets the special character for the scope faction",
        "usage": "",
        "supported_scopes": "faction",
        "supported_targets": "character",
        "notes": null
    },
    "set_special_title": {
        "desc": "Sets the special title for the scope faction",
        "usage": "",
        "supported_scopes": "faction",
        "supported_targets": "landed_title",
        "notes": null
    },
    "battle_event": {
        "desc": "Makes a battle event show up in combat, and the combat result summary. The key is used for loc, with '_friendly' or '_enemy' appended. If this side is not the player's side, the two portraits get flipped. battle_event = { left_portrait = someone right_portrait = someone key = string }",
        "usage": "",
        "supported_scopes": "combat_side",
        "supported_targets": null,
        "notes": null
    },
    "every_side_commander": {
        "desc": "Iterate through all commanders (the commanders of every army on the side, not just the one leading the battle)",
        "usage": "every_side_commander = { limit = { <triggers> } <effects> }",
        "supported_scopes": "combat_side",
        "supported_targets": "character",
        "notes": null
    },
    "every_side_knight": {
        "desc": "Iterate through all knights",
        "usage": "every_side_knight = { limit = { <triggers> } <effects> }",
        "supported_scopes": "combat_side",
        "supported_targets": "character",
        "notes": null
    },
    "every_side_participant": {
        "desc": "Returns all participants in a combat side",
        "usage": "every_side_participant = { limit = { <triggers> } <effects> }",
        "supported_scopes": "combat_side",
        "supported_targets": "character",
        "notes": null
    },
    "force_win": {
        "desc": "Make the this side of the combat win the combat (or lose if 'force_win = no'), regardless of number of soldiers left. Happens instantly.",
        "usage": "force_win = yes",
        "supported_scopes": "combat_side",
        "supported_targets": null,
        "notes": null
    },
    "ordered_side_commander": {
        "desc": "Iterate through all commanders (the commanders of every army on the side, not just the one leading the battle)",
        "usage": "ordered_side_commander = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "combat_side",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_side_knight": {
        "desc": "Iterate through all knights",
        "usage": "ordered_side_knight = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "combat_side",
        "supported_targets": "character",
        "notes": null
    },
    "ordered_side_participant": {
        "desc": "Returns all participants in a combat side",
        "usage": "ordered_side_participant = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }",
        "supported_scopes": "combat_side",
        "supported_targets": "character",
        "notes": null
    },
    "random_side_commander": {
        "desc": "Iterate through all commanders (the commanders of every army on the side, not just the one leading the battle)",
        "usage": "random_side_commander = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "combat_side",
        "supported_targets": "character",
        "notes": null
    },
    "random_side_knight": {
        "desc": "Iterate through all knights",
        "usage": "random_side_knight = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "combat_side",
        "supported_targets": "character",
        "notes": null
    },
    "random_side_participant": {
        "desc": "Returns all participants in a combat side",
        "usage": "random_side_participant = { limit = { <triggers> } (optional) weight = { mtth } <effects> }",
        "supported_scopes": "combat_side",
        "supported_targets": "character",
        "notes": null
    },
    "set_allow_early_retreat": {
        "desc": "Allow early retreat for one side of the combat. This means if this side loses, it can retreat even if the battle was short. (before NCombat::MIN_DAYS_BEFORE_MANUAL_RETREAT)",
        "usage": "set_allow_early_retreat = yes\nYou can undo this via 'set_allow_early_retreat = no' (which is the default)",
        "supported_scopes": "combat_side",
        "supported_targets": null,
        "notes": null
    },
    "set_disallowed_retreat": {
        "desc": "Disallow retreat for one side of the combat. This means if this side loses, they will take hard casualties.",
        "usage": "set_disallowed_retreat = yes\nYou can undo this via 'set_disallowed_retreat = no' (which is the default)",
        "supported_scopes": "combat_side",
        "supported_targets": null,
        "notes": null
    },
    "set_skip_pursuit": {
        "desc": "Skip pursuit phase for this combat side, if they would lose. This means that they will not take more casualties from pursuit.",
        "usage": "set_skip_pursuit = yes\nYou can undo this via 'set_skip_pursuit = no' (which is the default)",
        "supported_scopes": "combat_side",
        "supported_targets": null,
        "notes": null
    },
    "set_winner": {
        "desc": "Make the a side of a combat become the winner, regardless of number of soldiers left.",
        "usage": "set_winner = yes\nYou can undo this win (this tick) via 'set_winner = no'",
        "supported_scopes": "combat_side",
        "supported_targets": null,
        "notes": "The combat will progress to the pursuit phase the next tick."
    },
    "add_domicile_building": {
        "desc": "Add building to scoped domicile, ignores cost and construction time",
        "usage": "domicile = { add_domicile_building = domicile building key }",
        "supported_scopes": "domicile",
        "supported_targets": null,
        "notes": null
    },
    "change_herd": {
        "desc": "Adds/removes herd to/from a scoped domicile",
        "usage": "",
        "supported_scopes": "domicile",
        "supported_targets": null,
        "notes": null
    },
    "change_provisions": {
        "desc": "Adds (or removes) provisions to a scoped domicile",
        "usage": "",
        "supported_scopes": "domicile",
        "supported_targets": null,
        "notes": null
    },
    "construct_domicile_building": {
        "desc": "Construct building to scoped domicile, ignores cost but uses construction time",
        "usage": "domicile = { construct_domicile_building = domicile building key }",
        "supported_scopes": "domicile",
        "supported_targets": null,
        "notes": null
    },
    "lower_domicile_building": {
        "desc": "Downgrade building to previous from scoped domicile or destroy it if at lowest",
        "usage": "domicile = { lower_domicile_building = domicile building key }",
        "supported_scopes": "domicile",
        "supported_targets": null,
        "notes": null
    },
    "lower_domicile_building_no_refund": {
        "desc": "Downgrade building to previous from scoped domicile or destroy it if at lowest, without refunding",
        "usage": "domicile = { lower_domicile_building = domicile building key }",
        "supported_scopes": "domicile",
        "supported_targets": null,
        "notes": null
    },
    "move_domicile": {
        "desc": "Moves domicile to target location",
        "usage": "domicile = { move_domicile = location }",
        "supported_scopes": "domicile",
        "supported_targets": "province",
        "notes": null
    },
    "remove_domicile_building": {
        "desc": "Remove building from scoped domicile",
        "usage": "domicile = { remove_domicile_building = domicile building key }",
        "supported_scopes": "domicile",
        "supported_targets": null,
        "notes": null
    },
    "remove_domicile_building_no_refund": {
        "desc": "Remove building from scoped domicile without refunding it",
        "usage": "domicile = { remove_domicile_building = domicile building key }",
        "supported_scopes": "domicile",
        "supported_targets": null,
        "notes": null
    },
    "set_domicile_culture": {
        "desc": "Sets the domicile's culture, if it supports it",
        "usage": "",
        "supported_scopes": "domicile",
        "supported_targets": "culture",
        "notes": null
    },
    "set_domicile_faith": {
        "desc": "Sets the domicile's faith, if it supports it",
        "usage": "",
        "supported_scopes": "domicile",
        "supported_targets": "faith",
        "notes": null
    },
    "change_inspiration_progress": {
        "desc": "change_progress = int",
        "usage": "",
        "supported_scopes": "inspiration",
        "supported_targets": null,
        "notes": "Changes the progress of the scoped inspiration"
    },
    "invest_gold": {
        "desc": "invest_gold = value",
        "usage": "",
        "supported_scopes": "inspiration",
        "supported_targets": null,
        "notes": "Invests gold into the scoped inspiration from its sponsor, it handles the removal of the gold from the sponsor, must be a positive value"
    }
}